# Blueprint Precondition Type Definitions
# v3.0.0 - Consolidated types for reduced over-specification

schema_version: "1.0"
category: core
description: Precondition type definitions for workflow conditions

preconditions:
  # ==========================================================================
  # category: core/composite
  # ==========================================================================

  # --------------------------------------------------------------------------
  # all_of
  # --------------------------------------------------------------------------
  all_of:
    category: core/composite
    description:
      brief: All nested conditions must be true (AND)
      detail: |
        Evaluates to true only if all nested conditions evaluate to true.
        Implements logical AND operation with short-circuit evaluation.
      notes:
        - Short-circuits on first false condition
        - Empty conditions array evaluates to true
        - Recursive - nested conditions can be any precondition type

    parameters:
      - name: conditions
        type: array
        required: true
        description: Array of precondition objects
        interpolatable: false

    evaluation:
      effect: |
        for condition in conditions:
          if not evaluate(condition):
            return false
        return true
      reads:
        - "varies by nested conditions"
      functions:
        - evaluate

    since: "1.0.0"

  # --------------------------------------------------------------------------
  # any_of
  # --------------------------------------------------------------------------
  any_of:
    category: core/composite
    description:
      brief: At least one condition must be true (OR)
      detail: |
        Evaluates to true if at least one nested condition evaluates to true.
        Implements logical OR operation with short-circuit evaluation.
      notes:
        - Short-circuits on first true condition
        - Empty conditions array evaluates to false
        - Recursive - nested conditions can be any precondition type

    parameters:
      - name: conditions
        type: array
        required: true
        description: Array of precondition objects
        interpolatable: false

    evaluation:
      effect: |
        for condition in conditions:
          if evaluate(condition):
            return true
        return false
      reads:
        - "varies by nested conditions"
      functions:
        - evaluate

    since: "1.0.0"

  # --------------------------------------------------------------------------
  # none_of
  # --------------------------------------------------------------------------
  none_of:
    category: core/composite
    description:
      brief: No conditions may be true (NOR)
      detail: |
        Evaluates to true only if no nested conditions evaluate to true.
        Implements logical NOR (negated OR) operation.
      notes:
        - Returns false on first true condition
        - Empty conditions array evaluates to true
        - Useful for exclusion checks

    parameters:
      - name: conditions
        type: array
        required: true
        description: Array of precondition objects
        interpolatable: false

    evaluation:
      effect: |
        for condition in conditions:
          if evaluate(condition):
            return false
        return true
      reads:
        - "varies by nested conditions"
      functions:
        - evaluate

    since: "1.0.0"

  # --------------------------------------------------------------------------
  # xor_of
  # --------------------------------------------------------------------------
  xor_of:
    category: core/composite
    description:
      brief: Exactly one condition must be true (XOR)
      detail: |
        Evaluates to true if exactly one nested condition evaluates to true.
        Returns false if zero or more than one condition is true.
        Does not short-circuit - always evaluates all conditions.
      notes:
        - Always evaluates all conditions (no short-circuit)
        - Empty conditions array evaluates to false
        - Useful for mutually exclusive states (e.g., exactly one source type selected)
        - Recursive - nested conditions can be any precondition type

    parameters:
      - name: conditions
        type: array
        required: true
        description: Array of precondition objects
        interpolatable: false

    evaluation:
      effect: |
        true_count = 0
        for condition in conditions:
          if evaluate(condition):
            true_count += 1
        return true_count == 1
      reads:
        - "varies by nested conditions"
      functions:
        - evaluate

    since: "2.0.0"

  # ==========================================================================
  # category: core/expression
  # ==========================================================================

  # --------------------------------------------------------------------------
  # evaluate_expression
  # --------------------------------------------------------------------------
  evaluate_expression:
    category: core/expression
    description:
      brief: Evaluate arbitrary boolean expression
      detail: |
        Evaluates a boolean expression string with access to state variables.
        Supports comparisons, logical operators, and built-in functions.
        Use for complex conditions that don't fit standard precondition types.

        This is the recommended replacement for count_equals, count_above,
        and count_below - use len() function instead.
      notes:
        - "Field access via dot notation: source_type, computed.count"
        - "Comparisons: ==, !=, >, <, >=, <="
        - "Logical: &&, ||, !"
        - "Functions: len(), contains(), startswith(), endswith()"
        - "Use len(field) for array length checks (replaces count_* types)"
        - Use sparingly; prefer typed preconditions when possible

    parameters:
      - name: expression
        type: string
        required: true
        description: Boolean expression to evaluate
        interpolatable: false

    evaluation:
      effect: |
        # Parse and evaluate expression with state context
        result = eval_expression(expression, state)
        return boolean(result)
      reads:
        - "varies by expression content"
      functions:
        - eval_expression
        - len
        - contains
        - startswith
        - endswith

    since: "1.0.0"

  # ==========================================================================
  # category: core/state
  # ==========================================================================

  # --------------------------------------------------------------------------
  # state_check
  # --------------------------------------------------------------------------
  state_check:
    category: core/state
    description:
      brief: Check state field values with various operators
      detail: |
        Unified state inspection precondition. The operator parameter determines
        what type of check is performed on the specified field.

        For flags, use field "flags.flag_name" with operator "true" or "false".
      notes:
        - "operator: equals - field equals value"
        - "operator: not_equals - field does not equal value"
        - "operator: null - field is null or undefined"
        - "operator: not_null - field has a value"
        - "operator: true - field is boolean true (for flags)"
        - "operator: false - field is boolean false (for flags)"
        - Supports dot notation for nested fields

    parameters:
      - name: field
        type: string
        required: true
        description: State field path (dot notation for nested, e.g., "flags.initialized")
        pattern: "^[a-zA-Z_][a-zA-Z0-9_.]*$"
        interpolatable: false

      - name: operator
        type: string
        required: true
        description: "Comparison operator: equals, not_equals, null, not_null, true, false"
        enum:
          - equals
          - not_equals
          - "null"
          - not_null
          - "true"
          - "false"
        interpolatable: false

      - name: value
        type: any
        required: false
        description: Value for equals/not_equals operators
        interpolatable: false

    evaluation:
      effect: |
        actual = get_state_value(field)

        if operator == "equals":
          return actual == value

        elif operator == "not_equals":
          return actual != value

        elif operator == "null":
          return actual == null

        elif operator == "not_null":
          return actual != null

        elif operator == "true":
          return actual == true

        elif operator == "false":
          return actual != true
      reads:
        - "state.${field}"
      functions:
        - get_state_value

    since: "3.0.0"
    replaces:
      - flag_set
      - flag_not_set
      - state_equals
      - state_not_null
      - state_is_null

  # ==========================================================================
  # category: core/tools
  # ==========================================================================

  # --------------------------------------------------------------------------
  # tool_check
  # --------------------------------------------------------------------------
  tool_check:
    category: core/tools
    description:
      brief: Check tool availability, version, auth, or daemon status
      detail: |
        Unified tool inspection precondition. The capability parameter determines
        what aspect of the tool is checked.
      notes:
        - "capability: available - tool exists in PATH"
        - "capability: version_gte - tool version >= args.min_version"
        - "capability: authenticated - tool is authenticated (for gh, aws, etc.)"
        - "capability: daemon_ready - tool's daemon is running (for docker, etc.)"
        - Returns true for tools that don't need auth/daemon

    parameters:
      - name: tool
        type: string
        required: true
        description: Tool name (command name)
        pattern: "^[a-zA-Z0-9_-]+$"
        interpolatable: false

      - name: capability
        type: string
        required: true
        description: "Capability to check: available, version_gte, authenticated, daemon_ready"
        enum:
          - available
          - version_gte
          - authenticated
          - daemon_ready
        interpolatable: false

      - name: args
        type: object
        required: false
        description: "Capability-specific args: {min_version: '2.0'} for version_gte"
        interpolatable: false

    evaluation:
      effect: |
        if capability == "available":
          exit_code = shell("which ${tool} >/dev/null 2>&1")
          return exit_code == 0

        elif capability == "version_gte":
          if not tool_available(tool):
            return false
          version_output = shell(tool + " --version 2>&1")
          installed_version = extract_version(version_output, tool)
          if installed_version == null:
            return true  # Can't determine version, assume OK
          return compare_versions(installed_version, args.min_version) >= 0

        elif capability == "authenticated":
          if not tool_available(tool):
            return false
          auth_check = get_auth_check(tool)  # From registry
          if auth_check == null:
            return true  # No auth required
          exit_code = shell(auth_check + " >/dev/null 2>&1")
          return exit_code == 0

        elif capability == "daemon_ready":
          if not tool_available(tool):
            return false
          daemon_check = get_daemon_check(tool)  # From registry
          if daemon_check == null:
            return true  # No daemon required
          exit_code = shell(daemon_check)
          return exit_code == 0
      reads: []
      functions:
        - shell
        - tool_available
        - extract_version
        - compare_versions
        - get_auth_check
        - get_daemon_check

    since: "3.0.0"
    replaces:
      - tool_available
      - tool_version_gte
      - tool_authenticated
      - tool_daemon_ready

  # ==========================================================================
  # category: core/filesystems
  # ==========================================================================

  # --------------------------------------------------------------------------
  # path_check
  # --------------------------------------------------------------------------
  path_check:
    category: core/filesystems
    description:
      brief: Check file or directory existence and properties
      detail: |
        Unified filesystem precondition for checking paths. The check parameter
        determines what is verified about the path.

        Replaces config_exists, index_exists, index_is_placeholder, file_exists,
        and directory_exists.
      notes:
        - "check: exists - path exists (file or directory)"
        - "check: is_file - path exists and is a file"
        - "check: is_directory - path exists and is a directory"
        - "check: contains_text - file contains specified text (args.pattern)"
        - Path supports ${} interpolation

    parameters:
      - name: path
        type: string
        required: true
        description: File or directory path (relative to root)
        interpolatable: true

      - name: check
        type: string
        required: true
        description: "Check type: exists, is_file, is_directory, contains_text"
        enum:
          - exists
          - is_file
          - is_directory
          - contains_text
        interpolatable: false

      - name: args
        type: object
        required: false
        description: "Check-specific args: {pattern: 'text'} for contains_text"
        interpolatable: true

    evaluation:
      effect: |
        resolved_path = interpolate(path)

        if check == "exists":
          return path_exists(resolved_path)

        elif check == "is_file":
          return file_exists(resolved_path)

        elif check == "is_directory":
          return directory_exists(resolved_path)

        elif check == "contains_text":
          if not file_exists(resolved_path):
            return false
          content = read_file(resolved_path)
          return args.pattern in content
      reads:
        - "${path}"
      functions:
        - path_exists
        - file_exists
        - directory_exists
        - read_file
        - interpolate

    since: "3.0.0"
    replaces:
      - config_exists
      - index_exists
      - index_is_placeholder
      - file_exists
      - directory_exists

  # ==========================================================================
  # category: core/logging
  # ==========================================================================

  # --------------------------------------------------------------------------
  # log_state
  # --------------------------------------------------------------------------
  log_state:
    category: core/logging
    description:
      brief: Check logging lifecycle state
      detail: |
        Unified logging state precondition. The aspect parameter determines
        what part of the logging lifecycle is checked.
      notes:
        - "aspect: initialized - init_log has been called"
        - "aspect: finalized - finalize_log has been called"
        - "aspect: level_enabled - current log level includes args.level"
        - Level hierarchy: error < warn < info < debug < trace

    parameters:
      - name: aspect
        type: string
        required: true
        description: "Logging aspect to check: initialized, finalized, level_enabled"
        enum:
          - initialized
          - finalized
          - level_enabled
        interpolatable: false

      - name: args
        type: object
        required: false
        description: "Aspect-specific args: {level: 'debug'} for level_enabled"
        interpolatable: false

    evaluation:
      effect: |
        if aspect == "initialized":
          return state.flags.log_initialized == true

        elif aspect == "finalized":
          return state.flags.log_finalized == true

        elif aspect == "level_enabled":
          level_hierarchy = ["error", "warn", "info", "debug", "trace"]
          current_level = get_log_config("level")
          current_index = level_hierarchy.index(current_level)
          check_index = level_hierarchy.index(args.level)
          return current_index >= check_index
      reads:
        - "state.flags.log_initialized"
        - "state.flags.log_finalized"
        - "state.logging.level"
      functions:
        - get_log_config

    since: "3.0.0"
    replaces:
      - log_initialized
      - log_level_enabled
      - log_finalized

  # ==========================================================================
  # category: core/python
  # ==========================================================================

  # --------------------------------------------------------------------------
  # python_module_available
  # --------------------------------------------------------------------------
  python_module_available:
    category: core/python
    description:
      brief: Check if Python module is installed
      detail: |
        Evaluates to true if the specified Python module can be imported.
        Uses `python3 -c "import module"` to check.
      notes:
        - Uses python3 interpreter
        - Module must be importable (installed in environment)
        - "Common modules: yaml, pymupdf, requests"

    parameters:
      - name: module
        type: string
        required: true
        description: Python module name
        pattern: "^[a-zA-Z_][a-zA-Z0-9_.]*$"
        interpolatable: false

    evaluation:
      effect: |
        exit_code = shell("python3 -c 'import ${module}' 2>/dev/null")
        return exit_code == 0
      reads: []
      functions:
        - shell

    since: "1.0.0"

  # ==========================================================================
  # category: core/network
  # ==========================================================================

  # --------------------------------------------------------------------------
  # network_available
  # --------------------------------------------------------------------------
  network_available:
    category: core/network
    description:
      brief: Check if network access is available
      detail: |
        Evaluates to true if network connectivity is available. Can check
        general connectivity (default github.com) or a specific target URL.
        Uses curl with a short timeout to avoid blocking.
      notes:
        - Uses curl with 5 second timeout
        - Defaults to checking github.com
        - Can specify custom target URL
        - Returns false on timeout or connection failure

    parameters:
      - name: target
        type: string
        required: false
        description: URL to check (defaults to https://github.com)
        interpolatable: true
        default: "https://github.com"

    evaluation:
      effect: |
        url = target or "https://github.com"
        exit_code = shell("curl -s --max-time 5 -o /dev/null -w '%{http_code}' " + url + " >/dev/null")
        return exit_code == 0
      reads: []
      functions:
        - shell

    since: "2.0.0"

  # ==========================================================================
  # category: core/git
  # ==========================================================================

  # --------------------------------------------------------------------------
  # source_check
  # --------------------------------------------------------------------------
  source_check:
    category: core/git
    description:
      brief: Check source repository status
      detail: |
        Unified source repository precondition. The aspect parameter determines
        what is checked about the source.
      notes:
        - "aspect: exists - source ID is defined in config.yaml"
        - "aspect: cloned - .source/{id}/ directory exists"
        - "aspect: has_updates - git source has new remote commits (network op)"
        - ID supports ${} interpolation

    parameters:
      - name: source_id
        type: string
        required: true
        description: Source identifier
        pattern: "^[a-zA-Z0-9_-]+$"
        interpolatable: true

      - name: aspect
        type: string
        required: true
        description: "Aspect to check: exists, cloned, has_updates"
        enum:
          - exists
          - cloned
          - has_updates
        interpolatable: false

    evaluation:
      effect: |
        resolved_id = interpolate(source_id)

        if aspect == "exists":
          config = load_yaml("data/config.yaml")
          return config.sources.any(s => s.id == resolved_id)

        elif aspect == "cloned":
          return directory_exists(".source/" + resolved_id)

        elif aspect == "has_updates":
          source_path = ".source/" + resolved_id

          # Fetch latest
          shell("git -C " + source_path + " fetch --quiet")

          # Compare
          local_sha = shell("git -C " + source_path + " rev-parse HEAD")
          remote_sha = shell("git -C " + source_path + " rev-parse @{u}")

          return local_sha != remote_sha
      reads:
        - "data/config.yaml"
        - ".source/${source_id}"
      functions:
        - load_yaml
        - directory_exists
        - shell
        - interpolate

    since: "3.0.0"
    replaces:
      - source_exists
      - source_cloned
      - source_has_updates

  # ==========================================================================
  # category: core/web_fetch
  # ==========================================================================

  # --------------------------------------------------------------------------
  # fetch_check
  # --------------------------------------------------------------------------
  fetch_check:
    category: core/web_fetch
    description:
      brief: Check web fetch result status
      detail: |
        Unified web fetch result precondition. The aspect parameter determines
        what is checked about a previous fetch result stored in state.
      notes:
        - "aspect: succeeded - fetch result has 2xx status"
        - "aspect: has_content - fetch result has non-empty content"
        - Checks result stored by web_ops consequence

    parameters:
      - name: from
        type: string
        required: true
        description: State field containing fetch result
        pattern: "^[a-zA-Z_][a-zA-Z0-9_.]*$"
        interpolatable: false

      - name: aspect
        type: string
        required: true
        description: "Aspect to check: succeeded, has_content"
        enum:
          - succeeded
          - has_content
        interpolatable: false

    evaluation:
      effect: |
        result = get_state_value(from)
        if result == null:
          return false

        if aspect == "succeeded":
          status = result.status
          return status >= 200 and status < 300

        elif aspect == "has_content":
          content = result.content
          return content != null and len(content) > 0
      reads:
        - "state.${from}"
      functions:
        - get_state_value
        - len

    since: "3.0.0"
    replaces:
      - fetch_succeeded
      - fetch_returned_content
