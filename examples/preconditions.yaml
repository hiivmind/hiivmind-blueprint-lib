# Precondition Examples
# Documentary usage patterns for precondition types
# v3.0.0 - Updated for consolidated types
#
# These examples are for human reference, not automated testing.

schema_version: "1.0"
description: |
  Example usage patterns for precondition types.
  These are documentary snippets for workflow authors.

examples:
  # ==========================================================================
  # core/composite - Logical combinators
  # ==========================================================================
  core/composite:
    all_of:
      - title: "All conditions must be true (AND)"
        yaml: |
          condition:
            type: all_of
            conditions:
              - type: path_check
                path: "config.yaml"
                check: is_file
              - type: tool_check
                tool: git
                capability: available
              - type: tool_check
                tool: yq
                capability: available
        explanation: |
          Evaluates to true only if ALL conditions are true.
          Short-circuits on first false condition.

      - title: "Nested composite conditions"
        yaml: |
          condition:
            type: all_of
            conditions:
              - type: path_check
                path: "data/config.yaml"
                check: is_file
              - type: any_of
                conditions:
                  - type: tool_check
                    tool: yq
                    capability: available
                  - type: python_module_available
                    module: yaml
        explanation: |
          Composite conditions can be nested.
          Config must exist AND at least one YAML processor available.

    any_of:
      - title: "At least one condition true (OR)"
        yaml: |
          condition:
            type: any_of
            conditions:
              - type: tool_check
                tool: yq
                capability: available
              - type: tool_check
                tool: jq
                capability: available
              - type: python_module_available
                module: yaml
        explanation: |
          Evaluates to true if ANY condition is true.
          Short-circuits on first true condition.

    none_of:
      - title: "No conditions may be true (NOR)"
        yaml: |
          condition:
            type: none_of
            conditions:
              - type: path_check
                path: ".lock"
                check: exists
              - type: state_check
                field: flags.operation_in_progress
                operator: "true"
        explanation: |
          Evaluates to true only if NO conditions are true.
          Useful for exclusion checks.

    xor_of:
      - title: "Exactly one condition must be true (XOR)"
        yaml: |
          condition:
            type: xor_of
            conditions:
              - type: state_check
                field: flags.is_git_source
                operator: "true"
              - type: state_check
                field: flags.is_local_source
                operator: "true"
              - type: state_check
                field: flags.is_web_source
                operator: "true"
        explanation: |
          Evaluates to true if EXACTLY one condition is true.
          Does not short-circuit - always evaluates all conditions.
          Useful for mutually exclusive states.

  # ==========================================================================
  # core/expression - Arbitrary expression evaluation
  # ==========================================================================
  core/expression:
    evaluate_expression:
      - title: "Check array length (replaces count_equals)"
        yaml: |
          condition:
            type: evaluate_expression
            expression: "len(computed.sources) == 0"
        explanation: |
          Use len() for array length checks.
          Replaces the old count_equals precondition.

      - title: "Check array has items (replaces count_above)"
        yaml: |
          condition:
            type: evaluate_expression
            expression: "len(computed.sources) > 0"
        explanation: |
          Use len() with comparison for count checks.
          Replaces the old count_above precondition.

      - title: "Complex condition"
        yaml: |
          condition:
            type: evaluate_expression
            expression: "computed.file_count > 100 && source_type == 'git'"
        explanation: |
          Combine multiple checks with logical operators.

      - title: "String matching"
        yaml: |
          condition:
            type: evaluate_expression
            expression: "startswith(computed.url, 'https://github.com')"
        explanation: |
          Use built-in string functions for matching.

  # ==========================================================================
  # core/filesystems - File and directory checks
  # ==========================================================================
  core/filesystems:
    path_check:
      - title: "Check for config file"
        yaml: |
          condition:
            type: path_check
            path: "data/config.yaml"
            check: is_file
        explanation: |
          Evaluates to true if file exists at path.
          Path supports ${} interpolation.

      - title: "Check with interpolated path"
        yaml: |
          condition:
            type: path_check
            path: "${computed.output_dir}/index.md"
            check: exists
        explanation: |
          Path can include interpolated state values.

      - title: "Check for source directory"
        yaml: |
          condition:
            type: path_check
            path: ".source/${computed.source_id}"
            check: is_directory
        explanation: |
          Evaluates to true if directory exists.
          Returns false if path is a file.

      - title: "Check for corpus config (was config_exists)"
        yaml: |
          condition:
            type: path_check
            path: "data/config.yaml"
            check: is_file
        explanation: |
          Convenience pattern for data/config.yaml.
          Replaces the old config_exists type.

      - title: "Check for built index (was index_exists)"
        yaml: |
          condition:
            type: path_check
            path: "data/index.md"
            check: is_file
        explanation: |
          Convenience pattern for data/index.md.
          Replaces the old index_exists type.

      - title: "Check if index needs building (was index_is_placeholder)"
        yaml: |
          condition:
            type: path_check
            path: "data/index.md"
            check: contains_text
            args:
              pattern: "Run hiivmind-corpus-build"
        explanation: |
          True if index contains placeholder text.
          Replaces the old index_is_placeholder type.

  # ==========================================================================
  # core/logging - Logging state checks
  # ==========================================================================
  core/logging:
    log_state:
      - title: "Check if logging is ready"
        yaml: |
          condition:
            type: log_state
            aspect: initialized
        explanation: |
          True if init_log has been called.
          Required before log_node, log_entry, etc.

      - title: "Check if debug logging enabled"
        yaml: |
          condition:
            type: log_state
            aspect: level_enabled
            args:
              level: debug
        explanation: |
          True if current log level includes debug.
          Level hierarchy: error < warn < info < debug < trace

      - title: "Check if log is complete"
        yaml: |
          condition:
            type: log_state
            aspect: finalized
        explanation: |
          True if finalize_log has been called.
          Required before write_log.

  # ==========================================================================
  # core/state - State inspection
  # ==========================================================================
  core/state:
    state_check:
      - title: "Check boolean flag (was flag_set)"
        yaml: |
          condition:
            type: state_check
            field: flags.config_loaded
            operator: "true"
        explanation: |
          True if flags.config_loaded is true.
          Replaces the old flag_set type.

      - title: "Check flag is false or undefined (was flag_not_set)"
        yaml: |
          condition:
            type: state_check
            field: flags.error_occurred
            operator: "false"
        explanation: |
          True if flag is false, undefined, or null.
          Replaces the old flag_not_set type.

      - title: "Check state field value (was state_equals)"
        yaml: |
          condition:
            type: state_check
            field: source_type
            operator: equals
            value: git
        explanation: |
          True if field equals specified value.
          Supports dot notation for nested fields.

      - title: "Check nested field"
        yaml: |
          condition:
            type: state_check
            field: computed.config.version
            operator: equals
            value: 2
        explanation: |
          Access nested fields with dot notation.

      - title: "Check field has value (was state_not_null)"
        yaml: |
          condition:
            type: state_check
            field: computed.repo_url
            operator: not_null
        explanation: |
          True for any non-null value including empty strings.

      - title: "Check field is empty (was state_is_null)"
        yaml: |
          condition:
            type: state_check
            field: computed.error
            operator: "null"
        explanation: |
          True if field is null or undefined.

  # ==========================================================================
  # core/tools - Tool availability
  # ==========================================================================
  core/tools:
    tool_check:
      - title: "Check for required tool (was tool_available)"
        yaml: |
          condition:
            type: tool_check
            tool: git
            capability: available
        explanation: |
          True if tool is available in PATH.
          Uses 'which' to check availability.

      - title: "Check tool version (was tool_version_gte)"
        yaml: |
          condition:
            type: tool_check
            tool: git
            capability: version_gte
            args:
              min_version: "2.0"
        explanation: |
          True if installed version >= min_version.
          Falls back to existence check if version unknown.

      - title: "Check for authenticated tool (was tool_authenticated)"
        yaml: |
          condition:
            type: tool_check
            tool: gh
            capability: authenticated
        explanation: |
          True if tool is available AND authenticated.
          Returns true for tools that don't require auth.

      - title: "Check for running daemon (was tool_daemon_ready)"
        yaml: |
          condition:
            type: tool_check
            tool: docker
            capability: daemon_ready
        explanation: |
          True if daemon-based tool is ready.
          Checks both availability and daemon status.

  # ==========================================================================
  # core/network - Network connectivity
  # ==========================================================================
  core/network:
    network_available:
      - title: "Check internet connectivity"
        yaml: |
          condition:
            type: network_available
        explanation: |
          True if network is available.
          Defaults to checking github.com.

      - title: "Check specific endpoint"
        yaml: |
          condition:
            type: network_available
            target: "https://api.example.com/health"
        explanation: |
          Check connectivity to specific URL.
          Uses 5 second timeout.

  # ==========================================================================
  # core/python - Python module availability
  # ==========================================================================
  core/python:
    python_module_available:
      - title: "Check for Python module"
        yaml: |
          condition:
            type: python_module_available
            module: yaml
        explanation: |
          True if Python module can be imported.
          Uses python3 interpreter.

  # ==========================================================================
  # core/git - Source repository checks
  # ==========================================================================
  core/git:
    source_check:
      - title: "Check if source is configured (was source_exists)"
        yaml: |
          condition:
            type: source_check
            source_id: "${computed.source_id}"
            aspect: exists
        explanation: |
          True if source ID exists in config.yaml.
          Does not verify source is cloned.

      - title: "Check if source is cloned (was source_cloned)"
        yaml: |
          condition:
            type: source_check
            source_id: polars
            aspect: cloned
        explanation: |
          True if .source/{id}/ directory exists.

      - title: "Check for upstream changes (was source_has_updates)"
        yaml: |
          condition:
            type: source_check
            source_id: "${computed.source_id}"
            aspect: has_updates
        explanation: |
          True if git source has new remote commits.
          Performs network operation (git fetch).

  # ==========================================================================
  # core/web_fetch - Web fetch result checks
  # ==========================================================================
  core/web_fetch:
    fetch_check:
      - title: "Check previous fetch succeeded (was fetch_succeeded)"
        yaml: |
          condition:
            type: fetch_check
            from: computed.page_fetch
            aspect: succeeded
        explanation: |
          True if fetch result has 2xx status.
          Checks result stored from web_ops consequence.

      - title: "Check fetch has content (was fetch_returned_content)"
        yaml: |
          condition:
            type: fetch_check
            from: computed.page_fetch
            aspect: has_content
        explanation: |
          True if fetch result has non-empty content.
          More specific than succeeded check.
