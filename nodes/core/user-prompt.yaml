# User Prompt Node Type Definition
# Presents a question and routes based on response
# Supports interactive (AskUserQuestion) and tabular (markdown table) modes

schema_version: "2.0"
category: core

nodes:
  - type: user_prompt
    description:
      brief: Presents a question and routes based on user response
      detail: |
        A user_prompt node presents a question to the user and routes based on their
        response. Each response option can optionally execute consequences before
        routing to the next node.

        Execution mode is configured via initial_state.prompts:
        - interactive (default) - Uses AskUserQuestion tool for structured prompts
        - tabular - Renders markdown table, parses user text response

        This enables user-driven branching in workflows while maintaining deterministic
        behavior once a choice is made.
      notes:
        - "Mode configured in initial_state.prompts (default: interactive)"
        - "Interactive mode maps to Claude Code's AskUserQuestion tool"
        - "Tabular mode renders markdown table and matches user text to option IDs"
        - "Header must be 12 characters or less"
        - "Options array should have 2-4 items"
        - "User responses are stored in state.user_responses"
        - "Each response handler can execute consequences before routing"
        - "Tabular mode supports match strategies: exact, prefix, fuzzy"
        - "When using tabular mode with other_handler: route, on_response.other is required"

    fields:
      - name: type
        type: string
        required: true
        value: "user_prompt"
        description: Node type discriminator

      - name: prompt
        type: object
        required: true
        description: Question configuration
        properties:
          - name: question
            type: string
            required: true
            description: The question text to display to the user

          - name: header
            type: string
            required: true
            max_length: 12
            description: Short label displayed as a chip/tag (max 12 characters)

          - name: options
            type: array
            required_unless: options_from_state
            min_items: 2
            max_items: 4
            description: Static choices for the user (mutually exclusive with options_from_state)
            items:
              type: object
              properties:
                - name: id
                  type: string
                  required: true
                  description: Unique identifier for this option, used in on_response

                - name: label
                  type: string
                  required: true
                  description: Display text the user sees and selects

                - name: description
                  type: string
                  required: true
                  description: Explanation of what this option means or does

          - name: options_from_state
            type: string
            required_unless: options
            description: |
              State path containing an array of items to use as dynamic options.
              Use with option_mapping to transform items into option format.
              Example: "computed.intent_matches.top_candidates"

          - name: option_mapping
            type: object
            required_with: options_from_state
            description: |
              Expressions to transform each item from options_from_state into an option.
              Each expression is evaluated in the context of the current array item.
            properties:
              - name: id
                type: string
                required: true
                description: Expression for option ID (e.g., "rule.name")

              - name: label
                type: string
                required: true
                description: Expression for display label (e.g., "rule.name")

              - name: description
                type: string
                required: true
                description: Expression for description (e.g., "rule.description")

      - name: on_response
        type: object
        required: true
        description: |
          Map of option id to response handler. Each handler specifies the next_node
          and optionally a consequence array to execute before routing.

          For static options: Use option IDs as keys (e.g., "git", "local", "web").
          For dynamic options: Use special keys "selected" and "other".
        additionalProperties:
          type: object
          properties:
            - name: consequence
              type: array
              items: consequence
              required: false
              description: Optional consequences to execute before routing

            - name: next_node
              type: node_reference
              required: true
              description: Node or ending to route to after this response
        reserved_keys:
          - name: selected
            description: |
              Handler invoked when user selects any option from a dynamic options list.
              The selected item is available at user_responses.{node_id}.selected
            for: options_from_state

          - name: other
            description: |
              Handler invoked when user enters custom text (via "Other" option).
              The text is available at user_responses.{node_id}.text
            for: options_from_state

    execution:
      effect: |
        # Get prompts configuration (defaults to interactive mode)
        prompts_config = state.prompts or { mode: "interactive" }
        mode = prompts_config.mode or "interactive"

        # Determine options source (static vs dynamic)
        options = resolve_options(node, state)

        # Execute based on mode
        if mode == "interactive":
          return execute_interactive_mode(node, options, state)
        else if mode == "tabular":
          return execute_tabular_mode(node, options, state, prompts_config.tabular or {})
        else:
          throw Error("Unknown prompt mode: " + mode)

      helpers:
        resolve_options: |
          FUNCTION resolve_options(node, state):
            if node.prompt.options_from_state:
              # Dynamic options: resolve from state and transform via mapping
              source_items = get_state_value(node.prompt.options_from_state)
              if source_items == null or source_items.length == 0:
                throw Error("options_from_state resolved to empty array")

              mapping = node.prompt.option_mapping
              return source_items.map((item, index) => ({
                id: evaluate_expression(mapping.id, item) or ("dynamic_" + index),
                label: evaluate_expression(mapping.label, item),
                description: evaluate_expression(mapping.description, item),
                _source_item: item  # Preserve original item for handler
              }))
            else:
              # Static options: use as-is
              return node.prompt.options

        execute_interactive_mode: |
          FUNCTION execute_interactive_mode(node, options, state):
            # Build AskUserQuestion payload
            question_payload = {
              questions: [{
                question: node.prompt.question,
                header: node.prompt.header,
                options: options.map(opt => ({
                  label: opt.label,
                  description: opt.description
                })),
                multiSelect: false
              }]
            }

            # Present question and await response
            response = call_tool("AskUserQuestion", question_payload)

            # Handle response and route
            return handle_response(node, options, response, state, "interactive")

        execute_tabular_mode: |
          FUNCTION execute_tabular_mode(node, options, state, tabular_config):
            # Check if resuming from awaiting_input
            if state.awaiting_input and state.awaiting_input.node_id == node_id:
              # Resuming - user_input contains their text response
              user_input = state.awaiting_input.user_input
              state.awaiting_input = null  # Clear awaiting state

              # Match user input to options
              match_result = match_user_input_to_option(user_input, options, tabular_config)

              if match_result.matched:
                # Found a match
                response = { selected_id: match_result.option_id, text: user_input }
                return handle_response(node, options, response, state, "tabular", match_result)
              else:
                # No match - handle based on other_handler config
                other_handler = tabular_config.other_handler or "prompt"

                if other_handler == "prompt":
                  # Re-display table and re-prompt
                  render_no_match_message(user_input)
                  render_options_table(node.prompt.question, options, tabular_config)
                  state.awaiting_input = { node_id: node_id, type: "tabular" }
                  return { awaiting_input: true }

                else if other_handler == "route":
                  # Route to "other" handler
                  if not node.on_response["other"]:
                    throw Error("other_handler is 'route' but on_response.other not defined")
                  state.user_responses[node_id] = { handler_id: "other", text: user_input }
                  handler = node.on_response["other"]
                  return execute_handler_and_route(handler, state)

                else if other_handler == "fail":
                  throw Error("No matching option for input: " + user_input)

            else:
              # First execution - render table and await input
              render_options_table(node.prompt.question, options, tabular_config)
              state.awaiting_input = { node_id: node_id, type: "tabular" }
              return { awaiting_input: true }

        render_options_table: |
          FUNCTION render_options_table(question, options, tabular_config):
            show_ids = tabular_config.show_option_ids != false
            instruction = tabular_config.instruction_text or "**Please type the Option ID of your choice.**"

            # Render question as heading
            DISPLAY "## " + question
            DISPLAY ""

            # Render table header
            if show_ids:
              DISPLAY "| Option ID | Label | Description |"
              DISPLAY "|-----------|-------|-------------|"
            else:
              DISPLAY "| Label | Description |"
              DISPLAY "|-------|-------------|"

            # Render options
            for opt in options:
              if show_ids:
                DISPLAY "| " + opt.id + " | " + opt.label + " | " + opt.description + " |"
              else:
                DISPLAY "| " + opt.label + " | " + opt.description + " |"

            DISPLAY ""
            DISPLAY instruction

        render_no_match_message: |
          FUNCTION render_no_match_message(user_input):
            DISPLAY "I didn't recognize \"" + user_input + "\" as a valid option."
            DISPLAY ""

        match_user_input_to_option: |
          FUNCTION match_user_input_to_option(user_input, options, tabular_config):
            strategy = tabular_config.match_strategy or "prefix"
            case_sensitive = tabular_config.case_sensitive or false

            # Normalize input
            input = case_sensitive ? user_input : user_input.toLowerCase()
            input = input.trim()

            for opt in options:
              opt_id = case_sensitive ? opt.id : opt.id.toLowerCase()

              if strategy == "exact":
                if input == opt_id:
                  return { matched: true, option_id: opt.id, strategy: "exact" }

              else if strategy == "prefix":
                if opt_id.startsWith(input) or input.startsWith(opt_id):
                  return { matched: true, option_id: opt.id, strategy: "prefix" }

              else if strategy == "fuzzy":
                threshold = tabular_config.fuzzy_threshold or 0.7
                similarity = calculate_similarity(input, opt_id)
                if similarity >= threshold:
                  return { matched: true, option_id: opt.id, strategy: "fuzzy", similarity: similarity }

            return { matched: false }

        calculate_similarity: |
          FUNCTION calculate_similarity(str1, str2):
            # Levenshtein distance normalized to similarity score
            # Returns value between 0.0 and 1.0
            max_len = max(str1.length, str2.length)
            if max_len == 0:
              return 1.0
            distance = levenshtein_distance(str1, str2)
            return 1.0 - (distance / max_len)

        handle_response: |
          FUNCTION handle_response(node, options, response, state, mode, match_result = null):
            # Determine handler based on response and options type
            if node.prompt.options_from_state:
              # Dynamic options handling
              if response.is_other or (mode == "tabular" and not match_result):
                state.user_responses[node_id] = { handler_id: "other", text: response.text }
                handler = node.on_response["other"]
              else:
                selected_id = response.selected_id or find_selected_option_id(response, options)
                selected_opt = options.find(opt => opt.id == selected_id)
                state.user_responses[node_id] = {
                  handler_id: "selected",
                  selected: selected_opt._source_item,
                  raw: { text: response.text, matched_by: match_result?.strategy }
                }
                handler = node.on_response["selected"]
            else:
              # Static options handling
              selected_id = response.selected_id or find_selected_option_id(response, options)
              state.user_responses[node_id] = {
                handler_id: selected_id,
                raw: { text: response.text, matched_by: match_result?.strategy }
              }
              handler = node.on_response[selected_id]

            return execute_handler_and_route(handler, state)

        execute_handler_and_route: |
          FUNCTION execute_handler_and_route(handler, state):
            # Execute consequences if present
            if handler.consequence:
              for consequence in handler.consequence:
                result = dispatch_consequence(consequence, state)
                if result.failed:
                  return route_to_error(result.error)

            # Route to next node
            return route_to(handler.next_node)

      state_reads:
        - "state.prompts (for mode configuration)"
        - "state.awaiting_input (for tabular mode resumption)"
        - "Any fields referenced via ${} in consequence parameters"
        - "options_from_state path (if using dynamic options)"
      state_writes:
        - "user_responses.${node_id}"
        - "awaiting_input (set when awaiting tabular input, cleared when received)"
        - "Additional writes from consequence execution"

    examples:
      - title: Basic source type selection
        yaml: |
          ask_source_type:
            type: user_prompt
            prompt:
              question: "What type of source would you like to add?"
              header: "Source"
              options:
                - id: git
                  label: "Git repository"
                  description: "Clone a repository with docs folder"
                - id: local
                  label: "Local files"
                  description: "Files on your machine"
                - id: web
                  label: "Web pages"
                  description: "Cache blog posts or articles"
            on_response:
              git:
                consequence:
                  - type: set_state
                    field: source_type
                    value: git
                next_node: collect_git_url
              local:
                consequence:
                  - type: set_state
                    field: source_type
                    value: local
                next_node: collect_local_info
              web:
                consequence:
                  - type: set_state
                    field: source_type
                    value: web
                next_node: collect_web_urls
        explanation: |
          Presents three options to the user. Based on selection, sets the source_type
          state field and routes to the appropriate collection node.

      - title: Confirmation prompt
        yaml: |
          confirm_delete:
            type: user_prompt
            prompt:
              question: "Are you sure you want to delete this source?"
              header: "Confirm"
              options:
                - id: yes
                  label: "Yes, delete"
                  description: "Permanently remove the source"
                - id: no
                  label: "Cancel"
                  description: "Keep the source unchanged"
            on_response:
              yes:
                next_node: execute_delete
              no:
                next_node: cancelled

      - title: Route without consequence
        yaml: |
          select_output_format:
            type: user_prompt
            prompt:
              question: "Which output format do you prefer?"
              header: "Format"
              options:
                - id: markdown
                  label: "Markdown"
                  description: "Portable, readable in any editor"
                - id: json
                  label: "JSON"
                  description: "Machine-readable, for automation"
            on_response:
              markdown:
                next_node: generate_markdown
              json:
                next_node: generate_json

      - title: Dynamic options from state (disambiguation)
        yaml: |
          show_disambiguation:
            type: user_prompt
            description: Present top candidates for user selection
            prompt:
              question: "Multiple intents detected. Which did you mean?"
              header: "Clarify"
              options_from_state: computed.intent_matches.top_candidates
              option_mapping:
                id: rule.name
                label: rule.name
                description: rule.description
            on_response:
              selected:
                # User selected one of the dynamic options
                consequence:
                  - type: set_state
                    field: computed.matched_action
                    value: "${user_responses.show_disambiguation.selected.rule.action}"
                next_node: success_resolved
              other:
                # User typed custom text - re-parse with new input
                consequence:
                  - type: set_state
                    field: arguments
                    value: "${user_responses.show_disambiguation.text}"
                next_node: parse_intent_flags
        explanation: |
          Uses dynamic options from state array. The option_mapping transforms each
          candidate into an option. When user selects, the original item is available
          at user_responses.{node_id}.selected. When user types custom text, it's
          available at user_responses.{node_id}.text.

      - title: Tabular mode with prefix matching
        yaml: |
          # Workflow-level configuration in initial_state
          initial_state:
            prompts:
              mode: "tabular"
              tabular:
                match_strategy: "prefix"
                other_handler: "prompt"

          # Node definition (same structure as interactive mode)
          select_output_format:
            type: user_prompt
            prompt:
              question: "Which output format do you prefer?"
              header: "Format"
              options:
                - id: markdown
                  label: "Markdown"
                  description: "Portable, readable in any editor"
                - id: json
                  label: "JSON"
                  description: "Machine-readable, for automation"
                - id: yaml
                  label: "YAML"
                  description: "Structured and human-readable"
            on_response:
              markdown:
                next_node: generate_markdown
              json:
                next_node: generate_json
              yaml:
                next_node: generate_yaml
        explanation: |
          Tabular mode renders options as a markdown table:

          ## Which output format do you prefer?

          | Option ID | Label | Description |
          |-----------|-------|-------------|
          | markdown | Markdown | Portable, readable in any editor |
          | json | JSON | Machine-readable, for automation |
          | yaml | YAML | Structured and human-readable |

          **Please type the Option ID of your choice.**

          User types "mark" → matches "markdown" (prefix match)
          User types "json" → matches "json" (exact)
          User types "xyz" → re-prompts (no match)

      - title: Tabular mode with route to other handler
        yaml: |
          initial_state:
            prompts:
              mode: "tabular"
              tabular:
                match_strategy: "exact"
                other_handler: "route"

          select_or_custom:
            type: user_prompt
            prompt:
              question: "Select a preset or enter a custom value"
              header: "Choice"
              options:
                - id: preset1
                  label: "Preset 1"
                  description: "Common configuration"
                - id: preset2
                  label: "Preset 2"
                  description: "Alternative configuration"
            on_response:
              preset1:
                next_node: apply_preset1
              preset2:
                next_node: apply_preset2
              other:
                # Required when other_handler: "route"
                consequence:
                  - type: set_state
                    field: custom_value
                    value: "${user_responses.select_or_custom.text}"
                next_node: apply_custom
        explanation: |
          When other_handler is "route", unrecognized input routes to the "other"
          handler instead of re-prompting. The user's text is available at
          user_responses.{node_id}.text.

          User types "preset1" → matches, routes to apply_preset1
          User types "custom config" → no match, routes to other handler

    related:
      - conditional
      - action
    since: "1.0.0"
    updated: "2.0.0"
