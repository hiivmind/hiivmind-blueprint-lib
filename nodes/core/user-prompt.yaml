# User Prompt Node Type Definition
# Presents an AskUserQuestion and routes based on response

schema_version: "1.0"
category: core

nodes:
  - type: user_prompt
    description:
      brief: Presents an AskUserQuestion and routes based on response
      detail: |
        A user_prompt node presents a question to the user via the AskUserQuestion tool
        and routes based on their response. Each response option can optionally execute
        consequences before routing to the next node.

        This enables user-driven branching in workflows while maintaining deterministic
        behavior once a choice is made.
      notes:
        - Maps to Claude Code's AskUserQuestion tool
        - Header must be 12 characters or less
        - Options array should have 2-4 items
        - User responses are stored in state.user_responses
        - Each response handler can execute consequences before routing

    fields:
      - name: type
        type: string
        required: true
        value: "user_prompt"
        description: Node type discriminator

      - name: prompt
        type: object
        required: true
        description: Question configuration
        properties:
          - name: question
            type: string
            required: true
            description: The question text to display to the user

          - name: header
            type: string
            required: true
            max_length: 12
            description: Short label displayed as a chip/tag (max 12 characters)

          - name: options
            type: array
            required_unless: options_from_state
            min_items: 2
            max_items: 4
            description: Static choices for the user (mutually exclusive with options_from_state)
            items:
              type: object
              properties:
                - name: id
                  type: string
                  required: true
                  description: Unique identifier for this option, used in on_response

                - name: label
                  type: string
                  required: true
                  description: Display text the user sees and selects

                - name: description
                  type: string
                  required: true
                  description: Explanation of what this option means or does

          - name: options_from_state
            type: string
            required_unless: options
            description: |
              State path containing an array of items to use as dynamic options.
              Use with option_mapping to transform items into option format.
              Example: "computed.intent_matches.top_candidates"

          - name: option_mapping
            type: object
            required_with: options_from_state
            description: |
              Expressions to transform each item from options_from_state into an option.
              Each expression is evaluated in the context of the current array item.
            properties:
              - name: id
                type: string
                required: true
                description: Expression for option ID (e.g., "rule.name")

              - name: label
                type: string
                required: true
                description: Expression for display label (e.g., "rule.name")

              - name: description
                type: string
                required: true
                description: Expression for description (e.g., "rule.description")

      - name: on_response
        type: object
        required: true
        description: |
          Map of option id to response handler. Each handler specifies the next_node
          and optionally a consequence array to execute before routing.

          For static options: Use option IDs as keys (e.g., "git", "local", "web").
          For dynamic options: Use special keys "selected" and "other".
        additionalProperties:
          type: object
          properties:
            - name: consequence
              type: array
              items: consequence
              required: false
              description: Optional consequences to execute before routing

            - name: next_node
              type: node_reference
              required: true
              description: Node or ending to route to after this response
        reserved_keys:
          - name: selected
            description: |
              Handler invoked when user selects any option from a dynamic options list.
              The selected item is available at user_responses.{node_id}.selected
            for: options_from_state

          - name: other
            description: |
              Handler invoked when user enters custom text (via "Other" option).
              The text is available at user_responses.{node_id}.text
            for: options_from_state

    execution:
      effect: |
        # Determine options source (static vs dynamic)
        if node.prompt.options_from_state:
          # Dynamic options: resolve from state and transform via mapping
          source_items = get_state_value(node.prompt.options_from_state)
          if source_items == null or source_items.length == 0:
            throw Error("options_from_state resolved to empty array")

          mapping = node.prompt.option_mapping
          options = source_items.map((item, index) => ({
            id: "dynamic_" + index,  # Internal ID for tracking
            label: evaluate_expression(mapping.label, item),
            description: evaluate_expression(mapping.description, item),
            _source_item: item  # Preserve original item for handler
          }))
        else:
          # Static options: use as-is
          options = node.prompt.options

        # Build AskUserQuestion payload
        question_payload = {
          questions: [{
            question: node.prompt.question,
            header: node.prompt.header,
            options: options.map(opt => ({
              label: opt.label,
              description: opt.description
            })),
            multiSelect: false
          }]
        }

        # Present question and await response
        response = call_tool("AskUserQuestion", question_payload)

        # Handle response based on options type
        if node.prompt.options_from_state:
          # Dynamic options handling
          if response.is_other:
            # User entered custom text
            state.user_responses[node_id] = { text: response.text }
            handler = node.on_response["other"]
          else:
            # User selected an option
            selected_index = find_selected_index(response, options)
            selected_item = options[selected_index]._source_item
            state.user_responses[node_id] = { selected: selected_item }
            handler = node.on_response["selected"]
        else:
          # Static options handling
          selected_id = find_selected_option_id(response, options)
          state.user_responses[node_id] = selected_id
          handler = node.on_response[selected_id]

        # Execute consequences if present
        if handler.consequence:
          for consequence in handler.consequence:
            result = dispatch_consequence(consequence, state)
            if result.failed:
              return route_to_error(result.error)

        # Route to next node
        return route_to(handler.next_node)
      state_reads:
        - Any fields referenced via ${} in consequence parameters
        - options_from_state path (if using dynamic options)
      state_writes:
        - "user_responses.${node_id}"
        - Additional writes from consequence execution

    examples:
      - title: Basic source type selection
        yaml: |
          ask_source_type:
            type: user_prompt
            prompt:
              question: "What type of source would you like to add?"
              header: "Source"
              options:
                - id: git
                  label: "Git repository"
                  description: "Clone a repository with docs folder"
                - id: local
                  label: "Local files"
                  description: "Files on your machine"
                - id: web
                  label: "Web pages"
                  description: "Cache blog posts or articles"
            on_response:
              git:
                consequence:
                  - type: set_state
                    field: source_type
                    value: git
                next_node: collect_git_url
              local:
                consequence:
                  - type: set_state
                    field: source_type
                    value: local
                next_node: collect_local_info
              web:
                consequence:
                  - type: set_state
                    field: source_type
                    value: web
                next_node: collect_web_urls
        explanation: |
          Presents three options to the user. Based on selection, sets the source_type
          state field and routes to the appropriate collection node.

      - title: Confirmation prompt
        yaml: |
          confirm_delete:
            type: user_prompt
            prompt:
              question: "Are you sure you want to delete this source?"
              header: "Confirm"
              options:
                - id: yes
                  label: "Yes, delete"
                  description: "Permanently remove the source"
                - id: no
                  label: "Cancel"
                  description: "Keep the source unchanged"
            on_response:
              yes:
                next_node: execute_delete
              no:
                next_node: cancelled

      - title: Route without consequence
        yaml: |
          select_output_format:
            type: user_prompt
            prompt:
              question: "Which output format do you prefer?"
              header: "Format"
              options:
                - id: markdown
                  label: "Markdown"
                  description: "Portable, readable in any editor"
                - id: json
                  label: "JSON"
                  description: "Machine-readable, for automation"
            on_response:
              markdown:
                next_node: generate_markdown
              json:
                next_node: generate_json

      - title: Dynamic options from state (disambiguation)
        yaml: |
          show_disambiguation:
            type: user_prompt
            description: Present top candidates for user selection
            prompt:
              question: "Multiple intents detected. Which did you mean?"
              header: "Clarify"
              options_from_state: computed.intent_matches.top_candidates
              option_mapping:
                id: rule.name
                label: rule.name
                description: rule.description
            on_response:
              selected:
                # User selected one of the dynamic options
                consequence:
                  - type: set_state
                    field: computed.matched_action
                    value: "${user_responses.show_disambiguation.selected.rule.action}"
                next_node: success_resolved
              other:
                # User typed custom text - re-parse with new input
                consequence:
                  - type: set_state
                    field: arguments
                    value: "${user_responses.show_disambiguation.text}"
                next_node: parse_intent_flags
        explanation: |
          Uses dynamic options from state array. The option_mapping transforms each
          candidate into an option. When user selects, the original item is available
          at user_responses.{node_id}.selected. When user types custom text, it's
          available at user_responses.{node_id}.text.

    related:
      - conditional
      - action
    since: "1.0.0"
