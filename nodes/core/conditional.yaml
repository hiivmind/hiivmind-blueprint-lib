# Conditional Node Type Definition
# Branches based on a precondition evaluation

schema_version: "2.0"
category: core

nodes:
  - type: conditional
    description:
      brief: Branches based on a precondition evaluation
      detail: |
        A conditional node evaluates a single precondition and routes to one of
        two branches based on the result. This enables deterministic branching
        based on state, flags, or any condition supported by precondition types.

        The condition is evaluated once; the result determines which branch is taken.

        With `audit` enabled, the node evaluates ALL nested conditions (no short-circuit)
        and collects results with error messages. This replaces the deprecated
        `validation_gate` node type.
      notes:
        - Condition is a single precondition object (often a composite like all_of, any_of, xor_of)
        - Both true and false branches are required
        - Use for binary decisions based on state
        - With audit enabled, replaces validation_gate functionality
        - Audit mode evaluates all conditions (no short-circuit) for comprehensive error reporting

    fields:
      - name: type
        type: string
        required: true
        value: "conditional"
        description: Node type discriminator

      - name: description
        type: string
        required: false
        description: Human-readable purpose for debugging and documentation

      - name: condition
        type: precondition
        required: true
        description: |
          A single precondition object that evaluates to true or false.
          Must have a 'type' field matching a defined precondition type
          (e.g., flag_set, file_exists, all_of, any_of, xor_of).

          For multi-condition validation with audit, use a composite precondition:
          ```yaml
          condition:
            type: all_of
            conditions:
              - type: file_exists
                path: "config.yaml"
              - type: tool_available
                tool: git
          ```

      - name: audit
        type: object
        required: false
        description: |
          Enable audit mode to evaluate ALL conditions without short-circuiting
          and collect detailed results. Used for validation scenarios where you
          need to report all failures, not just the first one.
        properties:
          - name: enabled
            type: boolean
            required: false
            default: false
            description: Enable audit mode (no short-circuit, collect all results)
          - name: output
            type: string
            required: false
            default: "computed.audit_results"
            description: State path where audit results are written
          - name: messages
            type: object
            required: false
            description: |
              Error messages keyed by precondition type. When a condition of
              the given type fails, this message is included in the audit output.
              Keys are precondition type names (e.g., file_exists, tool_available).

      - name: branches
        type: object
        required: true
        description: Routing configuration for condition results
        properties:
          - name: on_true
            type: node_reference
            required: true
            description: Node or ending to route to when condition evaluates to true
          - name: on_false
            type: node_reference
            required: true
            description: Node or ending to route to when condition evaluates to false

    execution:
      effect: |
        if node.audit.enabled:
          # Audit mode: evaluate ALL conditions, no short-circuit
          audit_results = {
            passed: true,
            total: 0,
            passed_count: 0,
            failed_count: 0,
            results: []
          }

          # For composite conditions, iterate through nested conditions
          conditions = get_nested_conditions(node.condition)
          for index, condition in enumerate(conditions):
            result = evaluate_precondition(condition, state)
            audit_results.total += 1

            entry = {
              index: index,
              condition: condition,
              passed: result
            }

            if result:
              audit_results.passed_count += 1
            else:
              audit_results.passed_count += 0
              audit_results.failed_count += 1
              audit_results.passed = false
              # Add message from audit.messages if available
              if node.audit.messages and node.audit.messages[condition.type]:
                entry.message = node.audit.messages[condition.type]

            audit_results.results.append(entry)

          # Write results to state
          output_path = node.audit.output or "computed.audit_results"
          set_nested(state, output_path, audit_results)

          if audit_results.passed:
            return route_to(node.branches.on_true)
          else:
            return route_to(node.branches.on_false)
        else:
          # Normal mode: short-circuit evaluation
          result = evaluate_precondition(node.condition, state)
          if result == true:
            return route_to(node.branches.on_true)
          else:
            return route_to(node.branches.on_false)
      state_reads:
        - Fields referenced in condition parameters via ${} interpolation
        - Fields checked by the precondition type
      state_writes:
        - "computed.audit_results (when audit.enabled is true)"
        - "Custom path via audit.output (when audit.enabled is true)"

    examples:
      - title: Branch on flag
        yaml: |
          check_manifest:
            type: conditional
            description: Route based on whether manifest was detected
            condition:
              type: flag_set
              flag: manifest_detected
            branches:
              on_true: present_manifest_option
              on_false: ask_source_type
        explanation: |
          Checks if the manifest_detected flag is true. If so, routes to
          present_manifest_option; otherwise routes to ask_source_type.

      - title: Branch on state value
        yaml: |
          check_source_type:
            type: conditional
            description: Route based on detected source type
            condition:
              type: state_equals
              field: source_type
              value: git
            branches:
              on_true: configure_git_source
              on_false: configure_other_source

      - title: Branch on file existence
        yaml: |
          check_existing_corpus:
            type: conditional
            condition:
              type: file_exists
              path: "data/config.yaml"
            branches:
              on_true: load_existing_config
              on_false: initialize_new_corpus

      - title: Branch on expression evaluation
        yaml: |
          check_first_source:
            type: conditional
            description: Check if this is the first source being added
            condition:
              type: evaluate_expression
              expression: "len(computed.config.sources) == 0"
            branches:
              on_true: show_first_source_guidance
              on_false: proceed_to_add_source

      - title: Validation with audit mode (replaces validation_gate)
        yaml: |
          check_environment:
            type: conditional
            description: Validate environment before proceeding
            condition:
              type: all_of
              conditions:
                - type: file_exists
                  path: "config.yaml"
                - type: tool_available
                  tool: git
                - type: tool_available
                  tool: yq
            audit:
              enabled: true
              output: computed.audit_results
              messages:
                file_exists: "Config missing - run init first"
                tool_available: "Required tool not installed"
            branches:
              on_true: proceed
              on_false: show_errors
        explanation: |
          With audit.enabled, evaluates ALL conditions (no short-circuit) and
          collects results. On failure, computed.audit_results contains:
          {
            passed: false,
            total: 3,
            passed_count: 1,
            failed_count: 2,
            results: [
              { index: 0, condition: {...}, passed: true },
              { index: 1, condition: {...}, passed: false, message: "Required tool not installed" },
              { index: 2, condition: {...}, passed: false, message: "Required tool not installed" }
            ]
          }

      - title: Audit with custom output path
        yaml: |
          validate_source_config:
            type: conditional
            description: Validate source configuration
            condition:
              type: all_of
              conditions:
                - type: state_not_null
                  field: source_type
                - type: state_not_null
                  field: computed.source_id
                - type: flag_set
                  flag: url_validated
            audit:
              enabled: true
              output: computed.source_validation
              messages:
                state_not_null: "Required field is missing"
                flag_set: "Validation step incomplete"
            branches:
              on_true: add_source
              on_false: show_validation_errors
        explanation: |
          Stores audit results at computed.source_validation instead of
          the default computed.audit_results. Useful when multiple validation
          nodes need separate result storage.

      - title: Audit with any_of (flexible requirements)
        yaml: |
          check_yaml_processor:
            type: conditional
            description: Check for any available YAML processor
            condition:
              type: any_of
              conditions:
                - type: tool_available
                  tool: yq
                - type: python_module_available
                  module: yaml
            audit:
              enabled: true
              messages:
                tool_available: "yq not found"
                python_module_available: "PyYAML not installed"
            branches:
              on_true: process_yaml
              on_false: suggest_install
        explanation: |
          For any_of with audit, all conditions are still evaluated to collect
          complete results, but passed is true if ANY condition passed.

      - title: Audit with xor_of (exactly one)
        yaml: |
          check_single_source_type:
            type: conditional
            description: Exactly one source type must be selected
            condition:
              type: xor_of
              conditions:
                - type: flag_set
                  flag: is_git_source
                - type: flag_set
                  flag: is_local_source
                - type: flag_set
                  flag: is_web_source
            audit:
              enabled: true
              messages:
                flag_set: "Source type flag"
            branches:
              on_true: configure_source
              on_false: ask_source_type
        explanation: |
          For xor_of with audit, passed is true only if exactly one condition
          is true. If zero or multiple are true, routes to on_false with full
          audit results showing which conditions matched.

    related:
      - action
      - user_prompt
    since: "1.0.0"
    audit_since: "2.0.0"
