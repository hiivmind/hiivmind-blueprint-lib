# Action Node Type Definition
# Executes operations and routes based on success/failure

schema_version: "1.0"
category: core

nodes:
  # ==========================================================================
  # category: core/action
  # ==========================================================================

  # --------------------------------------------------------------------------
  # action
  # --------------------------------------------------------------------------

  action:
    description:
      brief: Executes operations and routes based on success/failure
      detail: |
        An action node executes a sequence of consequence operations. All actions
        must succeed for on_success routing; any failure triggers on_failure routing.

        Actions are executed in order. If any action fails, subsequent actions are
        skipped and the node routes to on_failure. If all succeed, routes to on_success.
      notes:
        - Actions execute sequentially in array order
        - First failure short-circuits remaining actions
        - Results can be stored in state.computed via store_as
        - Supports ${} interpolation in action parameters

    fields:
      - name: type
        type: string
        required: true
        value: "action"
        description: Node type discriminator

      - name: description
        type: string
        required: false
        description: Human-readable purpose for debugging and documentation

      - name: actions
        type: array
        items: consequence
        required: true
        min_items: 1
        description: |
          Array of consequence objects to execute. Each consequence must have a 'type'
          field matching a defined consequence type (e.g., set_flag, read_file, clone_repo).

      - name: on_success
        type: node_reference
        required: true
        description: Node or ending identifier to route to when all actions succeed

      - name: on_failure
        type: node_reference
        required: true
        description: Node or ending identifier to route to when any action fails

    execution:
      effect: |
        for action in node.actions:
          result = dispatch_consequence(action, state)
          if result.failed:
            log_failure(action, result.error)
            return route_to(node.on_failure)
          if action.store_as:
            state.computed[action.store_as] = result.value
        return route_to(node.on_success)
      state_reads:
        - Any fields referenced in action parameters via ${} interpolation
      state_writes:
        - "computed.${store_as} for each action with store_as"
        - "Additional writes defined by individual consequence types"

    examples:
      - title: Basic action chain
        yaml: |
          read_config:
            type: action
            description: Load and validate configuration
            actions:
              - type: read_file
                path: "config.yaml"
                store_as: config
              - type: set_flag
                flag: config_loaded
                value: true
            on_success: process_config
            on_failure: error_no_config
        explanation: |
          Reads config.yaml and stores result in state.computed.config, then sets
          the config_loaded flag. If file read fails, routes to error_no_config.

      - title: Action with evaluation
        yaml: |
          check_sources:
            type: action
            actions:
              - type: evaluate
                expression: "len(config.sources) == 0"
                set_flag: is_first_source
              - type: set_state
                field: source_count
                value: "${computed.config.sources.length}"
            on_success: route_by_source_count
            on_failure: error_evaluation

      - title: Git clone action
        yaml: |
          clone_repository:
            type: action
            description: Clone the source repository
            actions:
              - type: clone_repo
                url: "${computed.repo_url}"
                path: "${computed.clone_path}"
                branch: "${user_responses.branch}"
                store_as: clone_result
              - type: set_flag
                flag: repo_cloned
                value: true
            on_success: scan_docs
            on_failure: error_clone_failed

    related:
      - conditional
      - validation_gate
    since: "1.0.0"

  # ==========================================================================
  # category: core/conditional
  # ==========================================================================

  # --------------------------------------------------------------------------
  # conditional
  # --------------------------------------------------------------------------

  conditional:
    description:
      brief: Branches based on a precondition evaluation
      detail: |
        A conditional node evaluates a single precondition and routes to one of
        two branches based on the result. This enables deterministic branching
        based on state, flags, or any condition supported by precondition types.

        The condition is evaluated once; the result determines which branch is taken.

        With `audit` enabled, the node evaluates ALL nested conditions (no short-circuit)
        and collects results with error messages. This replaces the deprecated
        `validation_gate` node type.
      notes:
        - Condition is a single precondition object (often a composite like all_of, any_of, xor_of)
        - Both true and false branches are required
        - Use for binary decisions based on state
        - With audit enabled, replaces validation_gate functionality
        - Audit mode evaluates all conditions (no short-circuit) for comprehensive error reporting

    fields:
      - name: type
        type: string
        required: true
        value: "conditional"
        description: Node type discriminator

      - name: description
        type: string
        required: false
        description: Human-readable purpose for debugging and documentation

      - name: condition
        type: precondition
        required: true
        description: |
          A single precondition object that evaluates to true or false.
          Must have a 'type' field matching a defined precondition type
          (e.g., flag_set, file_exists, all_of, any_of, xor_of).

          For multi-condition validation with audit, use a composite precondition:
          ```yaml
          condition:
            type: all_of
            conditions:
              - type: file_exists
                path: "config.yaml"
              - type: tool_available
                tool: git
          ```

      - name: audit
        type: object
        required: false
        description: |
          Enable audit mode to evaluate ALL conditions without short-circuiting
          and collect detailed results. Used for validation scenarios where you
          need to report all failures, not just the first one.
        properties:
          - name: enabled
            type: boolean
            required: false
            default: false
            description: Enable audit mode (no short-circuit, collect all results)
          - name: output
            type: string
            required: false
            default: "computed.audit_results"
            description: State path where audit results are written
          - name: messages
            type: object
            required: false
            description: |
              Error messages keyed by precondition type. When a condition of
              the given type fails, this message is included in the audit output.
              Keys are precondition type names (e.g., file_exists, tool_available).

      - name: branches
        type: object
        required: true
        description: Routing configuration for condition results
        properties:
          - name: on_true
            type: node_reference
            required: true
            description: Node or ending to route to when condition evaluates to true
          - name: on_false
            type: node_reference
            required: true
            description: Node or ending to route to when condition evaluates to false

    execution:
      effect: |
        if node.audit.enabled:
          # Audit mode: evaluate ALL conditions, no short-circuit
          audit_results = {
            passed: true,
            total: 0,
            passed_count: 0,
            failed_count: 0,
            results: []
          }

          # For composite conditions, iterate through nested conditions
          conditions = get_nested_conditions(node.condition)
          for index, condition in enumerate(conditions):
            result = evaluate_precondition(condition, state)
            audit_results.total += 1

            entry = {
              index: index,
              condition: condition,
              passed: result
            }

            if result:
              audit_results.passed_count += 1
            else:
              audit_results.passed_count += 0
              audit_results.failed_count += 1
              audit_results.passed = false
              # Add message from audit.messages if available
              if node.audit.messages and node.audit.messages[condition.type]:
                entry.message = node.audit.messages[condition.type]

            audit_results.results.append(entry)

          # Write results to state
          output_path = node.audit.output or "computed.audit_results"
          set_nested(state, output_path, audit_results)

          if audit_results.passed:
            return route_to(node.branches.on_true)
          else:
            return route_to(node.branches.on_false)
        else:
          # Normal mode: short-circuit evaluation
          result = evaluate_precondition(node.condition, state)
          if result == true:
            return route_to(node.branches.on_true)
          else:
            return route_to(node.branches.on_false)
      state_reads:
        - Fields referenced in condition parameters via ${} interpolation
        - Fields checked by the precondition type
      state_writes:
        - "computed.audit_results (when audit.enabled is true)"
        - "Custom path via audit.output (when audit.enabled is true)"

    examples:
      - title: Branch on flag
        yaml: |
          check_manifest:
            type: conditional
            description: Route based on whether manifest was detected
            condition:
              type: flag_set
              flag: manifest_detected
            branches:
              on_true: present_manifest_option
              on_false: ask_source_type
        explanation: |
          Checks if the manifest_detected flag is true. If so, routes to
          present_manifest_option; otherwise routes to ask_source_type.

      - title: Branch on state value
        yaml: |
          check_source_type:
            type: conditional
            description: Route based on detected source type
            condition:
              type: state_equals
              field: source_type
              value: git
            branches:
              on_true: configure_git_source
              on_false: configure_other_source

      - title: Branch on file existence
        yaml: |
          check_existing_corpus:
            type: conditional
            condition:
              type: file_exists
              path: "data/config.yaml"
            branches:
              on_true: load_existing_config
              on_false: initialize_new_corpus

      - title: Branch on expression evaluation
        yaml: |
          check_first_source:
            type: conditional
            description: Check if this is the first source being added
            condition:
              type: evaluate_expression
              expression: "len(computed.config.sources) == 0"
            branches:
              on_true: show_first_source_guidance
              on_false: proceed_to_add_source

      - title: Validation with audit mode (replaces validation_gate)
        yaml: |
          check_environment:
            type: conditional
            description: Validate environment before proceeding
            condition:
              type: all_of
              conditions:
                - type: file_exists
                  path: "config.yaml"
                - type: tool_available
                  tool: git
                - type: tool_available
                  tool: yq
            audit:
              enabled: true
              output: computed.audit_results
              messages:
                file_exists: "Config missing - run init first"
                tool_available: "Required tool not installed"
            branches:
              on_true: proceed
              on_false: show_errors
        explanation: |
          With audit.enabled, evaluates ALL conditions (no short-circuit) and
          collects results. On failure, computed.audit_results contains:
          {
            passed: false,
            total: 3,
            passed_count: 1,
            failed_count: 2,
            results: [
              { index: 0, condition: {...}, passed: true },
              { index: 1, condition: {...}, passed: false, message: "Required tool not installed" },
              { index: 2, condition: {...}, passed: false, message: "Required tool not installed" }
            ]
          }

      - title: Audit with custom output path
        yaml: |
          validate_source_config:
            type: conditional
            description: Validate source configuration
            condition:
              type: all_of
              conditions:
                - type: state_not_null
                  field: source_type
                - type: state_not_null
                  field: computed.source_id
                - type: flag_set
                  flag: url_validated
            audit:
              enabled: true
              output: computed.source_validation
              messages:
                state_not_null: "Required field is missing"
                flag_set: "Validation step incomplete"
            branches:
              on_true: add_source
              on_false: show_validation_errors
        explanation: |
          Stores audit results at computed.source_validation instead of
          the default computed.audit_results. Useful when multiple validation
          nodes need separate result storage.

      - title: Audit with any_of (flexible requirements)
        yaml: |
          check_yaml_processor:
            type: conditional
            description: Check for any available YAML processor
            condition:
              type: any_of
              conditions:
                - type: tool_available
                  tool: yq
                - type: python_module_available
                  module: yaml
            audit:
              enabled: true
              messages:
                tool_available: "yq not found"
                python_module_available: "PyYAML not installed"
            branches:
              on_true: process_yaml
              on_false: suggest_install
        explanation: |
          For any_of with audit, all conditions are still evaluated to collect
          complete results, but passed is true if ANY condition passed.

      - title: Audit with xor_of (exactly one)
        yaml: |
          check_single_source_type:
            type: conditional
            description: Exactly one source type must be selected
            condition:
              type: xor_of
              conditions:
                - type: flag_set
                  flag: is_git_source
                - type: flag_set
                  flag: is_local_source
                - type: flag_set
                  flag: is_web_source
            audit:
              enabled: true
              messages:
                flag_set: "Source type flag"
            branches:
              on_true: configure_source
              on_false: ask_source_type
        explanation: |
          For xor_of with audit, passed is true only if exactly one condition
          is true. If zero or multiple are true, routes to on_false with full
          audit results showing which conditions matched.

    related:
      - action
      - user_prompt
    since: "1.0.0"
    audit_since: "2.0.0"

  # ==========================================================================
  # category: core/reference
  # ==========================================================================

  # --------------------------------------------------------------------------
  # reference
  # --------------------------------------------------------------------------

  reference:
    description:
      brief: Loads and executes a reference document or remote workflow
      detail: |
        A reference node delegates execution to either a local reference document
        or a remote workflow. This enables complex multi-step procedures to be
        documented separately while remaining callable from workflows.

        For local documents: typically markdown files containing detailed procedure
        instructions. Context variables are available for interpolation.

        For remote workflows: fetched from GitHub repositories, enabling distributed
        composable workflow ecosystems. See resolution/workflow-loader.yaml for
        the loading protocol.

        State is SHARED between parent and referenced workflow/document.
      notes:
        - Must specify either 'doc' (local) or 'workflow' (remote), not both
        - For local: doc path is relative to plugin root
        - For remote: uses owner/repo@version:workflow-name format
        - Section parameter only applies to doc references
        - Context variables are merged into state for sub-execution
        - State is shared (unlike invoke_skill which isolates state)
        - next_node supports variable interpolation for dynamic routing

    fields:
      - name: type
        type: string
        required: true
        value: "reference"
        description: Node type discriminator

      - name: doc
        type: string
        required_unless: workflow
        description: |
          Path to the reference document, relative to plugin root.
          Typically a markdown file in lib/ or references/ directory.
          Mutually exclusive with 'workflow'.

      - name: workflow
        type: string
        required_unless: doc
        description: |
          Remote workflow reference in format: owner/repo@version:workflow-name
          Example: hiivmind/hiivmind-blueprint-lib@v2.0.0:intent-detection
          Mutually exclusive with 'doc'.
          See resolution/workflow-loader.yaml for loading protocol.

      - name: section
        type: string
        required: false
        description: |
          Optional section heading within the document to execute.
          If omitted, the entire document is executed.
          Only applicable when using 'doc' (not 'workflow').

      - name: context
        type: object
        required: false
        description: |
          Variables to make available within the referenced document/workflow.
          These can be referenced using ${} interpolation syntax.
          For workflows, maps to workflow inputs.
        additionalProperties:
          type: any
          interpolatable: true

      - name: next_node
        type: node_reference
        required: true
        description: |
          Node or ending to route to after execution completes.
          Supports variable interpolation (e.g., "${computed.dynamic_target}").

    execution:
      effect: |
        # Determine source: remote workflow or local document
        if node.workflow:
          # Remote workflow reference (v2.1+)
          # See resolution/workflow-loader.yaml for full loading protocol
          workflow = load_workflow(node.workflow)
        else if node.doc:
          # Local file reference
          doc_path = resolve_path(plugin_root, node.doc)
          doc_content = read_file(doc_path)

          # Extract section if specified (only for doc references)
          if node.section:
            doc_content = extract_section(doc_content, node.section)
        else:
          throw Error("Reference node requires 'workflow' or 'doc' parameter")

        # Build context with interpolation
        context = {}
        if node.context:
          for key, value in node.context.items():
            context[key] = interpolate(value, state)

        # Merge context into state (for shared state execution)
        for key, value in context.items():
          state[key] = value

        # Execute based on source type
        if node.workflow:
          # Execute as sub-workflow with shared state
          # Note: Reference execution shares state (unlike invoke_skill)
          execute_workflow(workflow, types, state)
        else:
          # Execute document with context
          execute_document(doc_content, context, state)

        # Resolve next node (supports dynamic interpolation)
        target = resolve_routing_target(node.next_node, state)

        return route_to(target)
      state_reads:
        - Fields referenced in context values via ${} interpolation
      state_writes:
        - Depends on workflow/document execution
        - Remote workflows can read and modify parent state directly

    examples:
      # === Local document references ===
      - title: Execute git clone procedure (local doc)
        yaml: |
          clone_repository:
            type: reference
            doc: "lib/corpus/patterns/sources/git.md"
            section: "Clone Repository"
            context:
              repo_url: "${computed.repo_url}"
              clone_path: "${computed.clone_path}"
              branch: "${user_responses.branch}"
            next_node: verify_clone
        explanation: |
          Loads the git.md document, extracts the "Clone Repository" section,
          and executes it with the provided context variables. After completion,
          routes to verify_clone.

      - title: Full document execution (local doc)
        yaml: |
          run_build_process:
            type: reference
            doc: "references/build-index.md"
            context:
              source_paths: "${computed.source_paths}"
              output_path: "${computed.output_path}"
            next_node: finalize_build
        explanation: |
          Executes the entire build-index.md document with source and output
          paths from computed state.

      # === Remote workflow references ===
      - title: Remote workflow for intent detection
        yaml: |
          detect_intent:
            type: reference
            workflow: hiivmind/hiivmind-blueprint-lib@v2.0.0:intent-detection
            context:
              arguments: "${arguments}"
              intent_flags: "${intent_flags}"
              intent_rules: "${intent_rules}"
              fallback_action: "show_main_menu"
            next_node: execute_dynamic_route
        explanation: |
          Fetches the intent-detection workflow from hiivmind-blueprint-lib
          and executes it with context mapped as workflow inputs.
          After completion, routes to execute_dynamic_route.
          The workflow sets computed.matched_action and other outputs
          that are directly available in parent state.

      - title: Remote workflow with dynamic routing
        yaml: |
          detect_intent:
            type: reference
            workflow: hiivmind/hiivmind-blueprint-lib@v2.0.0:intent-detection
            context:
              arguments: "${arguments}"
              intent_flags: "${intent_flags}"
              intent_rules: "${intent_rules}"
            next_node: "${computed.dynamic_target}"
        explanation: |
          The next_node uses variable interpolation to route dynamically
          based on the workflow output. The intent-detection workflow sets
          computed.dynamic_target based on the matched intent.

      - title: Using outputs from remote workflow
        yaml: |
          # Parent workflow can use outputs directly after reference node
          execute_matched_intent:
            type: action
            actions:
              - type: dynamic_route
                action: "${computed.matched_action}"
            on_success: "${computed.dynamic_target}"
            on_failure: show_main_menu
        explanation: |
          After detect_intent reference node completes, the parent workflow
          has access to computed.matched_action, computed.intent_flags,
          and computed.intent_matches set by the sub-workflow.

      # === State sharing examples ===
      - title: Complex procedure with multiple context values (local doc)
        yaml: |
          process_web_source:
            type: reference
            doc: "lib/corpus/patterns/sources/web.md"
            section: "Fetch and Cache"
            context:
              urls: "${computed.discovered_urls}"
              cache_dir: "${computed.cache_directory}"
              max_depth: "${user_responses.crawl_depth}"
              include_images: "${flags.include_images}"
              user_agent: "hiivmind-corpus/1.0"
            next_node: verify_cached_content

      - title: Override logging for sub-workflow
        yaml: |
          detect_intent:
            type: reference
            workflow: hiivmind/hiivmind-blueprint-lib@v2.0.0:intent-detection
            context:
              arguments: "${arguments}"
              logging:
                level: "debug"
                auto:
                  node_tracking: true
            next_node: execute_dynamic_route
        explanation: |
          Pass logging config in context to override for this sub-workflow.
          More verbose logging for intent detection debugging.

    related:
      - action
      - conditional
    since: "1.0.0"
    workflow_since: "2.1.0"

  # ==========================================================================
  # category: core/user_prompt
  # ==========================================================================

  # --------------------------------------------------------------------------
  # user_prompt
  # --------------------------------------------------------------------------

  user_prompt:
    description:
      brief: Presents a question and routes based on user response
      detail: |
        A user_prompt node presents a question to the user and routes based on their
        response. Each response option can optionally execute consequences before
        routing to the next node.

        Execution mode is configured via initial_state.prompts:
        - interactive (default) - Uses AskUserQuestion tool for structured prompts
        - tabular - Renders markdown table, parses user text response

        This enables user-driven branching in workflows while maintaining deterministic
        behavior once a choice is made.
      notes:
        - "Mode configured in initial_state.prompts (default: interactive)"
        - "Interactive mode maps to Claude Code's AskUserQuestion tool"
        - "Tabular mode renders markdown table and matches user text to option IDs"
        - "Header must be 12 characters or less"
        - "Options array should have 2-4 items"
        - "User responses are stored in state.user_responses"
        - "Each response handler can execute consequences before routing"
        - "Tabular mode supports match strategies: exact, prefix, fuzzy"
        - "When using tabular mode with other_handler: route, on_response.other is required"

    fields:
      - name: type
        type: string
        required: true
        value: "user_prompt"
        description: Node type discriminator

      - name: prompt
        type: object
        required: true
        description: Question configuration
        properties:
          - name: question
            type: string
            required: true
            description: The question text to display to the user

          - name: header
            type: string
            required: true
            max_length: 12
            description: Short label displayed as a chip/tag (max 12 characters)

          - name: options
            type: array
            required_unless: options_from_state
            min_items: 2
            max_items: 4
            description: Static choices for the user (mutually exclusive with options_from_state)
            items:
              type: object
              properties:
                - name: id
                  type: string
                  required: true
                  description: Unique identifier for this option, used in on_response

                - name: label
                  type: string
                  required: true
                  description: Display text the user sees and selects

                - name: description
                  type: string
                  required: true
                  description: Explanation of what this option means or does

          - name: options_from_state
            type: string
            required_unless: options
            description: |
              State path containing an array of items to use as dynamic options.
              Use with option_mapping to transform items into option format.
              Example: "computed.intent_matches.top_candidates"

          - name: option_mapping
            type: object
            required_with: options_from_state
            description: |
              Expressions to transform each item from options_from_state into an option.
              Each expression is evaluated in the context of the current array item.
            properties:
              - name: id
                type: string
                required: true
                description: Expression for option ID (e.g., "rule.name")

              - name: label
                type: string
                required: true
                description: Expression for display label (e.g., "rule.name")

              - name: description
                type: string
                required: true
                description: Expression for description (e.g., "rule.description")

      - name: on_response
        type: object
        required: true
        description: |
          Map of option id to response handler. Each handler specifies the next_node
          and optionally a consequence array to execute before routing.

          For static options: Use option IDs as keys (e.g., "git", "local", "web").
          For dynamic options: Use special keys "selected" and "other".
        additionalProperties:
          type: object
          properties:
            - name: consequence
              type: array
              items: consequence
              required: false
              description: Optional consequences to execute before routing

            - name: next_node
              type: node_reference
              required: true
              description: Node or ending to route to after this response
        reserved_keys:
          - name: selected
            description: |
              Handler invoked when user selects any option from a dynamic options list.
              The selected item is available at user_responses.{node_id}.selected
            for: options_from_state

          - name: other
            description: |
              Handler invoked when user enters custom text (via "Other" option).
              The text is available at user_responses.{node_id}.text
            for: options_from_state

    execution:
      effect: |
        # Get prompts configuration with multi-modal interface support
        prompts_config = state.prompts or { interface: "auto" }

        # Resolve interface (auto-detection or explicit)
        interface = state.interface or "claude_code"

        # Get mode for this interface
        mode = get_mode_for_interface(interface, prompts_config)

        # Determine options source (static vs dynamic)
        options = resolve_options(node, state)

        # Execute based on mode
        if mode == "interactive":
          return execute_interactive_mode(node, options, state)
        else if mode == "tabular":
          return execute_tabular_mode(node, options, state, prompts_config.tabular or {})
        else if mode == "forms":
          return execute_forms_mode(node, options, state)
        else if mode == "structured":
          return execute_structured_mode(node, options, state)
        else if mode == "autonomous":
          return execute_autonomous_mode(node, options, state, prompts_config.autonomous or {})
        else:
          throw Error("Unknown prompt mode: " + mode)

      get_mode_for_interface: |
        FUNCTION get_mode_for_interface(interface, prompts_config):
          # Get modes configuration with defaults
          modes = prompts_config.modes or {
            claude_code: "interactive",
            web: "forms",
            api: "structured",
            agent: "autonomous"
          }

          # Return mode for detected interface
          SWITCH interface:
            CASE "claude_code":
              RETURN modes.claude_code or "interactive"
            CASE "web":
              RETURN modes.web or "forms"
            CASE "api":
              RETURN modes.api or "structured"
            CASE "agent":
              RETURN modes.agent or "autonomous"
            DEFAULT:
              RETURN prompts_config.default_mode or "interactive"

      helpers:
        resolve_options: |
          FUNCTION resolve_options(node, state):
            if node.prompt.options_from_state:
              # Dynamic options: resolve from state and transform via mapping
              source_items = get_state_value(node.prompt.options_from_state)
              if source_items == null or source_items.length == 0:
                throw Error("options_from_state resolved to empty array")

              mapping = node.prompt.option_mapping
              return source_items.map((item, index) => ({
                id: evaluate_expression(mapping.id, item) or ("dynamic_" + index),
                label: evaluate_expression(mapping.label, item),
                description: evaluate_expression(mapping.description, item),
                _source_item: item  # Preserve original item for handler
              }))
            else:
              # Static options: use as-is
              return node.prompt.options

        execute_interactive_mode: |
          FUNCTION execute_interactive_mode(node, options, state):
            # Build AskUserQuestion payload
            question_payload = {
              questions: [{
                question: node.prompt.question,
                header: node.prompt.header,
                options: options.map(opt => ({
                  label: opt.label,
                  description: opt.description
                })),
                multiSelect: false
              }]
            }

            # Present question and await response
            response = call_tool("AskUserQuestion", question_payload)

            # Handle response and route
            return handle_response(node, options, response, state, "interactive")

        execute_tabular_mode: |
          FUNCTION execute_tabular_mode(node, options, state, tabular_config):
            # Check if resuming from awaiting_input
            if state.awaiting_input and state.awaiting_input.node_id == node_id:
              # Resuming - user_input contains their text response
              user_input = state.awaiting_input.user_input
              state.awaiting_input = null  # Clear awaiting state

              # Match user input to options
              match_result = match_user_input_to_option(user_input, options, tabular_config)

              if match_result.matched:
                # Found a match
                response = { selected_id: match_result.option_id, text: user_input }
                return handle_response(node, options, response, state, "tabular", match_result)
              else:
                # No match - handle based on other_handler config
                other_handler = tabular_config.other_handler or "prompt"

                if other_handler == "prompt":
                  # Re-display table and re-prompt
                  render_no_match_message(user_input)
                  render_options_table(node.prompt.question, options, tabular_config)
                  state.awaiting_input = { node_id: node_id, type: "tabular" }
                  return { awaiting_input: true }

                else if other_handler == "route":
                  # Route to "other" handler
                  if not node.on_response["other"]:
                    throw Error("other_handler is 'route' but on_response.other not defined")
                  state.user_responses[node_id] = { handler_id: "other", text: user_input }
                  handler = node.on_response["other"]
                  return execute_handler_and_route(handler, state)

                else if other_handler == "fail":
                  throw Error("No matching option for input: " + user_input)

            else:
              # First execution - render table and await input
              render_options_table(node.prompt.question, options, tabular_config)
              state.awaiting_input = { node_id: node_id, type: "tabular" }
              return { awaiting_input: true }

        render_options_table: |
          FUNCTION render_options_table(question, options, tabular_config):
            show_ids = tabular_config.show_option_ids != false
            instruction = tabular_config.instruction_text or "**Please type the Option ID of your choice.**"

            # Render question as heading
            DISPLAY "## " + question
            DISPLAY ""

            # Render table header
            if show_ids:
              DISPLAY "| Option ID | Label | Description |"
              DISPLAY "|-----------|-------|-------------|"
            else:
              DISPLAY "| Label | Description |"
              DISPLAY "|-------|-------------|"

            # Render options
            for opt in options:
              if show_ids:
                DISPLAY "| " + opt.id + " | " + opt.label + " | " + opt.description + " |"
              else:
                DISPLAY "| " + opt.label + " | " + opt.description + " |"

            DISPLAY ""
            DISPLAY instruction

        render_no_match_message: |
          FUNCTION render_no_match_message(user_input):
            DISPLAY "I didn't recognize \"" + user_input + "\" as a valid option."
            DISPLAY ""

        match_user_input_to_option: |
          FUNCTION match_user_input_to_option(user_input, options, tabular_config):
            strategy = tabular_config.match_strategy or "prefix"
            case_sensitive = tabular_config.case_sensitive or false

            # Normalize input
            input = case_sensitive ? user_input : user_input.toLowerCase()
            input = input.trim()

            for opt in options:
              opt_id = case_sensitive ? opt.id : opt.id.toLowerCase()

              if strategy == "exact":
                if input == opt_id:
                  return { matched: true, option_id: opt.id, strategy: "exact" }

              else if strategy == "prefix":
                if opt_id.startsWith(input) or input.startsWith(opt_id):
                  return { matched: true, option_id: opt.id, strategy: "prefix" }

              else if strategy == "fuzzy":
                threshold = tabular_config.fuzzy_threshold or 0.7
                similarity = calculate_similarity(input, opt_id)
                if similarity >= threshold:
                  return { matched: true, option_id: opt.id, strategy: "fuzzy", similarity: similarity }

            return { matched: false }

        calculate_similarity: |
          FUNCTION calculate_similarity(str1, str2):
            # Levenshtein distance normalized to similarity score
            # Returns value between 0.0 and 1.0
            max_len = max(str1.length, str2.length)
            if max_len == 0:
              return 1.0
            distance = levenshtein_distance(str1, str2)
            return 1.0 - (distance / max_len)

        execute_forms_mode: |
          FUNCTION execute_forms_mode(node, options, state):
            # Forms mode: render rich HTML-like forms for web interfaces
            # Falls back to tabular for pure text interfaces
            # The web interface renders this as clickable buttons/forms

            DISPLAY "## " + node.prompt.question
            DISPLAY ""

            # Render options as a clean list (web UI will enhance to buttons)
            for index, opt in enumerate(options):
              DISPLAY "**{index + 1}. {opt.label}**"
              DISPLAY "   {opt.description}"
              DISPLAY ""

            DISPLAY "_Select an option by number or name._"

            # Set awaiting state for multi-turn
            state.awaiting_input = { node_id: node_id, type: "forms" }
            return { awaiting_input: true }

        execute_structured_mode: |
          FUNCTION execute_structured_mode(node, options, state):
            # Structured mode: for API/programmatic access
            # Returns JSON schema for expected response format

            # Build structured prompt for API consumers
            prompt_data = {
              question: node.prompt.question,
              options: options.map(opt => ({
                id: opt.id,
                label: opt.label,
                description: opt.description
              })),
              response_format: {
                selected_id: "string (required) - ID of selected option",
                text: "string (optional) - Additional context"
              }
            }

            # For API mode, we expect the response to come with the request
            # Check if we have a pending response in state
            if state.api_response and state.api_response.node_id == node_id:
              response = state.api_response
              state.api_response = null
              return handle_response(node, options, response, state, "structured")

            # Otherwise, return prompt data for API consumer
            state.awaiting_input = {
              node_id: node_id,
              type: "structured",
              prompt: prompt_data
            }
            return { awaiting_input: true, prompt: prompt_data }

        execute_autonomous_mode: |
          FUNCTION execute_autonomous_mode(node, options, state, autonomous_config):
            # Autonomous mode: LLM evaluates options without user interaction
            # Used for embedded agents that cannot prompt users

            strategy = autonomous_config.strategy or "best_match"
            context_fields = autonomous_config.context_fields or ["computed.intent_flags", "arguments"]
            fallback = autonomous_config.fallback or "other"
            confidence_threshold = autonomous_config.confidence_threshold or 0.5

            # Gather context for evaluation
            context = {}
            for field in context_fields:
              context[field] = get_nested(state, field)

            # Evaluate options based on strategy
            selected = null
            confidence = 0

            if strategy == "best_match":
              # LLM evaluates which option best matches the context
              # This is a conceptual evaluation - the LLM reasons about the options
              for opt in options:
                score = evaluate_option_match(opt, context, node.prompt.question)
                if score > confidence:
                  confidence = score
                  selected = opt

            else if strategy == "first_valid":
              # Select first option that passes validation
              for opt in options:
                if validate_option(opt, context):
                  selected = opt
                  confidence = 1.0
                  break

            else if strategy == "weighted":
              # Use weights from option metadata if available
              for opt in options:
                weight = opt.weight or 1.0
                score = evaluate_option_match(opt, context, node.prompt.question) * weight
                if score > confidence:
                  confidence = score
                  selected = opt

            # Check confidence threshold
            if selected == null or confidence < confidence_threshold:
              # Use fallback handler
              if node.on_response[fallback]:
                state.user_responses[node_id] = {
                  handler_id: fallback,
                  autonomous: true,
                  reason: "Below confidence threshold",
                  confidence: confidence
                }
                handler = node.on_response[fallback]
                return execute_handler_and_route(handler, state)
              else:
                throw Error("Autonomous mode: no match found and no fallback handler")

            # Log selection if configured
            if autonomous_config.explain_selection:
              LOG_DEBUG "Autonomous selection: {selected.id} (confidence: {confidence})"
              LOG_DEBUG "  Context: {JSON.stringify(context)}"

            # Build response and route
            response = { selected_id: selected.id, autonomous: true, confidence: confidence }
            return handle_response(node, options, response, state, "autonomous")

        evaluate_option_match: |
          FUNCTION evaluate_option_match(option, context, question):
            # Conceptual function: LLM evaluates how well the option matches
            # Based on option description, context state, and the question
            # Returns a confidence score between 0.0 and 1.0

            # The LLM naturally performs this evaluation by reasoning about:
            # - Does the option.label/description align with context.arguments?
            # - Do any intent_flags suggest this option?
            # - Is this option a logical answer to the question given context?

            # This is interpreted by the LLM, not executed as code
            RETURN evaluate_semantic_match(option.description, context)

        validate_option: |
          FUNCTION validate_option(option, context):
            # Check if option is valid given current context
            # Used by first_valid strategy
            if option.requires:
              for req in option.requires:
                if not evaluate_precondition(req, context):
                  return false
            return true

        handle_response: |
          FUNCTION handle_response(node, options, response, state, mode, match_result = null):
            # Determine handler based on response and options type
            if node.prompt.options_from_state:
              # Dynamic options handling
              if response.is_other or (mode == "tabular" and not match_result):
                state.user_responses[node_id] = { handler_id: "other", text: response.text }
                handler = node.on_response["other"]
              else:
                selected_id = response.selected_id or find_selected_option_id(response, options)
                selected_opt = options.find(opt => opt.id == selected_id)
                state.user_responses[node_id] = {
                  handler_id: "selected",
                  selected: selected_opt._source_item,
                  raw: { text: response.text, matched_by: match_result?.strategy },
                  autonomous: response.autonomous or false
                }
                handler = node.on_response["selected"]
            else:
              # Static options handling
              selected_id = response.selected_id or find_selected_option_id(response, options)
              state.user_responses[node_id] = {
                handler_id: selected_id,
                raw: { text: response.text, matched_by: match_result?.strategy },
                autonomous: response.autonomous or false
              }
              handler = node.on_response[selected_id]

            return execute_handler_and_route(handler, state)

        execute_handler_and_route: |
          FUNCTION execute_handler_and_route(handler, state):
            # Execute consequences if present
            if handler.consequence:
              for consequence in handler.consequence:
                result = dispatch_consequence(consequence, state)
                if result.failed:
                  return route_to_error(result.error)

            # Route to next node
            return route_to(handler.next_node)

      state_reads:
        - "state.prompts (for mode configuration)"
        - "state.interface (for multi-modal dispatch)"
        - "state.awaiting_input (for tabular/forms mode resumption)"
        - "state.api_response (for structured mode)"
        - "Any fields referenced via ${} in consequence parameters"
        - "options_from_state path (if using dynamic options)"
        - "autonomous.context_fields paths (for autonomous mode)"
      state_writes:
        - "user_responses.${node_id}"
        - "awaiting_input (set when awaiting input, cleared when received)"
        - "Additional writes from consequence execution"

    examples:
      - title: Basic source type selection
        yaml: |
          ask_source_type:
            type: user_prompt
            prompt:
              question: "What type of source would you like to add?"
              header: "Source"
              options:
                - id: git
                  label: "Git repository"
                  description: "Clone a repository with docs folder"
                - id: local
                  label: "Local files"
                  description: "Files on your machine"
                - id: web
                  label: "Web pages"
                  description: "Cache blog posts or articles"
            on_response:
              git:
                consequence:
                  - type: set_state
                    field: source_type
                    value: git
                next_node: collect_git_url
              local:
                consequence:
                  - type: set_state
                    field: source_type
                    value: local
                next_node: collect_local_info
              web:
                consequence:
                  - type: set_state
                    field: source_type
                    value: web
                next_node: collect_web_urls
        explanation: |
          Presents three options to the user. Based on selection, sets the source_type
          state field and routes to the appropriate collection node.

      - title: Confirmation prompt
        yaml: |
          confirm_delete:
            type: user_prompt
            prompt:
              question: "Are you sure you want to delete this source?"
              header: "Confirm"
              options:
                - id: yes
                  label: "Yes, delete"
                  description: "Permanently remove the source"
                - id: no
                  label: "Cancel"
                  description: "Keep the source unchanged"
            on_response:
              yes:
                next_node: execute_delete
              no:
                next_node: cancelled

      - title: Route without consequence
        yaml: |
          select_output_format:
            type: user_prompt
            prompt:
              question: "Which output format do you prefer?"
              header: "Format"
              options:
                - id: markdown
                  label: "Markdown"
                  description: "Portable, readable in any editor"
                - id: json
                  label: "JSON"
                  description: "Machine-readable, for automation"
            on_response:
              markdown:
                next_node: generate_markdown
              json:
                next_node: generate_json

      - title: Dynamic options from state (disambiguation)
        yaml: |
          show_disambiguation:
            type: user_prompt
            description: Present top candidates for user selection
            prompt:
              question: "Multiple intents detected. Which did you mean?"
              header: "Clarify"
              options_from_state: computed.intent_matches.top_candidates
              option_mapping:
                id: rule.name
                label: rule.name
                description: rule.description
            on_response:
              selected:
                # User selected one of the dynamic options
                consequence:
                  - type: set_state
                    field: computed.matched_action
                    value: "${user_responses.show_disambiguation.selected.rule.action}"
                next_node: success_resolved
              other:
                # User typed custom text - re-parse with new input
                consequence:
                  - type: set_state
                    field: arguments
                    value: "${user_responses.show_disambiguation.text}"
                next_node: parse_intent_flags
        explanation: |
          Uses dynamic options from state array. The option_mapping transforms each
          candidate into an option. When user selects, the original item is available
          at user_responses.{node_id}.selected. When user types custom text, it's
          available at user_responses.{node_id}.text.

      - title: Tabular mode with prefix matching
        yaml: |
          # Workflow-level configuration in initial_state
          initial_state:
            prompts:
              mode: "tabular"
              tabular:
                match_strategy: "prefix"
                other_handler: "prompt"

          # Node definition (same structure as interactive mode)
          select_output_format:
            type: user_prompt
            prompt:
              question: "Which output format do you prefer?"
              header: "Format"
              options:
                - id: markdown
                  label: "Markdown"
                  description: "Portable, readable in any editor"
                - id: json
                  label: "JSON"
                  description: "Machine-readable, for automation"
                - id: yaml
                  label: "YAML"
                  description: "Structured and human-readable"
            on_response:
              markdown:
                next_node: generate_markdown
              json:
                next_node: generate_json
              yaml:
                next_node: generate_yaml
        explanation: |
          Tabular mode renders options as a markdown table:

          ## Which output format do you prefer?

          | Option ID | Label | Description |
          |-----------|-------|-------------|
          | markdown | Markdown | Portable, readable in any editor |
          | json | JSON | Machine-readable, for automation |
          | yaml | YAML | Structured and human-readable |

          **Please type the Option ID of your choice.**

          User types "mark"  matches "markdown" (prefix match)
          User types "json"  matches "json" (exact)
          User types "xyz"  re-prompts (no match)

      - title: Tabular mode with route to other handler
        yaml: |
          initial_state:
            prompts:
              mode: "tabular"
              tabular:
                match_strategy: "exact"
                other_handler: "route"

          select_or_custom:
            type: user_prompt
            prompt:
              question: "Select a preset or enter a custom value"
              header: "Choice"
              options:
                - id: preset1
                  label: "Preset 1"
                  description: "Common configuration"
                - id: preset2
                  label: "Preset 2"
                  description: "Alternative configuration"
            on_response:
              preset1:
                next_node: apply_preset1
              preset2:
                next_node: apply_preset2
              other:
                # Required when other_handler: "route"
                consequence:
                  - type: set_state
                    field: custom_value
                    value: "${user_responses.select_or_custom.text}"
                next_node: apply_custom
        explanation: |
          When other_handler is "route", unrecognized input routes to the "other"
          handler instead of re-prompting. The user's text is available at
          user_responses.{node_id}.text.

          User types "preset1"  matches, routes to apply_preset1
          User types "custom config"  no match, routes to other handler

      - title: Autonomous mode for embedded agents
        yaml: |
          # Workflow-level configuration for agent interface
          initial_state:
            prompts:
              interface: "agent"
              autonomous:
                strategy: "best_match"
                context_fields:
                  - computed.intent_flags
                  - arguments
                  - computed.context
                fallback: "other"
                confidence_threshold: 0.7
                explain_selection: true

          # Node definition (same structure, different execution)
          select_action:
            type: user_prompt
            prompt:
              question: "What action should be taken?"
              header: "Action"
              options:
                - id: create
                  label: "Create new"
                  description: "Create a new resource"
                - id: update
                  label: "Update existing"
                  description: "Modify an existing resource"
                - id: delete
                  label: "Delete"
                  description: "Remove a resource"
            on_response:
              create:
                next_node: execute_create
              update:
                next_node: execute_update
              delete:
                next_node: execute_delete
              other:
                # Fallback when confidence is too low
                consequence:
                  - type: set_state
                    field: computed.needs_clarification
                    value: true
                next_node: request_clarification
        explanation: |
          In autonomous mode, no user is prompted. The LLM evaluates options
          based on context_fields and selects the best match. If confidence
          is below threshold (0.7), routes to 'other' handler.

          Example: If arguments contains "create a new file" and intent_flags
          includes { create: true }, the LLM selects "create" with high confidence.

          The selection is logged when explain_selection is true:
          [DEBUG] Autonomous selection: create (confidence: 0.95)
          [DEBUG]   Context: {"arguments": "create a new file", ...}

      - title: Multi-modal with interface-specific modes
        yaml: |
          initial_state:
            prompts:
              interface: "auto"  # Auto-detect interface
              modes:
                claude_code: "interactive"  # AskUserQuestion tool
                web: "forms"                # Rich form rendering
                api: "structured"           # JSON schema response
                agent: "autonomous"         # LLM decides
              tabular:
                match_strategy: "prefix"
              autonomous:
                strategy: "best_match"
                confidence_threshold: 0.6
        explanation: |
          Different interfaces get different prompt modes automatically.

          - Claude Code CLI: Uses AskUserQuestion with structured options
          - Web (Claude.ai): Renders as clickable form/buttons
          - API: Returns JSON schema, expects structured response
          - Agent: LLM evaluates options without user interaction

          The same user_prompt node works across all interfaces.

      - title: API structured mode
        yaml: |
          initial_state:
            prompts:
              interface: "api"
              modes:
                api: "structured"

          # When interface is "api", the node returns structured prompt data
          # API consumer receives:
          # {
          #   "awaiting_input": true,
          #   "prompt": {
          #     "question": "Select output format",
          #     "options": [
          #       { "id": "json", "label": "JSON", "description": "..." },
          #       { "id": "yaml", "label": "YAML", "description": "..." }
          #     ],
          #     "response_format": {
          #       "selected_id": "string (required)"
          #     }
          #   }
          # }

          # API consumer responds with:
          # state.api_response = { node_id: "select_format", selected_id: "json" }
        explanation: |
          Structured mode is designed for programmatic API access.
          The prompt is returned as JSON schema, and the response
          is expected to match the schema format.

    related:
      - conditional
      - action
    since: "1.0.0"
    updated: "2.4.0"
    multi_modal_since: "2.4.0"
