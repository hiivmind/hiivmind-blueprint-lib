# Shared Fetch Patterns
# Canonical source parsing and fetching primitives for all resolution loaders
#
# Loaded once during bootstrap Phase 3, Step 3.0.
# After loading, parse_source() and fetch() are in context for all subsequent operations.

schema_version: "2.0"
category: resolution

resolution:
  fetch_patterns:
    description:
      brief: Shared source parsing and fetching primitives for all loaders
      detail: |
        Single source of truth for fetch operations used by execution-loader,
        type-loader, and workflow-loader. Loaded once during bootstrap to avoid
        duplicating ~135 lines across each loader.

    source_format:
      description: Source format supporting both remote GitHub repos and local paths
      patterns:
        remote: "{owner}/{repo}@{version}"
        local_relative: '"./" or "./{path}"'
        local_absolute: '"/absolute/path"'

      detection:
        is_local: |
          source.startsWith("./") OR source.startsWith("/")
        is_remote: |
          source.matches(/^[^\/]+\/[^@]+@.+$/)

      examples:
        - source: "hiivmind/hiivmind-blueprint-lib@v2.0.0"
          type: remote
        - source: "./"
          type: local
        - source: "/home/user/git/my-lib"
          type: local

    source_parsing:
      description: Parse source string into components (supports local and remote)
      effect: |
        FUNCTION parse_source(source):
            # Check for local path first
            IF source.startsWith("./") OR source.startsWith("/"):
                # Local path - resolve to absolute
                IF source.startsWith("./"):
                    local_path = resolve_relative_path(source)
                ELSE:
                    local_path = source

                # Validate path exists
                IF NOT directory_exists(local_path):
                    THROW "Local source path does not exist: {local_path}"

                RETURN {
                    is_local: true,
                    local_path: local_path,
                    owner: null,
                    repo: null,
                    version: null
                }

            # Parse remote: owner/repo@version
            match = source.match(/^([^\/]+)\/([^@]+)@(.+)$/)

            IF NOT match:
                THROW "Invalid source format: {source}. Expected: owner/repo@version or local path (./ or /path)"

            RETURN {
                is_local: false,
                local_path: null,
                owner: match[1],
                repo: match[2],
                version: match[3]
            }

    url_construction:
      description: Construct GitHub API path and raw URL from components
      effect: |
        FUNCTION construct_paths(owner, repo, version, path):
            RETURN {
                api_path: "repos/{owner}/{repo}/contents/{path}?ref={version}",
                raw_url: "https://raw.githubusercontent.com/{owner}/{repo}/{version}/{path}"
            }

    fetching:
      description: Fetch YAML content from local path or GitHub repository

      local_method:
        description: Read directly from local filesystem
        effect: |
          FUNCTION fetch_local(local_path, path):
              full_path = "{local_path}/{path}"

              IF NOT file_exists(full_path):
                  RETURN { success: false, error: "File not found: {full_path}" }

              result = CALL Read with:
                  file_path: full_path

              IF result.error:
                  RETURN { success: false, error: result.error }

              RETURN { success: true, content: parse_yaml(result.content) }

      gh_api_method:
        description: Use gh api for authenticated access (supports private repos)
        effect: |
          FUNCTION fetch_gh_api(owner, repo, path, version):
              result = CALL Bash with:
                  command: "gh api repos/{owner}/{repo}/contents/{path}?ref={version} --jq '.content' | base64 -d"

              IF result.exit_code != 0:
                  RETURN { success: false, error: result.stderr }

              RETURN { success: true, content: parse_yaml(result.stdout) }

      raw_url_method:
        description: Use raw.githubusercontent.com for public repos when gh unavailable
        effect: |
          FUNCTION fetch_raw_url(owner, repo, path, version):
              url = "https://raw.githubusercontent.com/{owner}/{repo}/{version}/{path}"
              response = CALL WebFetch with:
                  url: url
                  prompt: "Return the raw YAML content"

              IF response.status >= 400:
                  RETURN { success: false, error: "{response.status} {url}" }

              IF response.redirect_url:
                  RETURN fetch_raw_url_direct(response.redirect_url)

              RETURN { success: true, content: parse_yaml(response.content) }

      combined_fetch:
        description: Unified fetch with local → gh api → raw URL fallback chain
        effect: |
          FUNCTION fetch(source_parts, path):
              # Local path: direct file read
              IF source_parts.is_local:
                  result = fetch_local(source_parts.local_path, path)
                  IF result.success:
                      LOG "Fetched locally: {source_parts.local_path}/{path}"
                      RETURN result.content

                  THROW "Failed to fetch local: {source_parts.local_path}/{path}\n  Error: {result.error}"

              # Remote: try gh api first, then raw URL fallback
              owner = source_parts.owner
              repo = source_parts.repo
              version = source_parts.version

              result = fetch_gh_api(owner, repo, path, version)
              IF result.success:
                  LOG "Fetched via gh api: {owner}/{repo}/{path}@{version}"
                  RETURN result.content

              LOG "gh api failed, trying raw URL fallback"
              result = fetch_raw_url(owner, repo, path, version)
              IF result.success:
                  LOG "Fetched via raw URL: {owner}/{repo}/{path}@{version}"
                  RETURN result.content

              THROW "Failed to fetch: {owner}/{repo}/{path}@{version}\n  gh api: {result.error}\n  raw URL: {result.error}"

      method_selection:
        table: |
          | Source Type        | Primary Method | Fallback Method |
          |--------------------|----------------|-----------------|
          | Local path (./)    | fetch_local    | none (error)    |
          | Local path (/)     | fetch_local    | none (error)    |
          | Remote (owner/repo)| fetch_gh_api   | fetch_raw_url   |

    since: "3.1.0"
