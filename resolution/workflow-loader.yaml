# Workflow Loader
# Load reusable workflows from remote or local sources
#
# This file defines how reusable sub-workflows are loaded and resolved
# at execution time via reference nodes. Supports both GitHub repositories
# and local filesystem paths.

schema_version: "2.0"
category: resolution

resolution:
  workflow_loader:
    description:
      brief: Load reusable workflows from remote or local sources
      detail: |
        Workflows can reference reusable sub-workflows via the reference node type.
        The workflow loader resolves these references from GitHub repositories or
        local filesystem paths, enabling distributed, composable workflow ecosystems.

        Sub-workflows share state with the parent workflow, allowing them to
        read and modify parent state directly.
      notes:
        - Supports both remote GitHub repos and local filesystem paths
        - Uses gh api for fetching remote (private repo support)
        - Falls back to raw.githubusercontent.com for public repos when gh unavailable
        - Local paths bypass network entirely (instant, offline-capable)
        - Supports version pinning for reproducibility
        - Sub-workflows share state (unlike invoke_skill)
        - Dependencies are validated before execution

    reference_format:
      description: Reference format supporting both remote GitHub repos and local paths
      patterns:
        remote: "{owner}/{repo}@{version}:{workflow-name}"
        local_relative: '"./" or "./{path}:{workflow-name}"'
        local_absolute: '"/absolute/path:{workflow-name}"'

      examples:
        - source: "hiivmind/hiivmind-blueprint-lib@v2.0.0:intent-detection"
          type: remote
          description: Remote GitHub repository with version pin
        - source: "mycorp/custom-workflows@v1.0.0:validation-pipeline"
          type: remote
          description: Private or public GitHub repository
        - source: "./:intent-detection"
          type: local
          description: Workflow from current directory
        - source: "./lib/workflows:validation"
          type: local
          description: Workflow from relative path
        - source: "/home/user/git/my-workflows:intent-detection"
          type: local
          description: Workflow from absolute path

      detection:
        is_local: |
          ref.startsWith("./") OR ref.startsWith("/")
        is_remote: |
          ref.matches(/^[^\/]+\/[^@]+@[^:]+:.+$/)

      local_notes: |
        Local paths are useful for:
        - Development: Testing workflow changes before publishing
        - Monorepos: Workflows defined in same repository as consuming plugin
        - Offline: No network required for local paths
        - Speed: No network latency for local file reads

      version_formats:
        - format: "@v2.0.0"
          behavior: Exact version (recommended for production)
        - format: "@v2.0"
          behavior: Latest patch in v2.0.x
        - format: "@v2"
          behavior: Latest minor in v2.x.x (development)

    loading_algorithm:
      description: Main loading function for workflow references (supports local and remote)
      effect: |
        FUNCTION load_workflow(workflow_ref):
            # 1. Parse reference (returns {is_local, local_path, workflow_name} or {owner, repo, version, workflow_name})
            parts = parse_workflow_reference(workflow_ref)

            # 2. Fetch workflow index (routes to local/gh api/raw URL based on source type)
            index = fetch(parts, "workflows/index.yaml")

            # 3. Verify workflow exists
            IF parts.workflow_name NOT IN index.workflows:
                THROW "Workflow not found: {parts.workflow_name} in {workflow_ref}"

            # 4. Fetch workflow content
            workflow_info = index.workflows[parts.workflow_name]
            workflow_path = "workflows/" + workflow_info.path
            workflow = fetch(parts, workflow_path)

            # 5. Validate workflow
            validate_workflow(workflow)

            RETURN workflow

    fetching:
      description: Fetch YAML content from local path or GitHub repository

      local_method:
        description: Read directly from local filesystem (fastest, no network)
        effect: |
          FUNCTION fetch_local(local_path, path):
              full_path = "{local_path}/{path}"

              IF NOT file_exists(full_path):
                  RETURN { success: false, error: "File not found: {full_path}" }

              result = CALL Read with:
                  file_path: full_path

              IF result.error:
                  RETURN { success: false, error: result.error }

              RETURN { success: true, content: parse_yaml(result.content) }

        advantages:
          - No network latency
          - Works offline
          - No authentication required
          - Instant feedback during development

      gh_api_method:
        description: Use gh api for authenticated access (supports private repos)
        effect: |
          FUNCTION fetch_gh_api(owner, repo, path, version):
              result = CALL Bash with:
                  command: "gh api repos/{owner}/{repo}/contents/{path}?ref={version} --jq '.content' | base64 -d"

              IF result.exit_code != 0:
                  RETURN { success: false, error: result.stderr }

              RETURN { success: true, content: parse_yaml(result.stdout) }

        advantages:
          - Works with private repositories
          - Respects GitHub rate limits
          - Uses existing gh authentication

      raw_url_method:
        description: Use raw.githubusercontent.com for public repos when gh unavailable
        effect: |
          FUNCTION fetch_raw_url(owner, repo, path, version):
              url = "https://raw.githubusercontent.com/{owner}/{repo}/{version}/{path}"
              response = CALL WebFetch with:
                  url: url
                  prompt: "Return the raw YAML content"

              IF response.status >= 400:
                  RETURN { success: false, error: "{response.status} {url}" }

              # Handle redirects
              IF response.redirect_url:
                  RETURN fetch_raw_url_direct(response.redirect_url)

              RETURN { success: true, content: parse_yaml(response.content) }

        advantages:
          - Works without gh CLI installed
          - Good fallback for public repos
          - Simple HTTP fetch

      combined_fetch:
        description: Unified fetch supporting local paths and remote with fallback
        effect: |
          FUNCTION fetch(source_parts, path):
              # Local path: direct file read (fastest)
              IF source_parts.is_local:
                  result = fetch_local(source_parts.local_path, path)
                  IF result.success:
                      LOG "Fetched locally: {source_parts.local_path}/{path}"
                      RETURN result.content

                  THROW "Failed to fetch local: {source_parts.local_path}/{path}\n  Error: {result.error}"

              # Remote: try gh api first, then raw URL fallback
              owner = source_parts.owner
              repo = source_parts.repo
              version = source_parts.version

              result = fetch_gh_api(owner, repo, path, version)
              IF result.success:
                  LOG "Fetched via gh api: {owner}/{repo}/{path}@{version}"
                  RETURN result.content

              # Fall back to raw URL (public repos only)
              LOG "gh api failed, trying raw URL fallback"
              result = fetch_raw_url(owner, repo, path, version)
              IF result.success:
                  LOG "Fetched via raw URL: {owner}/{repo}/{path}@{version}"
                  RETURN result.content

              THROW "Failed to fetch: {owner}/{repo}/{path}@{version}\n  gh api: {result.error}\n  raw URL: {result.error}"

      method_selection:
        description: Which method is used based on source type
        table: |
          | Source Type        | Primary Method | Fallback Method |
          |--------------------|----------------|-----------------|
          | Local path (./)    | local_method   | none (error)    |
          | Local path (/)     | local_method   | none (error)    |
          | Remote (owner/repo)| gh_api_method  | raw_url_method  |

    reference_parsing:
      description: Parse workflow reference into components (supports local and remote)
      effect: |
        FUNCTION parse_workflow_reference(ref):
            # Check for local path first (path:workflow-name format)
            IF ref.startsWith("./") OR ref.startsWith("/"):
                # Local: path:workflow-name
                # Find the last colon to split path and workflow name
                last_colon = ref.lastIndexOf(":")

                IF last_colon == -1:
                    THROW "Invalid local reference: {ref}. Expected: path:workflow-name"

                path_part = ref.substring(0, last_colon)
                workflow_name = ref.substring(last_colon + 1)

                # Resolve path
                IF path_part.startsWith("./"):
                    local_path = resolve_relative_path(path_part)
                ELSE:
                    local_path = path_part

                # Validate path exists
                IF NOT directory_exists(local_path):
                    THROW "Local source path does not exist: {local_path}"

                RETURN {
                    is_local: true,
                    local_path: local_path,
                    workflow_name: workflow_name,
                    # Remote fields set to null for local sources
                    owner: null,
                    repo: null,
                    version: null,
                    base_ref: local_path
                }

            # Remote: owner/repo@version:workflow-name
            match = ref.match(/^([^\/]+)\/([^@]+)@([^:]+):(.+)$/)

            IF NOT match:
                THROW "Invalid workflow reference format: {ref}. Expected: owner/repo@version:workflow-name or local path"

            RETURN {
                is_local: false,
                local_path: null,
                owner: match[1],
                repo: match[2],
                version: match[3],
                workflow_name: match[4],
                base_ref: "{match[1]}/{match[2]}@{match[3]}"
            }

      examples:
        - input: "hiivmind/hiivmind-blueprint-lib@v2.0.0:intent-detection"
          output: |
            { is_local: false, owner: "hiivmind", repo: "hiivmind-blueprint-lib", version: "v2.0.0", workflow_name: "intent-detection" }

        - input: "./:intent-detection"
          output: |
            { is_local: true, local_path: "/current/working/directory", workflow_name: "intent-detection" }

        - input: "/home/user/git/my-workflows:validation"
          output: |
            { is_local: true, local_path: "/home/user/git/my-workflows", workflow_name: "validation" }

    local_references:
      description: Use doc parameter for local workflow references
      example: |
        detect_intent:
          type: reference
          doc: "lib/workflows/intent-detection.yaml"
          context:
            arguments: "${arguments}"
          next_node: execute_dynamic_route

    workflow_index_format:
      description: Structure of workflow index files
      example: |
        # workflows/index.yaml
        schema_version: "2.0"

        workflows:
          intent-detection:
            version: "1.0.0"
            path: "core/intent-detection.yaml"
            description: "3VL intent detection with dynamic routing"
            depends_on:
              consequences:
                - parse_intent_flags
                - match_3vl_rules
                - set_state
                - dynamic_route
              preconditions:
                - evaluate_expression
            inputs:
              - name: arguments
                type: string
                required: true
                description: "User input to parse"
              - name: intent_flags
                type: object
                required: true
                description: "Flag definitions from intent-mapping.yaml"
              - name: intent_rules
                type: array
                required: true
                description: "Rules from intent-mapping.yaml"
              - name: fallback_action
                type: string
                required: false
                default: "show_main_menu"
                description: "Action when no rules match"
            outputs:
              - name: computed.matched_action
                type: string
                description: "The resolved action to execute"
              - name: computed.intent_flags
                type: object
                description: "Parsed 3VL flag values"

      fields:
        - name: version
          required: true
          description: Workflow version (semver)
        - name: path
          required: true
          description: Path to workflow file relative to workflows/
        - name: description
          required: true
          description: What the workflow does
        - name: depends_on
          required: false
          description: Type dependencies for validation
        - name: depends_on.consequences
          required: false
          description: Required consequence types
        - name: depends_on.preconditions
          required: false
          description: Required precondition types
        - name: inputs
          required: true
          description: Input parameters
        - name: outputs
          required: true
          description: Output fields set by workflow

    dependency_validation:
      description: Validate workflow dependencies before execution
      effect: |
        FUNCTION validate_workflow_dependencies(workflow_info, type_registry):
            IF workflow_info.depends_on:
                # Check consequences
                FOR each type_name IN workflow_info.depends_on.consequences:
                    IF type_name NOT IN type_registry.consequences:
                        THROW "Workflow requires missing consequence type: {type_name}"

                # Check preconditions
                FOR each type_name IN workflow_info.depends_on.preconditions:
                    IF type_name NOT IN type_registry.preconditions:
                        THROW "Workflow requires missing precondition type: {type_name}"

    execution:
      description: Execute reference node with remote workflow
      effect: |
        FUNCTION execute_reference_node(node, types, state):
            IF node.workflow:
                # Remote workflow reference
                workflow = load_workflow(node.workflow)
            ELSE IF node.doc:
                # Local file reference
                workflow = parse_yaml(read_file(node.doc))
            ELSE:
                THROW "Reference node requires 'workflow' or 'doc' parameter"

            # Build context with interpolation
            context = {}
            FOR each key, value IN node.context:
                context[key] = interpolate(value, state)

            # Merge context into state (for shared state execution)
            FOR each key, value IN context:
                state[key] = value

            # Execute the referenced workflow
            # Note: State is SHARED - the workflow can read/write parent state
            execute_workflow(workflow, types, state)

            # Resolve next node (supports dynamic interpolation)
            target = resolve_routing_target(node.next_node, state)

            RETURN { next_node: target }

    input_output_mapping:
      description: How inputs and outputs are mapped

      inputs:
        description: Inputs are mapped from parent state via context parameter
        example: |
          detect_intent:
            type: reference
            workflow: hiivmind/hiivmind-blueprint-lib@v2.0.0:intent-detection
            context:
              arguments: "${arguments}"           # Maps state.arguments
              intent_flags: "${intent_flags}"     # Maps state.intent_flags
              intent_rules: "${intent_rules}"     # Maps state.intent_rules
              fallback_action: "show_main_menu"   # Literal value
            next_node: execute_dynamic_route

      outputs:
        description: Outputs are automatically available in parent state
        example: |
          # After intent-detection workflow completes:
          # - state.computed.matched_action is set
          # - state.computed.intent_flags is set
          # - state.computed.intent_matches is set

          # Parent workflow can use these directly:
          execute_dynamic_route:
            type: action
            actions:
              - type: dynamic_route
                action: "${computed.matched_action}"
            on_success: "${computed.dynamic_target}"
            on_failure: show_main_menu

    isolated_execution:
      description: Use invoke_skill for isolated execution with explicit mapping
      example: |
        detect_intent:
          type: action
          actions:
            - type: invoke_skill
              skill: hiivmind/hiivmind-blueprint-lib@v2.0.0:intent-detection
              input:
                arguments: "${arguments}"
                intent_flags: "${intent_flags}"
                intent_rules: "${intent_rules}"
              output_mapping:
                - from: computed.matched_action
                  to: computed.resolved_action
          on_success: execute_dynamic_route
          on_failure: show_main_menu

      comparison:
        - type: reference
          state: Shared
          use_case: Pattern libraries, documentation, composable workflows
        - type: invoke_skill
          state: Isolated
          use_case: Reusable skills, clean boundaries

    version_pinning:
      description: Use exact versions for reproducible builds

      formats:
        - format: "@v2.0.0"
          behavior: Exact version (recommended for production)
        - format: "@v2.0"
          behavior: Latest patch in v2.0.x
        - format: "@v2"
          behavior: Latest minor in v2.x.x (development)

    error_messages:
      description: Provide clear, actionable error messages for all source types

      examples:
        - error: "Workflow not found (remote)"
          source_type: remote
          context: |
            Reference: hiivmind/hiivmind-blueprint-lib@v2.0.0:my-workflow

            Tried:
            1. gh api repos/hiivmind/hiivmind-blueprint-lib/contents/workflows/index.yaml?ref=v2.0.0 → (success)
            2. Workflow 'my-workflow' not in index

            Available workflows in this version:
            - intent-detection (v1.0.0)

            Suggestions:
            - Check the workflow name for typos
            - Verify the workflow exists in the specified version
            - Check available workflows: https://github.com/hiivmind/hiivmind-blueprint-lib/releases

        - error: "Workflow not found (local)"
          source_type: local
          context: |
            Reference: ./:my-workflow

            Tried:
            1. /home/user/project/workflows/index.yaml → (success)
            2. Workflow 'my-workflow' not in index

            Available workflows:
            - intent-detection (v1.0.0)
            - validation (v1.0.0)

            Suggestions:
            - Check the workflow name for typos
            - Verify workflows/index.yaml lists this workflow
            - Run: yq '.workflows | keys' ./workflows/index.yaml

        - error: "Failed to fetch workflow (remote)"
          source_type: remote
          context: |
            Reference: hiivmind/hiivmind-blueprint-lib@v2.0.0:intent-detection

            Tried:
            1. gh api repos/hiivmind/hiivmind-blueprint-lib/contents/workflows/index.yaml?ref=v2.0.0 → (error)
            2. https://raw.githubusercontent.com/hiivmind/hiivmind-blueprint-lib/v2.0.0/workflows/index.yaml → (error)

            Suggestions:
            - For private repos: Verify gh auth status (gh auth status)
            - Check the version exists: https://github.com/hiivmind/hiivmind-blueprint-lib/tags
            - Verify network connectivity

        - error: "Failed to fetch workflow (local)"
          source_type: local
          context: |
            Reference: ./lib/workflows:intent-detection

            Tried:
            1. /home/user/project/lib/workflows/workflows/index.yaml → File not found

            Suggestions:
            - Verify the path exists: ls -la ./lib/workflows
            - Check for required files: workflows/index.yaml
            - Ensure proper directory structure with index.yaml files

        - error: "Local source path does not exist"
          source_type: local
          context: |
            Reference: /home/user/git/my-workflows:intent-detection

            The specified local path does not exist or is not a directory.

            Suggestions:
            - Verify the path: ls -la /home/user/git/my-workflows
            - Check spelling and case sensitivity
            - Use absolute path or ./ relative path

        - error: "Invalid workflow reference format"
          context: |
            Reference: invalid-reference

            Expected formats:
            - Remote: owner/repo@version:workflow-name (e.g., hiivmind/hiivmind-blueprint-lib@v2.0.0:intent-detection)
            - Local relative: ./:workflow-name or ./path:workflow-name
            - Local absolute: /path:workflow-name

        - error: "Workflow dependency missing"
          context: |
            Workflow: intent-detection@v1.0.0
            Missing consequence type: parse_intent_flags

            The workflow requires consequence types that are not in the loaded type registry.

            Loaded types: hiivmind/hiivmind-blueprint-lib@v1.0.0 (35 consequences)
            Required types: 43 consequences (workflow needs v2.0.0+)

            Suggestions:
            - Update type definitions to v2.0.0 or later
            - Add an extension with the missing type

    since: "2.1.0"
