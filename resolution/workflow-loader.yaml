# Workflow Loader
# Load reusable workflows from remote or local sources
#
# Fetching primitives: see resolution/fetch-patterns.yaml (loaded during bootstrap Phase 3.0)

schema_version: "2.0"
category: resolution

resolution:
  workflow_loader:
    description:
      brief: Load reusable workflows from remote or local sources
      detail: |
        Workflows can reference reusable sub-workflows via the reference node type.
        The workflow loader resolves these references from GitHub repositories or
        local filesystem paths, enabling distributed, composable workflow ecosystems.

        Sub-workflows share state with the parent workflow, allowing them to
        read and modify parent state directly.

    reference_format:
      description: Reference format supporting remote GitHub repos, local paths, and direct file references
      patterns:
        remote: "{owner}/{repo}@{version}:{workflow-name}"
        local_indexed: '"./" or "./{path}:{workflow-name}"'
        local_file: '"./path/to/workflow.yaml" (direct file path)'
        local_absolute: '"/absolute/path:{workflow-name}" or "/absolute/path/workflow.yaml"'

      examples:
        - source: "hiivmind/hiivmind-blueprint-lib@v2.0.0:intent-detection"
          type: remote
        - source: "./:intent-detection"
          type: local_indexed
        - source: "./subflows/load-skill.yaml"
          type: local_file
        - source: "/home/user/git/my-workflows:intent-detection"
          type: local_indexed

      detection:
        is_local_file: |
          (ref.startsWith("./") OR ref.startsWith("/")) AND ref.endsWith(".yaml")
        is_local_indexed: |
          (ref.startsWith("./") OR ref.startsWith("/")) AND ref.contains(":") AND NOT ref.endsWith(".yaml")
        is_remote: |
          ref.matches(/^[^\/]+\/[^@]+@[^:]+:.+$/)

      version_formats:
        - format: "@v2.0.0"
          behavior: Exact version (recommended for production)
        - format: "@v2.0"
          behavior: Latest patch in v2.0.x
        - format: "@v2"
          behavior: Latest minor in v2.x.x (development)

    loading_algorithm:
      description: Main loading function for workflow references (supports local file, local indexed, and remote)
      # Uses fetch() from resolution/fetch-patterns.yaml
      effect: |
        FUNCTION load_workflow(workflow_ref):
            # 1. Parse reference - determines source type and extracts components
            parts = parse_workflow_reference(workflow_ref)

            # 2. Route based on source type
            IF parts.is_local_file:
                # Direct file path: ./subflows/load-skill.yaml
                RETURN load_workflow_direct(parts.file_path)

            ELSE IF parts.is_local_indexed:
                # Local indexed: ./:workflow-name or ./path:workflow-name
                RETURN load_workflow_indexed(parts, is_local=true)

            ELSE:
                # Remote: owner/repo@version:workflow-name
                RETURN load_workflow_indexed(parts, is_local=false)

        FUNCTION load_workflow_direct(file_path):
            # Direct file loading - no index resolution
            IF NOT file_exists(file_path):
                THROW "Workflow file not found: {file_path}"

            workflow = parse_yaml(read_file(file_path))
            validate_workflow(workflow)
            RETURN workflow

        FUNCTION load_workflow_indexed(parts, is_local):
            # Index-based resolution
            # 1. Fetch workflow index
            index = fetch(parts, "workflows/index.yaml")

            # 2. Verify workflow exists
            IF parts.workflow_name NOT IN index.workflows:
                THROW "Workflow not found: {parts.workflow_name} in {parts.base_ref}"

            # 3. Fetch workflow content
            workflow_info = index.workflows[parts.workflow_name]
            workflow_path = "workflows/" + workflow_info.path
            workflow = fetch(parts, workflow_path)

            # 4. Validate workflow
            validate_workflow(workflow)

            RETURN workflow

    reference_parsing:
      description: Parse workflow reference into components (supports local file, local indexed, and remote)
      effect: |
        FUNCTION parse_workflow_reference(ref):
            # Check for local path first
            IF ref.startsWith("./") OR ref.startsWith("/"):

                # Check for direct file path (ends with .yaml)
                IF ref.endsWith(".yaml"):
                    IF ref.startsWith("./"):
                        file_path = resolve_relative_path(ref)
                    ELSE:
                        file_path = ref

                    RETURN {
                        is_local_file: true,
                        is_local_indexed: false,
                        is_remote: false,
                        file_path: file_path,
                        workflow_name: null,
                        local_path: null,
                        owner: null,
                        repo: null,
                        version: null,
                        base_ref: file_path
                    }

                # Local indexed: path:workflow-name format
                last_colon = ref.lastIndexOf(":")

                IF last_colon == -1:
                    THROW "Invalid local reference: {ref}. Expected: path:workflow-name or path/to/workflow.yaml"

                path_part = ref.substring(0, last_colon)
                workflow_name = ref.substring(last_colon + 1)

                IF path_part.startsWith("./"):
                    local_path = resolve_relative_path(path_part)
                ELSE:
                    local_path = path_part

                IF NOT directory_exists(local_path):
                    THROW "Local source path does not exist: {local_path}"

                RETURN {
                    is_local_file: false,
                    is_local_indexed: true,
                    is_remote: false,
                    file_path: null,
                    local_path: local_path,
                    workflow_name: workflow_name,
                    owner: null,
                    repo: null,
                    version: null,
                    base_ref: local_path
                }

            # Remote: owner/repo@version:workflow-name
            match = ref.match(/^([^\/]+)\/([^@]+)@([^:]+):(.+)$/)

            IF NOT match:
                THROW "Invalid workflow reference format: {ref}. Expected: owner/repo@version:workflow-name, path:workflow-name, or path/to/workflow.yaml"

            RETURN {
                is_local_file: false,
                is_local_indexed: false,
                is_remote: true,
                file_path: null,
                local_path: null,
                owner: match[1],
                repo: match[2],
                version: match[3],
                workflow_name: match[4],
                base_ref: "{match[1]}/{match[2]}@{match[3]}"
            }

      examples:
        - input: "hiivmind/hiivmind-blueprint-lib@v2.0.0:intent-detection"
          output: |
            { is_remote: true, owner: "hiivmind", repo: "hiivmind-blueprint-lib", version: "v2.0.0", workflow_name: "intent-detection" }

        - input: "./:intent-detection"
          output: |
            { is_local_indexed: true, local_path: "/current/working/directory", workflow_name: "intent-detection" }

        - input: "./subflows/load-skill.yaml"
          output: |
            { is_local_file: true, file_path: "/current/working/directory/subflows/load-skill.yaml" }

    local_references:
      description: Options for local workflow references
      examples:
        - title: Direct file path (recommended for local workflows)
          yaml: |
            load_skill:
              type: reference
              workflow: ./subflows/load-skill.yaml
              input:
                skill_path: "${args.path}"
              next_node: analyze_structure

        - title: Local indexed workflow
          yaml: |
            detect_intent:
              type: reference
              workflow: ./:intent-detection
              context:
                arguments: "${arguments}"
              next_node: execute_dynamic_route

        - title: Document reference (for markdown procedures)
          yaml: |
            clone_repo:
              type: reference
              doc: "lib/patterns/git-clone.md"
              section: "Clone Steps"
              context:
                repo_url: "${computed.repo_url}"
              next_node: verify_clone

    workflow_index_format:
      description: Structure of workflow index files
      example: |
        # workflows/index.yaml
        schema_version: "2.0"

        workflows:
          intent-detection:
            version: "1.0.0"
            path: "core/intent-detection.yaml"
            description: "3VL intent detection with dynamic routing"
            depends_on:
              consequences:
                - parse_intent_flags
                - match_3vl_rules
                - set_state
                - dynamic_route
              preconditions:
                - evaluate_expression
            inputs:
              - name: arguments
                type: string
                required: true
                description: "User input to parse"
              - name: intent_flags
                type: object
                required: true
                description: "Flag definitions from intent-mapping.yaml"
              - name: intent_rules
                type: array
                required: true
                description: "Rules from intent-mapping.yaml"
              - name: fallback_action
                type: string
                required: false
                default: "show_main_menu"
                description: "Action when no rules match"
            outputs:
              - name: computed.matched_action
                type: string
                description: "The resolved action to execute"
              - name: computed.intent_flags
                type: object
                description: "Parsed 3VL flag values"

      fields:
        - name: version
          required: true
          description: Workflow version (semver)
        - name: path
          required: true
          description: Path to workflow file relative to workflows/
        - name: description
          required: true
          description: What the workflow does
        - name: depends_on
          required: false
          description: Type dependencies for validation
        - name: inputs
          required: true
          description: Input parameters
        - name: outputs
          required: true
          description: Output fields set by workflow

    dependency_validation:
      description: Validate workflow dependencies before execution
      effect: |
        FUNCTION validate_workflow_dependencies(workflow_info, type_registry):
            IF workflow_info.depends_on:
                FOR each type_name IN workflow_info.depends_on.consequences:
                    IF type_name NOT IN type_registry.consequences:
                        THROW "Workflow requires missing consequence type: {type_name}"

                FOR each type_name IN workflow_info.depends_on.preconditions:
                    IF type_name NOT IN type_registry.preconditions:
                        THROW "Workflow requires missing precondition type: {type_name}"

    execution:
      description: Execute reference node with remote workflow
      effect: |
        FUNCTION execute_reference_node(node, types, state):
            IF node.workflow:
                workflow = load_workflow(node.workflow)
            ELSE IF node.doc:
                workflow = parse_yaml(read_file(node.doc))
            ELSE:
                THROW "Reference node requires 'workflow' or 'doc' parameter"

            # Build context with interpolation
            context = {}
            FOR each key, value IN node.context:
                context[key] = interpolate(value, state)

            # Merge context into state (for shared state execution)
            FOR each key, value IN context:
                state[key] = value

            # Execute the referenced workflow
            # Note: State is SHARED - the workflow can read/write parent state
            execute_workflow(workflow, types, state)

            # Resolve next node (supports dynamic interpolation)
            target = resolve_routing_target(node.next_node, state)

            RETURN { next_node: target }

    input_output_mapping:
      description: How inputs and outputs are mapped

      inputs:
        description: Inputs are mapped from parent state via context parameter
        example: |
          detect_intent:
            type: reference
            workflow: hiivmind/hiivmind-blueprint-lib@v2.0.0:intent-detection
            context:
              arguments: "${arguments}"
              intent_flags: "${intent_flags}"
              intent_rules: "${intent_rules}"
              fallback_action: "show_main_menu"
            next_node: execute_dynamic_route

      outputs:
        description: Outputs are automatically available in parent state
        example: |
          # After intent-detection workflow completes:
          # - state.computed.matched_action is set
          # - state.computed.intent_flags is set

          # Parent workflow can use these directly:
          execute_dynamic_route:
            type: action
            actions:
              - type: dynamic_route
                action: "${computed.matched_action}"
            on_success: "${computed.dynamic_target}"
            on_failure: show_main_menu

    isolated_execution:
      description: Use invoke_skill for isolated execution with explicit mapping
      example: |
        detect_intent:
          type: action
          actions:
            - type: invoke_skill
              skill: hiivmind/hiivmind-blueprint-lib@v2.0.0:intent-detection
              input:
                arguments: "${arguments}"
                intent_flags: "${intent_flags}"
                intent_rules: "${intent_rules}"
              output_mapping:
                - from: computed.matched_action
                  to: computed.resolved_action
          on_success: execute_dynamic_route
          on_failure: show_main_menu

      comparison:
        - type: reference
          state: Shared
          use_case: Pattern libraries, documentation, composable workflows
        - type: invoke_skill
          state: Isolated
          use_case: Reusable skills, clean boundaries

    error_messages:
      examples:
        - error: "Workflow not found (remote)"
          context: |
            Reference: hiivmind/hiivmind-blueprint-lib@v2.0.0:my-workflow

            Workflow 'my-workflow' not in index.
            Available workflows: intent-detection (v1.0.0)

            Suggestions:
            - Check the workflow name for typos
            - Verify the workflow exists in the specified version

        - error: "Failed to fetch workflow (remote)"
          context: |
            Reference: hiivmind/hiivmind-blueprint-lib@v2.0.0:intent-detection

            Tried:
            1. gh api repos/.../workflows/index.yaml → (error)
            2. raw.githubusercontent.com fallback → (error)

            Suggestions:
            - Verify gh auth status (gh auth status)
            - Check the version exists

        - error: "Direct workflow file not found"
          context: |
            Reference: ./subflows/load-skill.yaml

            File not found: /home/user/project/subflows/load-skill.yaml

            Suggestions:
            - Verify the file path: ls -la ./subflows/
            - Ensure the file has .yaml extension

    since: "2.1.0"
    direct_file_since: "3.1.0"
