# Execution Entrypoints
# Pre-composed yq queries for progressive loading of execution semantics
#
# Progressive loading strategy:
# - Phase 1: Fetch entrypoints only (small payloads, verifiable values)
# - Phase 2: Execute workflow using entrypoints as guide
# - Phase 3: Fetch detail sections on-demand when dispatching specific node types

schema_version: "2.0"
category: resolution

resolution:
  entrypoints:
    description:
      brief: Pre-composed yq queries for progressive execution semantics loading
      detail: |
        Instead of fetching entire files (2000+ lines), use these yq queries to
        extract minimal entrypoint data first. Each query returns a small payload
        with verifiable expected values.

        This creates a forcing function for actually reading the remote files:
        1. Execute the yq query
        2. Verify results match expected values
        3. Only proceed if verification passes

        If verification fails, the fetch was skipped or returned incorrect data.

    queries:
      fetch_patterns:
        description: Shared fetch primitives (loaded during bootstrap Phase 3.0)
        file: resolution/fetch-patterns.yaml
        yq: |
          {
            "functions": [.resolution.fetch_patterns | keys[] | select(. != "description" and . != "since")]
          }
        expected:
          functions:
            - "source_format"
            - "source_parsing"
            - "url_construction"
            - "fetching"
        verification: |
          After loading, parse_source() and fetch() must be available in context.

      bootstrap:
        description: Bootstrap phases and required section registry
        file: resolution/execution-loader.yaml
        yq: |
          {
            "phases": [.resolution.execution_loader.bootstrap.fetch_order.phases[].id],
            "required_sections": [.resolution.execution_loader.section_registry.sections | to_entries[] | select(.value.required == true) | .key]
          }
        expected:
          phases:
            - "bootstrap"
            - "execution_semantics"
            - "types"
            - "initialize"
            - "execute"
          required_sections:
            - "traversal"
            - "state"
            - "precondition_dispatch"
            - "consequence_dispatch"
        verification: |
          state._semantics.bootstrap.phases MUST equal ["bootstrap", "execution_semantics", "types", "initialize", "execute"]
          state._semantics.bootstrap.required_sections MUST contain exactly 4 items

      traversal:
        description: Traversal phases and dispatchable node types
        file: execution/engine_execution.yaml
        yq: |
          {
            "phases": [.execution.traversal.phases[].id],
            "node_types": ["action", "conditional", "user_prompt", "validation_gate", "reference"]
          }
        expected:
          phases:
            - "initialize"
            - "execute"
            - "complete"
          node_types:
            - "action"
            - "conditional"
            - "user_prompt"
            - "validation_gate"
            - "reference"
        verification: |
          state._semantics.traversal.phases MUST equal ["initialize", "execute", "complete"]
          This is the 3-phase model: initialize -> execute -> complete

      type_loading:
        description: Type loader hybrid threshold and strategies
        file: resolution/type-loader.yaml
        yq: |
          {
            "hybrid_threshold": .resolution.type_loader.hybrid_loading.threshold,
            "strategies": ["lazy", "selective", "hybrid"]
          }
        expected:
          hybrid_threshold: 30
          strategies:
            - "lazy"
            - "selective"
            - "hybrid"
        verification: |
          state._semantics.type_loading.hybrid_threshold MUST equal 30
          Workflows with < 30 types use selective loading; >= 30 use lazy loading

      workflow_references:
        description: Reference node format and state behavior
        file: resolution/workflow-loader.yaml
        yq: |
          {
            "reference_format": .resolution.workflow_loader.reference_format.patterns.remote,
            "state_sharing": "shared"
          }
        expected:
          reference_format: "{owner}/{repo}@{version}:{workflow-name}"
          state_sharing: "shared"
        verification: |
          Reference nodes share state with parent workflow
          invoke_skill isolates state (contrast with reference)

      output_defaults:
        description: Hardcoded output config defaults (no fetch required)
        file: resolution/execution-loader.yaml
        yq: |
          .resolution.execution_loader.optionality.output
        expected:
          level: "normal"
          display_enabled: true
          batch_enabled: true
          batch_threshold: 3
          use_icons: true
          log_enabled: true
          log_format: "yaml"
          log_location: ".logs/"
          ci_mode: false
        verification: |
          These defaults are used when output section is not explicitly loaded
          No remote fetch required for output defaults

    detail_queries:
      description: On-demand queries for specific sections (fetch when needed)

      execute_phase:
        description: The execute phase algorithm
        file: execution/engine_execution.yaml
        yq: '.execution.traversal.phases[] | select(.id == "execute") | .effect'
        use_when: Starting the main execution loop
        key_behaviors:
          - Check for multi-turn resume (state.awaiting_input)
          - Check for ending BEFORE dispatch
          - Flush batch before user_prompt nodes
          - Dispatch via dispatch_node() switch statement
          - Handle awaiting_input outcome
          - Apply batching logic based on output level
          - Record history entry
          - Auto-inject log_node if enabled
          - Update position (previous_node, current_node)

      initialize_phase:
        description: The initialize phase algorithm
        file: execution/engine_execution.yaml
        yq: '.execution.traversal.phases[] | select(.id == "initialize") | .effect'
        use_when: Starting workflow execution

      complete_phase:
        description: The complete phase algorithm
        file: execution/engine_execution.yaml
        yq: '.execution.traversal.phases[] | select(.id == "complete") | .effect'
        use_when: Reaching an ending node

      conditional_dispatch:
        description: How conditional nodes are executed
        file: execution/engine_execution.yaml
        yq: '.execution.traversal.dispatch.effect | match("CASE \"conditional\"[^C]+") | .string'
        use_when: Dispatching a conditional node

      action_dispatch:
        description: How action nodes are executed
        file: execution/engine_execution.yaml
        yq: '.execution.traversal.dispatch.effect | match("CASE \"action\"[^C]+") | .string'
        use_when: Dispatching an action node

      user_prompt_dispatch:
        description: How user_prompt nodes are executed
        file: execution/engine_execution.yaml
        yq: '.execution.traversal.dispatch.effect | match("CASE \"user_prompt\"[^C]+") | .string'
        use_when: Dispatching a user_prompt node

      reference_dispatch:
        description: How reference nodes are executed
        file: execution/engine_execution.yaml
        yq: '.execution.traversal.dispatch.effect | match("CASE \"reference\"[^C]+") | .string'
        use_when: Dispatching a reference node (sub-workflow loading)

      consequence_type:
        description: Get semantics for a specific consequence type
        file: consequences/consequences.yaml
        yq: '.consequences.${type_name}'
        param: type_name
        use_when: Executing a consequence you haven't seen before

    verification_protocol:
      description: How to verify entrypoints were actually loaded

      checkpoint_values:
        description: Specific values that MUST match after fetching
        items:
          - field: "_semantics.bootstrap.phases"
            expected: '["bootstrap", "execution_semantics", "types", "initialize", "execute"]'
            failure_action: Stop execution, report fetch error

          - field: "_semantics.traversal.phases"
            expected: '["initialize", "execute", "complete"]'
            failure_action: Stop execution, report fetch error

          - field: "_semantics.type_loading.hybrid_threshold"
            expected: 30
            failure_action: Stop execution, report fetch error

          - field: "_semantics.bootstrap.required_sections | length"
            expected: 4
            failure_action: Stop execution, report fetch error

      why_verification_matters: |
        Without verification checkpoints, Claude can:
        1. Skip fetching entirely and "wing it" from pattern matching
        2. Return plausible-but-wrong values from memory
        3. Execute workflows without following the actual semantics

        Verification forces actual fetching because:
        - The expected values are specific numbers/lists
        - They come from files that may change between versions
        - Incorrect values fail the checkpoint and halt execution

        This is a forcing function, not just documentation.
