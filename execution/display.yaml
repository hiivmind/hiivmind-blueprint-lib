# Display Configuration Loader
# 4-tier priority hierarchy for display configuration resolution
#
# This file defines how display configuration is loaded and resolved
# at workflow initialization. Display controls real-time terminal output
# (distinct from logging which writes to files).

schema_version: "2.3"
category: execution

execution:
  display:
    description:
      brief: 4-tier display configuration resolution
      detail: |
        Display configuration controls real-time terminal output during workflow execution.
        This is distinct from logging which writes to files. Display determines what the
        user sees in the terminal as the workflow runs.

        Configuration can be specified at multiple levels, with higher-priority
        levels overriding lower ones. This enables framework defaults, plugin-wide settings,
        skill-specific overrides, and runtime control.
      notes:
        - Runtime flags have highest priority
        - Skill-specific config overrides plugin defaults
        - Plugin defaults override framework defaults
        - Framework defaults are always fetched (with hardcoded fallback)
        - Batch mode collapses non-interactive nodes into summary lines

    priority_hierarchy:
      description: |
        Configuration is resolved from lowest to highest priority.
        Higher priority values override lower ones during deep merge.
      tiers:
        - tier: 4
          name: Framework defaults
          source: Remote lib (definitions.source) or hardcoded fallback
          priority: lowest
          description: Base defaults for all workflows

        - tier: 3
          name: Plugin config
          source: .hiivmind/blueprint/display.yaml
          priority: low
          description: Plugin-wide defaults

        - tier: 2
          name: Skill config
          source: workflow.initial_state.display
          priority: high
          description: Skill-specific overrides

        - tier: 1
          name: Runtime flags
          source: Command-line flags (--verbose, --quiet, --terse, etc.)
          priority: highest
          description: User runtime overrides

    loading_algorithm:
      description: Main loading function for display configuration
      effect: |
        FUNCTION load_display_config(workflow, plugin_root, runtime_flags):
            # Priority 1: Runtime flags (--verbose, --quiet, --terse, etc.)
            runtime_config = extract_display_from_runtime(runtime_flags)

            # Priority 2: Skill config (workflow.initial_state.display)
            skill_config = workflow.initial_state.display ?? {}

            # Priority 3: Plugin config (.hiivmind/blueprint/display.yaml)
            plugin_config_path = "{plugin_root}/.hiivmind/blueprint/display.yaml"
            IF file_exists(plugin_config_path):
                plugin_config = read_yaml(plugin_config_path)
            ELSE:
                plugin_config = {}

            # Priority 4: Framework defaults (fetched from lib)
            framework_config = load_framework_defaults(workflow.definitions)

            # Merge: runtime > skill > plugin > framework (deep merge)
            resolved_config = deep_merge(
                framework_config,  # Lowest priority
                plugin_config,
                skill_config,
                runtime_config     # Highest priority
            )

            # Validate resolved config
            validate_display_config(resolved_config)

            RETURN resolved_config

    runtime_flag_extraction:
      description: Extract display configuration from runtime flags
      effect: |
        FUNCTION extract_display_from_runtime(flags):
            config = {}

            # Verbosity flags
            IF flags.verbose OR flags.v:
                config.verbosity = "verbose"
            IF flags.quiet OR flags.q:
                config.verbosity = "silent"
            IF flags.terse:
                config.verbosity = "terse"
            IF flags.debug:
                config.verbosity = "debug"

            # Batch flag
            IF flags.no_batch:
                config.batch = config.batch ?? {}
                config.batch.enabled = false

            # Master switch
            IF flags.no_display:
                config.enabled = false

            RETURN config

      flag_mappings:
        - flag: "--verbose, -v"
          maps_to: "display.verbosity: verbose"
        - flag: "--quiet, -q"
          maps_to: "display.verbosity: silent"
        - flag: "--terse"
          maps_to: "display.verbosity: terse"
        - flag: "--debug"
          maps_to: "display.verbosity: debug"
        - flag: "--no-batch"
          maps_to: "display.batch.enabled: false"
        - flag: "--no-display"
          maps_to: "display.enabled: false"

    framework_defaults_loading:
      description: Fetch framework defaults from type definitions library
      effect: |
        FUNCTION load_framework_defaults(definitions_block):
            # 1. Parse source
            source = definitions_block.source
            parts = parse_source(source)  # {owner, repo, version}

            # 2. Construct URL
            url = "https://raw.githubusercontent.com/{parts.owner}/{parts.repo}/{parts.version}/display/defaults.yaml"

            # 3. Fetch defaults
            TRY:
                defaults = fetch(url)
                RETURN defaults.content
            CATCH:
                # Fallback to hardcoded defaults if fetch fails
                RETURN HARDCODED_DEFAULTS

      hardcoded_defaults:
        enabled: true
        verbosity: "normal"
        batch:
          enabled: true
          threshold: 3
          show_summary: true
          show_node_list: false
          expand_on_error: true
        show:
          workflow_state: true
          node_transitions: true
          condition_eval: false
          branch_result: true
          user_prompts: true
          tool_output: true
          final_result: true
          phase_markers: false
          spinner_text: true
        format:
          style: "structured"
          indent: 2
          use_icons: true
          timestamp: false

    verbosity_levels:
      description: |
        Verbosity levels control how much output is shown during execution.
        Each level includes all output from lower levels plus additional details.

      levels:
        - level: silent
          output:
            - User prompts (cannot be disabled)
            - Final result (cannot be disabled)
          use_case: Production or embedded workflows

        - level: terse
          output:
            - Batch summaries for non-interactive segments
            - User prompts
            - Final result
          use_case: Normal user-facing operation

        - level: normal
          output:
            - Node transition arrows (→ node_name)
            - Batch internal nodes when threshold met
            - User prompts
            - Final result
          use_case: Development and basic troubleshooting
          default: true

        - level: verbose
          output:
            - Workflow state at phase boundaries
            - All node details
            - Condition evaluation expressions
            - Branch decisions
            - No batching (all nodes shown)
          use_case: Debugging workflow logic

        - level: debug
          output:
            - Full state dumps at each node
            - All internal details
            - Interpolation steps
            - Type resolution details
          use_case: Deep debugging of engine behavior

    batch_mode:
      description: |
        Batch mode collapses consecutive non-interactive nodes into summary lines.
        This reduces visual noise while still providing feedback.

      algorithm:
        effect: |
          FUNCTION should_batch(node, state, display_config):
              # Never batch if batching disabled
              IF NOT display_config.batch.enabled:
                  RETURN false

              # Never batch at verbose+ levels
              IF display_config.verbosity IN ["verbose", "debug"]:
                  RETURN false

              # Never batch user_prompt nodes
              IF node.type == "user_prompt":
                  RETURN false

              # Never batch nodes with user-visible output
              IF node_has_visible_output(node):
                  RETURN false

              RETURN true

          FUNCTION flush_batch(batch_buffer, display_config, state):
              IF batch_buffer.length == 0:
                  RETURN

              # Check if threshold met
              IF batch_buffer.length < display_config.batch.threshold:
                  # Show individual nodes instead
                  FOR each node IN batch_buffer:
                      display_node_transition(node, display_config)
                  RETURN

              # Display batch summary
              last_node = batch_buffer[batch_buffer.length - 1]
              next_target = last_node.routing_target

              IF display_config.batch.show_summary:
                  IF display_config.batch.show_node_list:
                      node_ids = batch_buffer.map(n => n.id).join(", ")
                      DISPLAY "{batch_buffer.phase}... [{node_ids}] → {next_target}"
                  ELSE:
                      DISPLAY "{batch_buffer.phase}... [{batch_buffer.length} nodes] → {next_target}"
              ELSE:
                  DISPLAY "{batch_buffer.phase}... → {next_target}"

      breaking_conditions:
        - condition: user_prompt node
          reason: Requires user interaction
        - condition: Node with user-visible output
          reason: Tool output to show
        - condition: Error occurs
          reason: Expand on error for debugging
        - condition: verbose or debug verbosity
          reason: Detailed output requested
        - condition: Threshold not met
          reason: Less than N consecutive nodes

    deep_merge:
      description: Merge configuration objects with nested override
      effect: |
        FUNCTION deep_merge(...objects):
            result = {}

            FOR each obj IN objects:
                FOR each key, value IN obj:
                    IF value is object AND result[key] is object:
                        # Recursively merge nested objects
                        result[key] = deep_merge(result[key], value)
                    ELSE:
                        # Overwrite scalar or null values
                        result[key] = value

            RETURN result

      example:
        framework:
          verbosity: "normal"
          batch:
            enabled: true
            threshold: 3
        plugin:
          verbosity: "terse"
        skill:
          batch:
            threshold: 5
        result:
          verbosity: "terse"
          batch:
            enabled: true
            threshold: 5

    plugin_config_discovery:
      description: Find plugin-level display configuration
      effect: |
        FUNCTION find_plugin_config(skill_path):
            # Walk up from skill directory to find .hiivmind/blueprint/
            current = skill_path
            WHILE current != "/":
                candidate = "{current}/.hiivmind/blueprint/display.yaml"
                IF file_exists(candidate):
                    RETURN candidate
                current = parent_directory(current)
            RETURN null

    validation:
      description: Validate resolved display configuration
      effect: |
        FUNCTION validate_display_config(config):
            errors = []

            # Verbosity validation
            valid_levels = ["silent", "terse", "normal", "verbose", "debug"]
            IF config.verbosity AND config.verbosity NOT IN valid_levels:
                errors.push("Invalid verbosity level: {config.verbosity}")

            # Format style validation
            valid_styles = ["structured", "minimal", "inline"]
            IF config.format?.style AND config.format.style NOT IN valid_styles:
                errors.push("Invalid format style: {config.format.style}")

            # Batch threshold validation
            IF config.batch?.threshold:
                IF config.batch.threshold < 2:
                    errors.push("batch.threshold must be >= 2")
                IF config.batch.threshold > 100:
                    errors.push("batch.threshold must be <= 100")

            # Indent validation
            IF config.format?.indent:
                IF config.format.indent < 0 OR config.format.indent > 8:
                    errors.push("format.indent must be between 0 and 8")

            IF errors.length > 0:
                THROW "Display configuration validation failed:\n" + errors.join("\n")

      valid_values:
        verbosity: ["silent", "terse", "normal", "verbose", "debug"]
        format_style: ["structured", "minimal", "inline"]

    sub_workflow_inheritance:
      description: |
        When a reference node invokes a sub-workflow, display configuration
        is inherited by default. Can be overridden via context.display.

      default_behavior: |
        Sub-workflows inherit parent's state.display automatically because
        reference nodes share state with the parent workflow.

      override_pattern:
        yaml: |
          detect_intent:
            type: reference
            workflow: hiivmind/hiivmind-blueprint-lib@v2.0.0:intent-detection
            context:
              arguments: "${arguments}"
              display:                          # Override for this sub-workflow
                verbosity: "verbose"            # More detail for intent detection
                batch:
                  enabled: false                # Show all nodes
            next_node: execute_dynamic_route

    display_functions:
      description: Helper functions for rendering display output

      render_node_transition:
        effect: |
          FUNCTION display_node_transition(node_id, display_config):
              IF NOT display_config.show.node_transitions:
                  RETURN

              icon = display_config.format.use_icons ? "→ " : ""
              DISPLAY "{icon}{node_id}"

      render_condition_eval:
        effect: |
          FUNCTION display_condition_eval(condition, result, display_config):
              IF NOT display_config.show.condition_eval:
                  RETURN

              indent = " ".repeat(display_config.format.indent)
              DISPLAY "{indent}Condition: {condition.expression}"
              DISPLAY "{indent}Result: {result}"

      render_branch_result:
        effect: |
          FUNCTION display_branch_result(branch, target, display_config):
              IF NOT display_config.show.branch_result:
                  RETURN

              indent = " ".repeat(display_config.format.indent)
              DISPLAY "{indent}Branch: {branch} → {target}"

      render_batch_summary:
        effect: |
          FUNCTION display_batch_summary(batch, phase_name, target, display_config):
              IF display_config.batch.show_node_list:
                  nodes = batch.map(n => n.id).join(", ")
                  DISPLAY "{phase_name}... [{nodes}] → {target}"
              ELSE IF display_config.batch.show_summary:
                  DISPLAY "{phase_name}... [{batch.length} nodes] → {target}"
              ELSE:
                  DISPLAY "{phase_name}... → {target}"

      render_workflow_state:
        effect: |
          FUNCTION display_workflow_state(state, display_config):
              IF NOT display_config.show.workflow_state:
                  RETURN
              IF display_config.verbosity NOT IN ["verbose", "debug"]:
                  RETURN

              DISPLAY "● Workflow State:"
              indent = " ".repeat(display_config.format.indent)
              FOR each key, value IN state:
                  IF key NOT IN ["history", "log", "checkpoints"]:  # Skip large fields
                      DISPLAY "{indent}- {key}: {format_value(value)}"

      render_final_result:
        effect: |
          FUNCTION display_final_result(ending, state, display_config):
              # Final result always shown (show.final_result cannot be disabled)
              icon = display_config.format.use_icons ? (ending.type == "success" ? "✓ " : "✗ ") : ""

              message = interpolate(ending.message, state)
              DISPLAY "{icon}{message}"

              IF ending.summary:
                  indent = " ".repeat(display_config.format.indent)
                  FOR each key, value IN ending.summary:
                      DISPLAY "{indent}- {key}: {interpolate(value, state)}"

    since: "2.3.0"
