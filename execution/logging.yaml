# Logging Configuration Loader
# 4-tier priority hierarchy for logging configuration resolution
#
# This file defines how logging configuration is loaded and resolved
# at workflow initialization.

schema_version: "2.0"
category: execution

execution:
  logging:
    description:
      brief: 4-tier logging configuration resolution
      detail: |
        Logging configuration can be specified at multiple levels, with higher-priority
        levels overriding lower ones. This enables framework defaults, plugin-wide settings,
        skill-specific overrides, and runtime control.

        The loader resolves configuration from all tiers and deep-merges them into
        a single resolved configuration used during workflow execution.
      notes:
        - Runtime flags have highest priority
        - Skill-specific config overrides plugin defaults
        - Plugin defaults override framework defaults
        - Framework defaults are always fetched (with hardcoded fallback)
        - Auto-injection flags control consequence insertion

    priority_hierarchy:
      description: |
        Configuration is resolved from lowest to highest priority.
        Higher priority values override lower ones during deep merge.
      tiers:
        - tier: 4
          name: Framework defaults
          source: Remote lib (definitions.source) or hardcoded fallback
          priority: lowest
          description: Base defaults for all workflows

        - tier: 3
          name: Plugin config
          source: .hiivmind/blueprint/logging.yaml
          priority: low
          description: Plugin-wide defaults

        - tier: 2
          name: Skill config
          source: workflow.initial_state.logging
          priority: high
          description: Skill-specific overrides

        - tier: 1
          name: Runtime flags
          source: Command-line flags (--verbose, --log-level, etc.)
          priority: highest
          description: User runtime overrides

    loading_algorithm:
      description: Main loading function for logging configuration
      effect: |
        FUNCTION load_logging_config(workflow, plugin_root, runtime_flags):
            # Priority 1: Runtime flags (--log-level, --verbose, etc.)
            runtime_config = extract_logging_from_runtime(runtime_flags)

            # Priority 2: Skill config (workflow.initial_state.logging)
            skill_config = workflow.initial_state.logging ?? {}

            # Priority 3: Plugin config (.hiivmind/blueprint/logging.yaml)
            plugin_config_path = "{plugin_root}/.hiivmind/blueprint/logging.yaml"
            IF file_exists(plugin_config_path):
                plugin_config = read_yaml(plugin_config_path)
            ELSE:
                plugin_config = {}

            # Priority 4: Framework defaults (fetched from lib)
            framework_config = load_framework_defaults(workflow.definitions)

            # Merge: runtime > skill > plugin > framework (deep merge)
            resolved_config = deep_merge(
                framework_config,  # Lowest priority
                plugin_config,
                skill_config,
                runtime_config     # Highest priority
            )

            # Validate resolved config
            validate_logging_config(resolved_config)

            RETURN resolved_config

    runtime_flag_extraction:
      description: Extract logging configuration from runtime flags
      effect: |
        FUNCTION extract_logging_from_runtime(flags):
            config = {}

            # Level flags
            IF flags.log_level:
                config.level = flags.log_level
            IF flags.verbose OR flags.v:
                config.level = "debug"
            IF flags.quiet OR flags.q:
                config.level = "error"
            IF flags.trace:
                config.level = "trace"

            # Output flags
            IF flags.log_format:
                config.output = config.output ?? {}
                config.output.format = flags.log_format
            IF flags.log_dir:
                config.output = config.output ?? {}
                config.output.location = flags.log_dir

            # Control flags
            IF flags.no_log:
                config.enabled = false
            IF flags.ci:
                config.ci = config.ci ?? {}
                config.ci.format = "github"

            RETURN config

      flag_mappings:
        - flag: "--verbose, -v"
          maps_to: "logging.level: debug"
        - flag: "--quiet, -q"
          maps_to: "logging.level: error"
        - flag: "--trace"
          maps_to: "logging.level: trace"
        - flag: "--log-level=X"
          maps_to: "logging.level: X"
        - flag: "--log-format=X"
          maps_to: "logging.output.format: X"
        - flag: "--log-dir=X"
          maps_to: "logging.output.location: X"
        - flag: "--no-log"
          maps_to: "logging.enabled: false"
        - flag: "--ci"
          maps_to: "logging.ci.format: github"

    framework_defaults_loading:
      description: Fetch framework defaults from type definitions library
      effect: |
        FUNCTION load_framework_defaults(definitions_block):
            # 1. Parse source
            source = definitions_block.source
            parts = parse_source(source)  # {owner, repo, version}

            # 2. Construct URL
            url = "https://raw.githubusercontent.com/{parts.owner}/{parts.repo}/{parts.version}/logging/defaults.yaml"

            # 3. Fetch defaults
            TRY:
                defaults = fetch(url)
                RETURN defaults.content
            CATCH:
                # Fallback to hardcoded defaults if fetch fails
                RETURN HARDCODED_DEFAULTS

      hardcoded_defaults:
        enabled: true
        level: "info"
        auto:
          init: true
          finalize: true
          write: true
          node_tracking: true
        capture:
          nodes: true
          state_changes: false
          user_responses: true
          timing: true
        output:
          format: "yaml"
          location: ".logs/"
          filename: "{skill_name}-{timestamp}.{ext}"
        retention:
          strategy: "count"
          count: 10
        ci:
          format: "none"
          annotations: true

    deep_merge:
      description: Merge configuration objects with nested override
      effect: |
        FUNCTION deep_merge(...objects):
            result = {}

            FOR each obj IN objects:
                FOR each key, value IN obj:
                    IF value is object AND result[key] is object:
                        # Recursively merge nested objects
                        result[key] = deep_merge(result[key], value)
                    ELSE:
                        # Overwrite scalar or null values
                        result[key] = value

            RETURN result

      example:
        framework:
          enabled: true
          level: "info"
          auto:
            init: true
            node_tracking: true
          output:
            format: "yaml"
            location: ".logs/"
        plugin:
          level: "warn"
          output:
            location: "data/logs/"
        skill:
          auto:
            node_tracking: false
        result:
          enabled: true
          level: "warn"
          auto:
            init: true
            node_tracking: false
          output:
            format: "yaml"
            location: "data/logs/"

    plugin_config_discovery:
      description: Find plugin-level logging configuration
      effect: |
        FUNCTION find_plugin_config(skill_path):
            # Walk up from skill directory to find .hiivmind/blueprint/
            current = skill_path
            WHILE current != "/":
                candidate = "{current}/.hiivmind/blueprint/logging.yaml"
                IF file_exists(candidate):
                    RETURN candidate
                current = parent_directory(current)
            RETURN null

    validation:
      description: Validate resolved logging configuration
      effect: |
        FUNCTION validate_logging_config(config):
            errors = []

            # Level validation
            valid_levels = ["error", "warn", "info", "debug", "trace"]
            IF config.level AND config.level NOT IN valid_levels:
                errors.push("Invalid log level: {config.level}")

            # Output format validation
            valid_formats = ["yaml", "json", "markdown"]
            IF config.output?.format AND config.output.format NOT IN valid_formats:
                errors.push("Invalid output format: {config.output.format}")

            # Retention validation
            valid_strategies = ["none", "days", "count"]
            IF config.retention?.strategy AND config.retention.strategy NOT IN valid_strategies:
                errors.push("Invalid retention strategy: {config.retention.strategy}")

            IF config.retention?.strategy == "days" AND NOT config.retention?.days:
                errors.push("retention.days required when strategy is 'days'")

            IF config.retention?.strategy == "count" AND NOT config.retention?.count:
                errors.push("retention.count required when strategy is 'count'")

            # CI format validation
            valid_ci_formats = ["none", "github", "plain", "json"]
            IF config.ci?.format AND config.ci.format NOT IN valid_ci_formats:
                errors.push("Invalid CI format: {config.ci.format}")

            IF errors.length > 0:
                THROW "Logging configuration validation failed:\n" + errors.join("\n")

      valid_values:
        level: ["error", "warn", "info", "debug", "trace"]
        output_format: ["yaml", "json", "markdown"]
        retention_strategy: ["none", "days", "count"]
        ci_format: ["none", "github", "plain", "json"]

    sub_workflow_inheritance:
      description: |
        When a reference node invokes a sub-workflow, logging configuration
        is inherited by default. Can be overridden via context.logging.

      default_behavior: |
        Sub-workflows inherit parent's state.logging automatically because
        reference nodes share state with the parent workflow.

      override_pattern:
        yaml: |
          detect_intent:
            type: reference
            workflow: hiivmind/hiivmind-blueprint-lib@v2.0.0:intent-detection
            context:
              arguments: "${arguments}"
              logging:                        # Override for this sub-workflow
                level: "debug"                # More verbose for intent detection
                auto:
                  node_tracking: true
            next_node: execute_dynamic_route

      log_nesting:
        description: |
          Sub-workflow logs are nested within the parent's log for traceability.
        example: |
          node_history:
            - id: validate_input
              outcome: success
              timestamp: "2026-01-28T10:30:00Z"

            - id: detect_intent
              outcome: success
              timestamp: "2026-01-28T10:30:01Z"
              sub_workflow:                   # Nested sub-workflow log
                name: "intent-detection"
                version: "1.0.0"
                node_history:
                  - id: parse_flags
                    outcome: success
                  - id: match_rules
                    outcome: success
                status: "success"

            - id: execute_action
              outcome: success
              timestamp: "2026-01-28T10:30:02Z"

    auto_injection:
      description: |
        The engine automatically injects logging consequences based on auto.* flags.
        This ensures consistent logging without requiring explicit consequences in every workflow.

      flags:
        - flag: auto.init
          injects: init_log
          phase: Initialize (Phase 1)
          description: Create log session at workflow start

        - flag: auto.node_tracking
          injects: log_node
          phase: Execute (Phase 2, after each node)
          description: Record each node execution in log

        - flag: auto.finalize
          injects: finalize_log
          phase: Complete (Phase 3)
          description: Finalize log with status and summary

        - flag: auto.write
          injects: write_log
          phase: Complete (Phase 3)
          description: Write log to file

    since: "1.3.0"
