# Precondition Dispatch
# Type-based precondition evaluation
#
# This file defines how preconditions are evaluated based on their
# type definitions from the TypeRegistry.

schema_version: "2.0"
category: execution

execution:
  precondition_dispatch:
    description:
      brief: Type-based precondition evaluation
      detail: |
        Preconditions are boolean evaluations that don't modify state.
        They are used in conditional nodes, validation gates, and entry checks
        to determine workflow routing based on current state.

        Each precondition has a type that maps to a definition in the TypeRegistry
        (loaded from preconditions/core/*.yaml or extensions).
      notes:
        - Preconditions are pure evaluations (no side effects)
        - Return boolean true/false
        - Supports ${...} interpolation in parameters
        - Composite preconditions (all_of, any_of, xor_of, none_of) combine multiple conditions

    evaluation_algorithm:
      description: Main evaluation function for preconditions
      effect: |
        FUNCTION evaluate_precondition(precondition, types, state):
            # 1. Resolve type definition
            type_def = types.preconditions[precondition.type]
            IF type_def == null:
                THROW "Unknown precondition type: {precondition.type}"

            # 2. Interpolate parameters
            params = interpolate_params(precondition, type_def, state)

            # 3. Evaluate based on type
            SWITCH precondition.type:
                # === Filesystem ===
                CASE "file_exists":
                    RETURN file_exists(params.path)
                CASE "directory_exists":
                    RETURN directory_exists(params.path)
                CASE "file_not_exists":
                    RETURN NOT file_exists(params.path)
                CASE "config_exists":
                    RETURN file_exists("data/config.yaml")

                # === State ===
                CASE "flag_set":
                    RETURN state.flags[params.flag] == true
                CASE "flag_not_set":
                    RETURN state.flags[params.flag] != true
                CASE "state_equals":
                    RETURN get_nested(state, params.field) == params.value
                CASE "state_not_equals":
                    RETURN get_nested(state, params.field) != params.value
                CASE "state_not_null":
                    RETURN get_nested(state, params.field) != null
                CASE "state_is_null":
                    RETURN get_nested(state, params.field) == null
                CASE "state_not_empty":
                    value = get_nested(state, params.field)
                    RETURN value != null AND value != "" AND value.length > 0

                # === Composite ===
                CASE "all_of":
                    FOR each cond IN params.conditions:
                        IF NOT evaluate_precondition(cond, types, state):
                            RETURN false
                    RETURN true

                CASE "any_of":
                    FOR each cond IN params.conditions:
                        IF evaluate_precondition(cond, types, state):
                            RETURN true
                    RETURN false

                CASE "none_of":
                    FOR each cond IN params.conditions:
                        IF evaluate_precondition(cond, types, state):
                            RETURN false
                    RETURN true

                CASE "xor_of":
                    # Exactly one must be true (no short-circuit)
                    true_count = 0
                    FOR each cond IN params.conditions:
                        IF evaluate_precondition(cond, types, state):
                            true_count += 1
                    RETURN true_count == 1

                # === Expression ===
                CASE "evaluate_expression":
                    RETURN evaluate_expression(params.expression, state)

                # === Tool ===
                CASE "tool_available":
                    RETURN check_tool_available(params.tool)

                DEFAULT:
                    # Fall back to type definition evaluation
                    RETURN evaluate_from_definition(type_def, params, state)

    type_categories:
      - category: filesystem
        description: Check file and directory existence
        types:
          - name: file_exists
            description: True if file exists at path
            parameters:
              - name: path
                type: string
                required: true
          - name: directory_exists
            description: True if directory exists at path
            parameters:
              - name: path
                type: string
                required: true
          - name: file_not_exists
            description: True if file does NOT exist at path
            parameters:
              - name: path
                type: string
                required: true
          - name: config_exists
            description: True if data/config.yaml exists (convenience)
            parameters: []

      - category: state
        description: Check state values and flags
        types:
          - name: flag_set
            description: True if flag is set to true
            parameters:
              - name: flag
                type: string
                required: true
          - name: flag_not_set
            description: True if flag is not set or false
            parameters:
              - name: flag
                type: string
                required: true
          - name: state_equals
            description: True if state field equals value
            parameters:
              - name: field
                type: string
                required: true
              - name: value
                type: any
                required: true
          - name: state_not_null
            description: True if state field is not null
            parameters:
              - name: field
                type: string
                required: true
          - name: state_is_null
            description: True if state field is null
            parameters:
              - name: field
                type: string
                required: true
          - name: state_not_empty
            description: True if state field is not null/empty/zero-length
            parameters:
              - name: field
                type: string
                required: true

      - category: composite
        description: Combine multiple preconditions with logical operators
        types:
          - name: all_of
            description: True if ALL conditions are true (AND)
            short_circuit: true
            parameters:
              - name: conditions
                type: array
                items: precondition
                required: true
          - name: any_of
            description: True if ANY condition is true (OR)
            short_circuit: true
            parameters:
              - name: conditions
                type: array
                items: precondition
                required: true
          - name: none_of
            description: True if NO conditions are true (NOR)
            short_circuit: true
            parameters:
              - name: conditions
                type: array
                items: precondition
                required: true
          - name: xor_of
            description: True if EXACTLY ONE condition is true (XOR)
            short_circuit: false
            parameters:
              - name: conditions
                type: array
                items: precondition
                required: true

      - category: expression
        description: Evaluate arbitrary expressions
        types:
          - name: evaluate_expression
            description: Evaluate expression as boolean
            parameters:
              - name: expression
                type: string
                required: true
                description: Expression string to evaluate (e.g., "len(computed.sources) > 0")

      - category: tool
        description: Check tool availability
        types:
          - name: tool_available
            description: True if tool is available in environment
            parameters:
              - name: tool
                type: string
                required: true

    fallback_evaluation:
      description: |
        For types not hardcoded in the dispatch, evaluate using the
        type definition's evaluation field.
      effect: |
        FUNCTION evaluate_from_definition(type_def, params, state):
            # The type definition contains evaluation instructions
            # that the LLM interprets directly
            evaluation = type_def.evaluation

            IF evaluation.effect:
                # Apply the evaluation effect
                RETURN apply_evaluation(evaluation.effect, params, state)

            THROW "Type {type_def.type} has no evaluation defined"

    audit_mode:
      description: |
        When used with conditional nodes in audit mode, preconditions are
        evaluated without short-circuiting to collect all results.
      behavior:
        - All conditions are evaluated regardless of intermediate results
        - Results are collected with pass/fail status
        - Error messages from audit.messages are attached to failures
        - Final result depends on composite type (all_of, any_of, xor_of)

      effect: |
        # Called from conditional node when audit.enabled = true
        FUNCTION evaluate_with_audit(condition, type_def, state, audit_config):
            conditions = get_nested_conditions(condition)
            results = []

            FOR index, cond IN enumerate(conditions):
                result = evaluate_precondition(cond, types, state)

                entry = {
                    index: index,
                    condition: cond,
                    passed: result
                }

                IF NOT result AND audit_config.messages[cond.type]:
                    entry.message = audit_config.messages[cond.type]

                results.append(entry)

            RETURN {
                results: results,
                passed_count: count(results, r => r.passed),
                failed_count: count(results, r => NOT r.passed),
                total: results.length
            }

        FUNCTION get_nested_conditions(condition):
            # For composite preconditions, return the nested conditions array
            IF condition.type IN ["all_of", "any_of", "xor_of", "none_of"]:
                RETURN condition.conditions
            ELSE:
                # Single condition - wrap in array for uniform processing
                RETURN [condition]

    since: "1.0.0"
