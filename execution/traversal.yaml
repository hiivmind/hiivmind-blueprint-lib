# Workflow Execution Traversal
# Core loop for executing workflow nodes
#
# This file defines the abstract execution engine that the LLM interprets
# directly. It is the authoritative source for workflow execution semantics.

schema_version: "2.3"
category: execution

execution:
  traversal:
    description:
      brief: Core workflow execution loop
      detail: |
        Executes workflows following a 3-phase model:
        Phase 1: Initialize - Load workflow, types, state
        Phase 2: Execute - Loop through nodes until ending
        Phase 3: Complete - Finalize log, write output

        This is an LLM-native execution model: the LLM interprets these patterns
        directly, enabling extensibility through new type definitions rather than
        engine modifications.
      notes:
        - Single entry point per workflow (start_node)
        - Node dispatch based on node.type field
        - State is shared and mutable throughout execution
        - Supports both static and dynamic routing targets
        - Logging auto-injection based on config flags

    phases:
      - id: initialize
        description: |
          Load workflow, resolve types, initialize state, check entry preconditions.
          This phase runs once before the execution loop begins.
        effect: |
          FUNCTION initialize(workflow_path, plugin_root, runtime_flags):
              # 1. Load workflow
              workflow = parse_yaml(read_file(workflow_path))

              # 2. Load type definitions (see resolution/type-loader.yaml)
              types = load_types(workflow.definitions)

              # 3. Load and resolve logging config (see execution/logging.yaml)
              logging_config = load_logging_config(workflow, plugin_root, runtime_flags)

              # 4. Load and resolve display config (see execution/display.yaml)
              display_config = load_display_config(workflow, plugin_root, runtime_flags)

              # 5. Validate
              validate_schema(workflow)
              validate_types_exist(workflow, types)
              validate_graph_connectivity(workflow)

              # 6. Check entry preconditions
              FOR each precondition IN workflow.entry_preconditions:
                  result = evaluate_precondition(precondition, types)
                  IF result == false:
                      DISPLAY "Cannot start: {precondition.error_message or 'precondition failed'}"
                      STOP

              # 7. Initialize state (see execution/state.yaml for structure)
              state = {
                  workflow_name: workflow.name,
                  workflow_version: workflow.version,
                  current_node: workflow.start_node,
                  previous_node: null,
                  interface: detect_interface(),
                  history: [],
                  user_responses: {},
                  computed: {},
                  flags: copy(workflow.initial_state.flags or {}),
                  checkpoints: {},
                  logging: logging_config,
                  display: display_config,
                  batch_buffer: [],              # Buffer for batched nodes
                  log: null,
                  ...workflow.initial_state  # Copy custom fields
              }

              # 8. Auto-inject init_log if enabled
              IF logging_config.enabled AND logging_config.auto.init:
                  execute_consequence({
                      type: "init_log",
                      workflow_name: workflow.name,
                      log_level: logging_config.level
                  }, types, state)

              RETURN { workflow, types, state }

      - id: execute
        description: |
          Main execution loop. Processes nodes sequentially until an ending is reached.
          Each iteration: get node, check for ending, dispatch, record history, route.

          Supports multi-turn conversation via awaiting_input state:
          - If awaiting_input is set, resume the waiting node with user input
          - If node returns { awaiting_input: true }, pause execution for user response

          Display integration:
          - Batches consecutive non-interactive nodes when batch.enabled
          - Flushes batch on user_prompt nodes, visible output, or threshold
          - Respects verbosity levels for output detail
        effect: |
          FUNCTION execute(workflow, types, state):
              LOOP:
                  # Check for multi-turn resume (tabular mode user_prompt)
                  IF state.awaiting_input:
                      # Resume the waiting node with user's input
                      state.awaiting_input.user_input = get_user_input()
                      node = workflow.nodes[state.awaiting_input.node_id]
                      state.current_node = state.awaiting_input.node_id
                  ELSE:
                      node = workflow.nodes[state.current_node]

                  # Check for ending
                  IF state.current_node IN workflow.endings:
                      # Flush any remaining batched nodes before ending
                      flush_batch(state.batch_buffer, state.display, state)
                      ending = workflow.endings[state.current_node]
                      GOTO Phase 3 (completion)

                  # Check if this node should break the batch (user_prompt, visible output)
                  IF should_flush_batch(node, state.display):
                      flush_batch(state.batch_buffer, state.display, state)

                  # Execute node based on type (see nodes/core/*.yaml)
                  outcome = dispatch_node(node, types, state)

                  # Handle awaiting_input (multi-turn pause)
                  IF outcome.awaiting_input:
                      # Node is waiting for user input - pause execution
                      # state.awaiting_input already set by the node
                      PAUSE execution
                      RETURN  # Will resume on next conversation turn

                  # Handle display output based on verbosity and batching
                  IF should_batch_node(node, state.display):
                      # Add to batch buffer
                      state.batch_buffer.append({
                          id: state.current_node,
                          outcome: outcome,
                          routing_target: outcome.next_node,
                          phase: infer_phase_name(state)
                      })
                      # Check if batch threshold reached
                      IF state.batch_buffer.length >= state.display.batch.threshold:
                          flush_batch(state.batch_buffer, state.display, state)
                  ELSE:
                      # Display node transition immediately
                      display_node_execution(state.current_node, node, outcome, state.display)

                  # Record in history
                  state.history.append({
                      node: state.current_node,
                      outcome: outcome,
                      timestamp: now()
                  })

                  # Auto-inject log_node if enabled
                  IF state.logging.enabled AND state.logging.auto.node_tracking:
                      execute_consequence({
                          type: "log_node",
                          node_id: state.current_node,
                          outcome: outcome
                      }, types, state)

                  # Update position
                  state.previous_node = state.current_node
                  state.current_node = outcome.next_node

              UNTIL ending

      - id: complete
        description: |
          Finalization phase. Generates logs, displays results to user.
          Runs once after the execution loop reaches an ending.
        effect: |
          FUNCTION complete(ending, state, types):
              # Auto-inject finalize_log if enabled
              IF state.logging.enabled AND state.logging.auto.finalize:
                  execute_consequence({
                      type: "finalize_log",
                      status: ending.type,
                      summary: ending.summary
                  }, types, state)

              # Auto-inject write_log if enabled
              IF state.logging.enabled AND state.logging.auto.write:
                  filename = interpolate_filename(state.logging.output.filename, {
                      skill_name: state.workflow_name,
                      timestamp: now().format("YYYY-MM-DD_HH-mm-ss"),
                      ext: format_to_extension(state.logging.output.format)
                  })
                  execute_consequence({
                      type: "write_log",
                      path: "{state.logging.output.location}/{filename}"
                  }, types, state)

              # Display result to user
              message = interpolate(ending.message, state)

              IF ending.type == "success":
                  DISPLAY message
                  IF ending.summary:
                      FOR each key, value IN ending.summary:
                          DISPLAY "  {key}: {interpolate(value, state)}"

              ELSE IF ending.type == "error":
                  DISPLAY "Error: " + message
                  IF ending.details:
                      DISPLAY interpolate(ending.details, state)
                  IF ending.recovery:
                      DISPLAY "Try running: /{ending.recovery}"

              RETURN ending.type

    dispatch:
      description: |
        Node type dispatch. Routes to the appropriate node executor based on type.
        Each node type has its own execution semantics defined in nodes/core/*.yaml.
      effect: |
        FUNCTION dispatch_node(node, types, state):
            # Dispatch based on node.type
            # See nodes/core/*.yaml for individual node execution semantics
            SWITCH node.type:
                CASE "action":
                    RETURN execute_action_node(node, types, state)
                CASE "conditional":
                    RETURN execute_conditional_node(node, types, state)
                CASE "user_prompt":
                    RETURN execute_user_prompt_node(node, types, state)
                CASE "validation_gate":
                    # DEPRECATED: Use conditional with audit.enabled
                    RETURN execute_validation_gate_node(node, types, state)
                CASE "reference":
                    RETURN execute_reference_node(node, types, state)
                DEFAULT:
                    THROW "Unknown node type: {node.type}"

    interface_detection:
      description: |
        Detects the execution environment (Claude Code vs Claude.ai).
        This affects how user prompts are presented.
      effect: |
        FUNCTION detect_interface():
            # Claude Code: AskUserQuestion tool is available
            # Claude.ai: No tool access, conversational mode
            IF tool_available("AskUserQuestion"):
                RETURN "claude_code"
            ELSE:
                RETURN "claude_ai"

    capabilities:
      interface_modes:
        - id: claude_code
          description: Full tool access, AskUserQuestion available
          features:
            - Structured prompts via AskUserQuestion tool
            - Multi-select support
            - File operations via tools
        - id: claude_ai
          description: Conversational mode, no tool access
          features:
            - Markdown table prompts
            - Single response per turn
            - User types responses in chat

    benefits:
      - name: Extensibility
        description: New types require only definition files, not engine changes
      - name: Self-describing
        description: Type definitions fully specify behavior via pseudocode effects
      - name: Natural handling
        description: The LLM naturally handles interpolation, error recovery, tool calls
      - name: Zero deployment
        description: Updates to types or engine apply to all skills immediately

    display_helpers:
      description: |
        Helper functions for display output during workflow execution.
        These functions are called by the execute phase to render output.

      should_batch_node:
        description: Determine if a node should be added to the batch buffer
        effect: |
          FUNCTION should_batch_node(node, display_config):
              # Never batch if batching disabled
              IF NOT display_config.batch.enabled:
                  RETURN false

              # Never batch at verbose+ levels (show all details)
              IF display_config.verbosity IN ["verbose", "debug"]:
                  RETURN false

              # Never batch in silent mode (no intermediate output)
              IF display_config.verbosity == "silent":
                  RETURN false

              # Never batch user_prompt nodes
              IF node.type == "user_prompt":
                  RETURN false

              # Batch action and conditional nodes in terse/normal modes
              RETURN true

      should_flush_batch:
        description: Determine if the batch should be flushed before executing this node
        effect: |
          FUNCTION should_flush_batch(node, display_config):
              # Always flush before user_prompt nodes
              IF node.type == "user_prompt":
                  RETURN true

              # Flush if batch is at threshold
              # (handled separately in execute loop)

              RETURN false

      flush_batch:
        description: Render batched nodes and clear the buffer
        effect: |
          FUNCTION flush_batch(batch_buffer, display_config, state):
              IF batch_buffer.length == 0:
                  RETURN

              # In silent mode, don't display batch summaries
              IF display_config.verbosity == "silent":
                  batch_buffer.clear()
                  RETURN

              # If below threshold, show individual transitions instead
              IF batch_buffer.length < display_config.batch.threshold:
                  FOR each entry IN batch_buffer:
                      display_node_transition(entry.id, display_config)
                  batch_buffer.clear()
                  RETURN

              # Display batch summary
              last_entry = batch_buffer[batch_buffer.length - 1]
              phase_name = last_entry.phase OR "Processing"

              IF display_config.batch.show_node_list:
                  node_ids = batch_buffer.map(e => e.id).join(", ")
                  DISPLAY "{phase_name}... [{node_ids}] → {last_entry.routing_target}"
              ELSE IF display_config.batch.show_summary:
                  DISPLAY "{phase_name}... [{batch_buffer.length} nodes] → {last_entry.routing_target}"
              ELSE:
                  DISPLAY "{phase_name}... → {last_entry.routing_target}"

              batch_buffer.clear()

      display_node_execution:
        description: Display a node execution based on verbosity
        effect: |
          FUNCTION display_node_execution(node_id, node, outcome, display_config):
              # Silent mode: no output except prompts and final result
              IF display_config.verbosity == "silent":
                  RETURN

              # Terse mode: handled by batching, individual nodes not shown
              IF display_config.verbosity == "terse":
                  RETURN

              # Normal mode: show transitions
              IF display_config.verbosity == "normal":
                  display_node_transition(node_id, display_config)
                  RETURN

              # Verbose mode: show details
              IF display_config.verbosity == "verbose":
                  display_node_transition(node_id, display_config)
                  IF node.type == "conditional":
                      display_condition_details(node, outcome, display_config)
                  RETURN

              # Debug mode: show everything
              IF display_config.verbosity == "debug":
                  display_node_transition(node_id, display_config)
                  display_node_debug(node_id, node, outcome, display_config)

      display_node_transition:
        description: Display a simple node transition arrow
        effect: |
          FUNCTION display_node_transition(node_id, display_config):
              IF NOT display_config.show.node_transitions:
                  RETURN

              icon = display_config.format.use_icons ? "→ " : ""
              timestamp = display_config.format.timestamp ? "[{now().format('HH:mm:ss.SSS')}] " : ""
              DISPLAY "{timestamp}{icon}{node_id}"

      display_condition_details:
        description: Display condition evaluation details (verbose mode)
        effect: |
          FUNCTION display_condition_details(node, outcome, display_config):
              indent = " ".repeat(display_config.format.indent)

              IF display_config.show.condition_eval:
                  DISPLAY "{indent}Condition: {node.condition.expression OR node.condition.type}"
                  DISPLAY "{indent}Result: {outcome.condition_result}"

              IF display_config.show.branch_result:
                  branch = outcome.condition_result ? "on_true" : "on_false"
                  DISPLAY "{indent}Branch: {branch} → {outcome.next_node}"

      display_node_debug:
        description: Display full node debug information (debug mode)
        effect: |
          FUNCTION display_node_debug(node_id, node, outcome, display_config):
              indent = " ".repeat(display_config.format.indent)
              DISPLAY "[DEBUG] Node: {node_id} (type: {node.type})"
              DISPLAY "[DEBUG] {indent}Outcome: {JSON.stringify(outcome)}"

      infer_phase_name:
        description: Infer a human-readable phase name from state
        effect: |
          FUNCTION infer_phase_name(state):
              # Use state.phase if available
              IF state.phase:
                  RETURN capitalize(state.phase)

              # Otherwise infer from workflow position
              IF state.history.length == 0:
                  RETURN "Initializing"
              ELSE:
                  RETURN "Processing"

      expand_batch_on_error:
        description: Expand batch details when an error occurs
        effect: |
          FUNCTION expand_batch_on_error(batch_buffer, error_node_id, error, display_config):
              IF NOT display_config.batch.expand_on_error:
                  RETURN

              DISPLAY "{batch_buffer[0].phase}... [{batch_buffer.length} nodes] ─ EXPANDED DUE TO ERROR:"
              indent = " ".repeat(display_config.format.indent)

              FOR each entry IN batch_buffer:
                  IF entry.id == error_node_id:
                      DISPLAY "{indent}→ {entry.id}: FAILED"
                      DISPLAY "{indent}  Error: {error.message}"
                  ELSE:
                      DISPLAY "{indent}→ {entry.id}: {entry.outcome.status OR 'passed'}"

    since: "1.0.0"
