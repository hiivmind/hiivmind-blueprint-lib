# Workflow State Management
# Runtime state structure and variable interpolation
#
# This file defines the state model that workflows use during execution.
# It is the authoritative source for state structure and interpolation semantics.

schema_version: "2.0"
category: execution

execution:
  state:
    description:
      brief: Runtime state structure and variable interpolation
      detail: |
        Workflows maintain a runtime state object that tracks execution progress,
        stores computed values, records user responses, and enables rollback via
        checkpoints. State is mutable and shared across the entire workflow execution.

        Variable interpolation uses ${...} syntax to reference state values within
        workflow YAML. This enables dynamic behavior while maintaining declarative structure.
      notes:
        - State is initialized from workflow.initial_state
        - State persists across conversation turns
        - Checkpoints enable rollback on failure
        - Variable interpolation supports nested paths

    structure:
      description: |
        Complete runtime state structure. Fields are categorized by purpose.
      example: |
        state:
          # Identity (from workflow)
          workflow_name: "add-source"
          workflow_version: "1.0.0"

          # Position (execution tracking)
          current_node: "ask_source_type"
          previous_node: "check_url_provided"

          # Runtime detection
          interface: "claude_code"  # or "claude_ai"

          # Logging (resolved from 4-tier hierarchy)
          logging:
            enabled: true
            level: "info"
            auto:
              init: true
              finalize: true
              write: true
              node_tracking: true

          # Log session (created by init_log)
          log:
            workflow: "add-source"
            level: "info"
            entries: []
            started_at: "2026-01-28T10:30:00Z"

          # Execution history
          history:
            - node: "locate_corpus"
              outcome: { success: true }
              timestamp: "2026-01-27T10:30:00Z"
            - node: "check_url_provided"
              outcome: { branch: "false" }
              timestamp: "2026-01-27T10:30:01Z"

          # User interaction results
          user_responses:
            ask_source_type:
              handler_id: "git"
              raw: { selected: "Git repository" }

          # Computed values from consequences
          computed:
            config:
              schema_version: 2
              corpus: { name: "polars" }
              sources: []
            source_id: "polars"
            repo_url: "https://github.com/pola-rs/polars"

          # Boolean routing flags
          flags:
            config_found: true
            manifest_detected: false
            is_first_source: true

          # Rollback snapshots
          checkpoints:
            before_clone:
              current_node: "execute_clone"
              flags: { ... }
              computed: { ... }

          # Custom fields from initial_state
          phase: "setup"
          source_type: "git"

      fields:
        identity:
          - name: workflow_name
            type: string
            description: Name from workflow.yaml
            source: workflow.name
          - name: workflow_version
            type: string
            description: Version from workflow.yaml
            source: workflow.version

        position:
          - name: current_node
            type: string
            description: Node currently being executed
            source: workflow.start_node (initial)
          - name: previous_node
            type: string
            description: Last executed node
            source: Updated after each node

        runtime:
          - name: interface
            type: string
            enum: ["claude_code", "claude_ai"]
            description: Detected interface environment
            source: detect_interface() at initialization

        logging:
          - name: logging
            type: object
            description: Resolved logging configuration (4-tier hierarchy)
            source: load_logging_config()
          - name: log
            type: object
            description: Log session, created by init_log consequence
            source: null until init_log executes

        history:
          - name: history
            type: array
            items:
              type: object
              properties:
                node: { type: string }
                outcome: { type: object }
                timestamp: { type: string, format: datetime }
            description: Array of executed node records

        user_responses:
          - name: user_responses
            type: object
            description: Results from user_prompt nodes, keyed by node name
            additionalProperties:
              type: object
              properties:
                handler_id: { type: string }
                raw: { type: object }

        computed:
          - name: computed
            type: object
            description: Results from action consequences (store_as targets)
            additionalProperties: true

        flags:
          - name: flags
            type: object
            description: Boolean values for routing decisions
            additionalProperties:
              type: boolean

        checkpoints:
          - name: checkpoints
            type: object
            description: Named state snapshots for rollback
            additionalProperties:
              type: object

    interpolation:
      description: |
        Variable interpolation replaces ${...} patterns with values from state.
        Supports nested paths using dot notation and array access.
      patterns:
        - pattern: "${field}"
          description: Top-level state field
          example: "${source_type}"
        - pattern: "${computed.field}"
          description: Computed value
          example: "${computed.repo_url}"
        - pattern: "${flags.flag}"
          description: Boolean flag
          example: "${flags.config_found}"
        - pattern: "${user_responses.node.field}"
          description: User response field
          example: "${user_responses.ask_type.handler_id}"
        - pattern: "${computed.nested.path}"
          description: Nested computed value
          example: "${computed.config.corpus.name}"
        - pattern: "${computed.array[0]}"
          description: Array index access
          example: "${computed.sources[0].id}"
        - pattern: "${history[-1].node}"
          description: Negative index (last element)
          example: "${history[-1].outcome}"

      effect: |
        FUNCTION interpolate(template, state):
            # Replace ${...} patterns with values from state
            FOR each match IN template.match_all(/\$\{([^}]+)\}/):
                path = match.group(1)
                value = resolve_path(state, path)
                IF value == null:
                    THROW "Unresolved variable: ${path}"
                template = template.replace(match.full, to_string(value))
            RETURN template

        FUNCTION resolve_path(state, path):
            # Resolution order:
            # 1. computed.{name}
            # 2. flags.{name}
            # 3. user_responses.{name}
            # 4. top-level state.{field}

            IF path.startsWith("computed."):
                RETURN get_nested(state.computed, path.substring(9))
            IF path.startsWith("flags."):
                RETURN state.flags[path.substring(6)]
            IF path.startsWith("user_responses."):
                RETURN get_nested(state.user_responses, path.substring(15))
            RETURN get_nested(state, path)

        FUNCTION get_nested(obj, path):
            parts = parse_path(path)  # Handles dots and brackets
            current = obj
            FOR each part IN parts:
                IF current == null:
                    RETURN null
                IF part.is_array_index:
                    index = part.index
                    IF index < 0:
                        index = current.length + index
                    current = current[index]
                ELSE:
                    current = current[part.key]
            RETURN current

    dynamic_routing:
      description: |
        Routing targets (on_success, on_failure, branches.*, next_node) support
        variable interpolation, enabling dynamic routing based on computed state.

        Static targets are validated at load time; dynamic targets containing ${...}
        are validated at runtime when the value is resolved.
      effect: |
        FUNCTION resolve_routing_target(target, state):
            # If target contains ${...}, interpolate it
            IF target.includes("${"):
                resolved = interpolate(target, state)
                IF resolved == null OR resolved == "":
                    THROW "Dynamic routing target resolved to null/empty: {target}"
                RETURN resolved
            ELSE:
                # Static target - return as-is
                RETURN target

      patterns:
        - name: Dynamic action routing
          description: Route based on computed action result
          example: |
            execute_matched_intent:
              type: action
              actions:
                - type: dynamic_route
                  action: "${computed.intent_matches.winner.action}"
              on_success: "${computed.dynamic_target}"  # Interpolated!
              on_failure: show_main_menu

        - name: Conditional dynamic branch
          description: Route based on computed destination
          example: |
            route_by_type:
              type: conditional
              condition:
                type: state_not_null
                field: computed.next_destination
              branches:
                on_true: "${computed.next_destination}"  # Interpolated!
                on_false: default_handler

    checkpoint_operations:
      description: |
        Checkpoints enable state snapshots for rollback on failure.
        Useful for operations that may fail and leave partial state.
      effect: |
        FUNCTION create_checkpoint(name, state):
            # Create deep copy of current state
            state.checkpoints[name] = deep_copy(state)

        FUNCTION rollback_checkpoint(name, state):
            IF name NOT IN state.checkpoints:
                THROW "Checkpoint not found: {name}"

            checkpoint = state.checkpoints[name]

            # Restore all state except checkpoints themselves
            state.current_node = checkpoint.current_node
            state.previous_node = checkpoint.previous_node
            state.computed = checkpoint.computed
            state.flags = checkpoint.flags
            state.user_responses = checkpoint.user_responses
            state.history = checkpoint.history
            # ... other fields

      usage:
        - title: Creating a checkpoint before risky operation
          yaml: |
            prepare_clone:
              type: action
              actions:
                - type: create_checkpoint
                  name: "before_clone"
              on_success: execute_clone
              on_failure: error_checkpoint

        - title: Rollback on failure
          yaml: |
            execute_clone:
              type: action
              actions:
                - type: clone_repo
                  url: "${computed.repo_url}"
                  path: ".source/${computed.source_id}"
              on_success: verify_clone
              on_failure: handle_clone_failure

            handle_clone_failure:
              type: action
              actions:
                - type: rollback_checkpoint
                  name: "before_clone"
                - type: display_message
                  message: "Clone failed, state restored"
              on_success: ask_retry
              on_failure: error_rollback

    state_access_patterns:
      description: Common patterns for reading and writing state

      reading:
        - pattern: "Dot notation for nested fields"
          example: "computed.config.corpus.name"
        - pattern: "Array access with brackets"
          example: "computed.config.sources[0].id"
        - pattern: "Negative index for last element"
          example: "history[-1].node"

      writing:
        - pattern: "set_state consequence"
          example: |
            - type: set_state
              field: source_type
              value: git
        - pattern: "set_flag consequence"
          example: |
            - type: set_flag
              flag: config_found
              value: true
        - pattern: "store_as on consequence"
          example: |
            - type: read_file
              path: "config.yaml"
              store_as: config
        - pattern: "evaluate with set_flag"
          example: |
            - type: evaluate
              expression: "len(computed.sources) == 0"
              set_flag: is_first_source

    state_lifecycle:
      description: State lifecycle throughout workflow execution

      phases:
        - phase: Initialization
          steps:
            - Load workflow.yaml
            - Create empty state structure
            - Copy workflow.initial_state fields
            - Copy workflow.initial_state.flags
            - Set current_node = workflow.start_node
            - Detect interface

        - phase: During Execution
          steps:
            - Execute node (may modify computed, flags, user_responses)
            - Append to history
            - Update previous_node, current_node

        - phase: On Error
          steps:
            - State may be partially modified
            - If checkpoint exists, can rollback
            - Route to on_failure node

        - phase: On Completion
          steps:
            - State is final
            - History contains full execution path
            - Summary can reference final computed values

    state_persistence:
      description: |
        State exists in conversation context and persists across turns.
        This enables multi-turn workflows with user interaction.
      example: |
        Turn 1:
          User invokes skill
          → Initialize state
          → Execute nodes until user_prompt
          → Present AskUserQuestion
          → State persists...

        Turn 2:
          User responds
          → Resume from user_prompt node
          → Store response in state.user_responses
          → Continue execution
          → State persists...

        Turn N:
          Workflow reaches ending
          → Display result
          → State complete

    since: "1.0.0"
