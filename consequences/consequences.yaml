# Core Control Flow Consequences
# Checkpoints, rollback, and agent spawning

schema_version: "1.0"
category: core/control
description: Control flow, checkpoints, and agent spawning operations

consequences:
  # ==========================================================================
  # category: core/control
  # ==========================================================================

  # --------------------------------------------------------------------------
  # create_checkpoint
  # --------------------------------------------------------------------------
  create_checkpoint:
    category: core/control
    description:
      brief: Save state snapshot for potential rollback
      detail: |
        Creates a deep copy of the entire state at a named checkpoint.
        Used before risky operations to enable state restoration if
        something fails.
      notes:
        - Creates deep copy of entire state
        - Multiple checkpoints can coexist
        - Checkpoint names should be descriptive
        - Does NOT checkpoint file system - only state

    parameters:
      - name: name
        type: string
        required: true
        description: Checkpoint identifier
        pattern: "^[a-zA-Z_][a-zA-Z0-9_-]*$"
        interpolatable: false

    payload:
      kind: state_mutation
      tool: null
      effect: |
        state.checkpoints = state.checkpoints ?? {}
        state.checkpoints[name] = deep_copy(state)
      state_writes:
        - "checkpoints.${name}"
      state_reads: []

    since: "1.0.0"

  # --------------------------------------------------------------------------
  # rollback_checkpoint
  # --------------------------------------------------------------------------
  rollback_checkpoint:
    category: core/control
    description:
      brief: Restore state from checkpoint
      detail: |
        Restores the entire state from a previously created checkpoint.
        Used in error handling to reset state after a failed operation.
      notes:
        - Restores complete state snapshot
        - Does NOT rollback file system changes
        - Fails if checkpoint doesn't exist

    parameters:
      - name: name
        type: string
        required: true
        description: Checkpoint to restore
        pattern: "^[a-zA-Z_][a-zA-Z0-9_-]*$"
        interpolatable: false

    payload:
      kind: state_mutation
      tool: null
      effect: |
        if not state.checkpoints or not state.checkpoints[name]:
          throw Error("Checkpoint not found: " + name)
        state = state.checkpoints[name]
      state_writes:
        - "*"
      state_reads:
        - "checkpoints.${name}"

    since: "1.0.0"

  # --------------------------------------------------------------------------
  # spawn_agent
  # --------------------------------------------------------------------------
  spawn_agent:
    category: core/control
    description:
      brief: Launch a Task agent for parallel work
      detail: |
        Spawns a Claude Task agent to perform work in parallel. Can run
        synchronously or in the background. Results are stored in state
        when the agent completes.
      notes:
        - Uses Claude's Task tool to spawn subagent
        - Background agents run concurrently
        - Results stored when agent completes
        - Multiple spawn_agent calls can run in parallel

    parameters:
      - name: subagent_type
        type: string
        required: true
        description: Agent type from available Task agents
        interpolatable: false

      - name: prompt
        type: string
        required: true
        description: Task prompt for the agent
        interpolatable: true

      - name: store_as
        type: string
        required: true
        description: State field for agent result
        pattern: "^[a-zA-Z_][a-zA-Z0-9_.\\[\\]]*$"
        interpolatable: true

      - name: run_in_background
        type: boolean
        required: false
        default: false
        description: Run agent asynchronously
        interpolatable: false

    payload:
      kind: tool_call
      tool: Task
      effect: |
        agent_result = Task(
          subagent_type: subagent_type,
          prompt: interpolate(prompt),
          run_in_background: run_in_background ?? false
        )
        set_state_value(interpolate(store_as), agent_result)
      state_writes:
        - "${store_as}"
      state_reads: []

    since: "1.0.0"

  # --------------------------------------------------------------------------
  # invoke_skill
  # --------------------------------------------------------------------------
  invoke_skill:
    description:
      brief: Invoke another skill and wait for completion
      detail: |
        Delegates to another skill using Claude's Skill tool. The invoked
        skill takes over the conversation. Typically used as the last
        action before reaching a success ending.
      notes:
        - Uses Claude's Skill tool to invoke
        - The invoked skill takes over the conversation
        - Control returns to workflow when skill completes
        - Typically the last action before ending

    parameters:
      - name: skill
        type: string
        required: true
        description: Skill name (without plugin prefix)
        interpolatable: true

      - name: args
        type: string
        required: false
        description: Arguments to pass to the skill
        default: ""
        interpolatable: true

    payload:
      kind: tool_call
      tool: Skill
      effect: |
        Skill(
          skill: interpolate(skill),
          args: interpolate(args) ?? ""
        )
      state_writes: []
      state_reads: []

    since: "1.0.0"

  # --------------------------------------------------------------------------
  # inline
  # --------------------------------------------------------------------------
  inline:
    category: core/control
    description:
      brief: Execute embedded pseudocode for non-reusable logic
      detail: |
        Allows embedding custom logic directly in a workflow when the operation
        is too specific to warrant a reusable consequence type. The pseudocode
        is executed by the workflow engine with access to state.

        Use sparingly - prefer reusable consequence types when the logic might
        be needed elsewhere.
      notes:
        - Pseudocode has full access to state
        - Can read and write state fields
        - Results can be stored via store_as
        - Use for workflow-specific transformations
        - Consider extracting to a reusable type if used more than once

    parameters:
      - name: description
        type: string
        required: true
        description: Human-readable description of what this code does
        interpolatable: false

      - name: pseudocode
        type: string
        required: true
        description: |
          The logic to execute. Has access to 'state' object and can use
          standard operations like get_state_value(), set_state_value().
        interpolatable: false

      - name: store_as
        type: string
        required: false
        description: State field to store the result in (if pseudocode returns a value)
        pattern: "^[a-zA-Z_][a-zA-Z0-9_.\\[\\]]*$"
        interpolatable: true

      - name: state_reads
        type: array
        required: false
        description: Document which state fields this code reads
        items: { type: string }

      - name: state_writes
        type: array
        required: false
        description: Document which state fields this code writes
        items: { type: string }

    payload:
      kind: computation
      tool: null
      effect: |
        # Execute the embedded pseudocode
        result = execute_pseudocode(pseudocode, state)

        # Store result if store_as is specified
        if store_as:
          set_state_value(interpolate(store_as), result)
      state_writes:
        - "${store_as}"
      state_reads: []

    since: "2.0.0"

  # ==========================================================================
  # category: core/evaluation
  # ==========================================================================

  # --------------------------------------------------------------------------
  # evaluate
  # --------------------------------------------------------------------------
  evaluate:
    category: core/evaluation
    description:
      brief: Evaluate expression and set flag based on result
      detail: |
        Evaluates a boolean expression and stores the result in a flag.
        Used for deriving boolean conditions from state that can then be
        used in conditional node branching.
      notes:
        - Expression must evaluate to boolean
        - Same syntax as evaluate_expression precondition
        - Supports comparison, logical operators, and functions

    parameters:
      - name: expression
        type: string
        required: true
        description: Boolean expression to evaluate
        interpolatable: false

      - name: set_flag
        type: string
        required: true
        description: Flag name to store the result
        pattern: "^[a-zA-Z_][a-zA-Z0-9_]*$"
        interpolatable: false

    payload:
      kind: computation
      tool: null
      effect: |
        result = eval_expression(expression, state)
        state.flags[set_flag] = result
      state_writes:
        - "flags.${set_flag}"
      state_reads: []

    since: "1.0.0"

  # --------------------------------------------------------------------------
  # compute
  # --------------------------------------------------------------------------
  compute:
    category: core/evaluation
    description:
      brief: Run expression and store result
      detail: |
        Evaluates an expression and stores the computed result in a state
        field. Unlike evaluate, this can return any type (string, number,
        array, object) not just booleans.
      notes:
        - Expression can return any type
        - Supports string operations, array methods, arithmetic
        - Result stored in specified state field

    parameters:
      - name: expression
        type: string
        required: true
        description: Expression to evaluate
        interpolatable: false

      - name: store_as
        type: string
        required: true
        description: State field to store the result
        pattern: "^[a-zA-Z_][a-zA-Z0-9_.\\[\\]]*$"
        interpolatable: false

    payload:
      kind: computation
      tool: null
      effect: |
        result = eval_expression(expression, state)
        set_state_value(store_as, result)
      state_writes:
        - "${store_as}"
      state_reads: []

    since: "1.0.0"

  # ==========================================================================
  # category: core/interaction
  # ==========================================================================

  # --------------------------------------------------------------------------
  # display_message
  # --------------------------------------------------------------------------
  display_message:
    category: core/interaction
    description:
      brief: Show message to user
      detail: |
        Displays an informational message to the user. Supports markdown
        formatting and ${} interpolation from state. Used for progress
        updates, summaries, and notifications.
      notes:
        - Supports multiline messages using YAML | syntax
        - All ${} placeholders interpolated from state
        - Markdown formatting is preserved
        - No state changes occur

    parameters:
      - name: message
        type: string
        required: true
        description: Message text with ${} interpolation
        interpolatable: true

    payload:
      kind: side_effect
      tool: null
      effect: |
        interpolated = interpolate(message, state)
        display_to_user(interpolated)
      state_writes: []
      state_reads: []

    since: "1.0.0"

  # --------------------------------------------------------------------------
  # display_table
  # --------------------------------------------------------------------------
  display_table:
    category: core/interaction
    description:
      brief: Show tabular data to user
      detail: |
        Displays data in a formatted table. Headers define columns, and
        rows can be provided inline or referenced from state. Renders as
        a markdown table.
      notes:
        - Rows can be state reference (${computed.table_data}) or inline array
        - Each row should be an array matching header count
        - Renders as markdown table

    parameters:
      - name: title
        type: string
        required: false
        description: Table title (displayed above table)
        interpolatable: true

      - name: headers
        type: array
        required: true
        description: Column header labels
        interpolatable: false

      - name: rows
        type: any
        required: true
        description: Row data - state reference or inline array
        interpolatable: true

    payload:
      kind: side_effect
      tool: null
      effect: |
        resolved_rows = interpolate(rows, state)
        table = format_markdown_table(headers, resolved_rows)
        if title:
          display_to_user("### " + interpolate(title) + "\n\n" + table)
        else:
          display_to_user(table)
      state_writes: []
      state_reads: []

    since: "1.0.0"

  # ==========================================================================
  # category: core/logging
  # ==========================================================================

  # --------------------------------------------------------------------------
  # init_log
  # --------------------------------------------------------------------------
  init_log:
    category: core/logging
    description:
      brief: Initialize log structure with workflow metadata
      detail: |
        Initializes the log structure at workflow start. Sets up metadata,
        session tracking, and prepares arrays for events, warnings, and
        errors. Should be called once at the beginning of workflow execution.
      notes:
        - Call once at workflow start
        - Session context captured from environment variables
        - Creates state.log structure
        - Sets flags.log_initialized to true

    parameters:
      - name: workflow_name
        type: string
        required: true
        description: Workflow identifier
        interpolatable: true

      - name: workflow_version
        type: string
        required: false
        default: "1.0"
        description: Workflow version
        interpolatable: true

      - name: skill_name
        type: string
        required: false
        description: Name of invoking skill
        interpolatable: true

      - name: plugin_name
        type: string
        required: false
        description: Name of parent plugin
        interpolatable: true

      - name: execution_path
        type: string
        required: false
        description: Skill/command path (auto-detected if not provided)
        interpolatable: true

    payload:
      kind: composite
      tool: null
      effect: |
        # Session state management
        session_state_path = ".logs/.session-state.yaml"
        session_state = read_yaml(session_state_path) ?? { current_session: null }

        current_id = env.BLUEPRINT_SESSION_ID
        if session_state.current_session?.id != current_id:
          session_state.current_session = {
            id: current_id,
            invocation_count: 0,
            invocations: []
          }

        session_state.current_session.invocation_count += 1
        invocation_index = session_state.current_session.invocation_count

        computed_log_path = format_log_path(skill_name, now_iso8601())

        session_state.current_session.invocations.push({
          index: invocation_index,
          skill: skill_name,
          log_path: computed_log_path,
          timestamp: now_iso8601()
        })

        mkdir -p dirname(session_state_path)
        write_yaml(session_state_path, session_state)

        state.log = {
          metadata: {
            workflow_name: workflow_name,
            workflow_version: workflow_version ?? "1.0",
            skill_name: skill_name ?? null,
            plugin_name: plugin_name ?? null,
            execution_path: execution_path ?? cwd,
            session: {
              id: env.BLUEPRINT_SESSION_ID ?? null,
              transcript_path: env.BLUEPRINT_TRANSCRIPT_PATH ?? null,
              invocation_index: invocation_index,
              snapshot_points: []
            }
          },
          parameters: extract_flags(initial_state.flags),
          execution: {
            start_time: now_iso8601(),
            end_time: null,
            duration_seconds: null,
            outcome: null,
            ending_node: null
          },
          node_history: [],
          events: [],
          warnings: [],
          errors: [],
          summary: null
        }
        state.flags.log_initialized = true
        state.computed.expected_log_path = computed_log_path
      state_writes:
        - "log"
        - "flags.log_initialized"
        - "computed.expected_log_path"
      state_reads: []

    since: "1.0.0"

  # --------------------------------------------------------------------------
  # log_node
  # --------------------------------------------------------------------------
  log_node:
    category: core/logging
    description:
      brief: Record node execution in history
      detail: |
        Records a node execution event in the log history. Captures the
        node ID, outcome, timestamp, and optional details. Subject to
        logging level configuration.
      notes:
        - Requires logging level >= info
        - Details can include any key-value pairs
        - Timestamp auto-generated

    parameters:
      - name: node
        type: string
        required: true
        description: Node identifier
        interpolatable: true

      - name: outcome
        type: string
        required: true
        description: "Execution result: success, skipped, error, blocked"
        enum:
          - success
          - skipped
          - error
          - blocked
        interpolatable: true

      - name: details
        type: object
        required: false
        description: Arbitrary key-value pairs for context
        interpolatable: true

    payload:
      kind: state_mutation
      tool: null
      effect: |
        if logging.level >= "info":
          state.log.node_history.push({
            node: node,
            timestamp: now_iso8601(),
            outcome: outcome,
            details: details ?? {}
          })
      state_writes:
        - "log.node_history"
      state_reads: []

    since: "1.0.0"

  # --------------------------------------------------------------------------
  # log_event
  # --------------------------------------------------------------------------
  log_event:
    category: core/logging
    description:
      brief: Log domain-specific event
      detail: |
        Logs a structured domain-specific event. Primary mechanism for
        plugins to add custom logging without defining new consequences.
        Events are stored with type, timestamp, and arbitrary data.
      notes:
        - Level configurable per-event via level parameter
        - Default level is "info"
        - Data can be any structured object

    parameters:
      - name: event_type
        type: string
        required: true
        description: Domain-specific event identifier
        interpolatable: true

      - name: data
        type: object
        required: false
        description: Event payload (arbitrary structure)
        interpolatable: true

      - name: level
        type: string
        required: false
        default: "info"
        description: Minimum level to record
        enum:
          - debug
          - info
          - warn
          - error
        interpolatable: false

    payload:
      kind: state_mutation
      tool: null
      effect: |
        effective_level = level ?? "info"
        if logging.level >= effective_level:
          state.log.events.push({
            type: event_type,
            timestamp: now_iso8601(),
            data: data ?? {}
          })
      state_writes:
        - "log.events"
      state_reads: []

    since: "1.0.0"

  # --------------------------------------------------------------------------
  # log_warning
  # --------------------------------------------------------------------------
  log_warning:
    category: core/logging
    description:
      brief: Add warning message to log
      detail: |
        Adds a warning message to the log. Warnings indicate potential
        issues that don't prevent execution but should be noted.
      notes:
        - Requires logging level >= warn
        - Node auto-detected from current_node if not specified
        - Context provides debugging information

    parameters:
      - name: message
        type: string
        required: true
        description: Warning message
        interpolatable: true

      - name: context
        type: object
        required: false
        description: Additional context for debugging
        interpolatable: true

      - name: node
        type: string
        required: false
        description: Node that generated warning (auto-detected)
        interpolatable: true

    payload:
      kind: state_mutation
      tool: null
      effect: |
        if logging.level >= "warn":
          state.log.warnings.push({
            message: message,
            timestamp: now_iso8601(),
            node: node ?? current_node.id,
            context: context ?? {}
          })
      state_writes:
        - "log.warnings"
      state_reads: []

    since: "1.0.0"

  # --------------------------------------------------------------------------
  # log_error
  # --------------------------------------------------------------------------
  log_error:
    category: core/logging
    description:
      brief: Add error with context to log
      detail: |
        Adds an error to the log with detailed context. Errors indicate
        failures that may affect the workflow outcome. Includes error
        type classification and recoverability flag.
      notes:
        - Requires logging level >= error
        - error_type helps classify the failure
        - recoverable indicates if workflow continued

    parameters:
      - name: message
        type: string
        required: true
        description: Error message
        interpolatable: true

      - name: error_type
        type: string
        required: false
        description: Error classification
        interpolatable: true

      - name: context
        type: object
        required: false
        description: Error details for debugging
        interpolatable: true

      - name: node
        type: string
        required: false
        description: Node that generated error (auto-detected)
        interpolatable: true

      - name: recoverable
        type: boolean
        required: false
        default: false
        description: Whether workflow continued after this error
        interpolatable: false

    payload:
      kind: state_mutation
      tool: null
      effect: |
        if logging.level >= "error":
          state.log.errors.push({
            message: message,
            error_type: error_type ?? "unknown",
            timestamp: now_iso8601(),
            node: node ?? current_node.id,
            context: context ?? {},
            recoverable: recoverable ?? false
          })
      state_writes:
        - "log.errors"
      state_reads: []

    since: "1.0.0"

  # --------------------------------------------------------------------------
  # log_session_snapshot
  # --------------------------------------------------------------------------
  log_session_snapshot:
    category: core/logging
    description:
      brief: Record mid-session checkpoint
      detail: |
        Records a snapshot at a critical decision point. Useful for
        long-running workflows where you want checkpoints at significant
        moments. Can optionally write an intermediate log file.
      notes:
        - Always executes (level-independent)
        - write_intermediate creates a snapshot file
        - Useful before destructive operations

    parameters:
      - name: description
        type: string
        required: true
        description: What decision or event occurred
        interpolatable: true

      - name: write_intermediate
        type: boolean
        required: false
        default: false
        description: Write log to file at this point
        interpolatable: false

      - name: node
        type: string
        required: false
        description: Node identifier (auto-detected)
        interpolatable: true

    payload:
      kind: composite
      tool: null
      effect: |
        snapshot = {
          timestamp: now_iso8601(),
          node: node ?? current_node.id,
          description: description,
          log_path: null
        }

        if write_intermediate:
          snapshot_count = len(state.log.metadata.session.snapshot_points) + 1
          snapshot_path = format_snapshot_path(
            state.log.metadata.skill_name,
            now_iso8601(),
            snapshot_count
          )

          log_content = format_log(state.log, "yaml")
          mkdir -p dirname(snapshot_path)
          write_file(snapshot_path, log_content)

          snapshot.log_path = snapshot_path

        state.log.metadata.session.snapshot_points.push(snapshot)
      state_writes:
        - "log.metadata.session.snapshot_points"
      state_reads: []

    since: "1.0.0"

  # --------------------------------------------------------------------------
  # finalize_log
  # --------------------------------------------------------------------------
  finalize_log:
    category: core/logging
    description:
      brief: Complete log with timing and outcome
      detail: |
        Completes the log with execution timing, outcome, and summary.
        Should be called at workflow end (success, error, or cancel).
        Sets flags.log_finalized to true.
      notes:
        - Call at workflow end (any ending node)
        - Calculates duration from start_time
        - Auto-generates summary if not provided

    parameters:
      - name: outcome
        type: string
        required: true
        description: "Final result: success, partial, error, cancelled"
        enum:
          - success
          - partial
          - error
          - cancelled
        interpolatable: true

      - name: ending_node
        type: string
        required: false
        description: Last executed node (auto-detected)
        interpolatable: true

      - name: summary
        type: string
        required: false
        description: Human-readable execution summary
        interpolatable: true

    payload:
      kind: state_mutation
      tool: null
      effect: |
        state.log.execution.end_time = now_iso8601()
        state.log.execution.duration_seconds = time_diff_seconds(
          state.log.execution.start_time,
          state.log.execution.end_time
        )
        state.log.execution.outcome = outcome
        state.log.execution.ending_node = ending_node ?? current_node.id
        state.log.summary = summary ?? auto_generate_summary()
        state.flags.log_finalized = true
      state_writes:
        - "log.execution"
        - "log.summary"
        - "flags.log_finalized"
      state_reads:
        - "log.execution.start_time"

    since: "1.0.0"

  # --------------------------------------------------------------------------
  # write_log
  # --------------------------------------------------------------------------
  write_log:
    category: core/logging
    description:
      brief: Write log to file
      detail: |
        Writes the finalized log to a file. Supports multiple output
        formats (YAML, JSON, Markdown). Path supports interpolation and
        has sensible defaults.
      notes:
        - Default path pattern based on skill name and timestamp
        - Creates parent directories if needed
        - Stores actual path in computed.log_path

    parameters:
      - name: format
        type: string
        required: false
        default: yaml
        description: "Output format: yaml, json, markdown"
        enum:
          - yaml
          - json
          - markdown
        interpolatable: false

      - name: path
        type: string
        required: false
        description: Output path (default based on skill name and timestamp)
        interpolatable: true

      - name: include_node_history
        type: boolean
        required: false
        default: true
        description: Include node_history array
        interpolatable: false

      - name: include_events
        type: boolean
        required: false
        default: true
        description: Include events array
        interpolatable: false

    payload:
      kind: side_effect
      tool: null
      effect: |
        log_content = format_log(state.log, format, {
          include_node_history: include_node_history ?? true,
          include_events: include_events ?? true
        })
        effective_path = path ?? format_default_log_path(
          state.log.metadata.skill_name,
          state.log.execution.start_time,
          format
        )
        mkdir -p dirname(effective_path)
        write_file(effective_path, log_content)
        state.computed.log_path = effective_path
      state_writes:
        - "computed.log_path"
      state_reads:
        - "log"

    since: "1.0.0"

  # --------------------------------------------------------------------------
  # apply_log_retention
  # --------------------------------------------------------------------------
  apply_log_retention:
    category: core/logging
    description:
      brief: Clean up old log files
      detail: |
        Cleans up old log files according to retention policy. Supports
        count-based (keep N newest) or time-based (keep files newer than
        N days) retention strategies.
      notes:
        - "strategy: none - no cleanup"
        - "strategy: count - keep N newest files"
        - "strategy: days - keep files newer than N days"
        - Stores count of deleted files in computed.logs_deleted

    parameters:
      - name: path
        type: string
        required: true
        description: Directory containing logs
        interpolatable: true

      - name: strategy
        type: string
        required: true
        description: "Retention strategy: none, days, count"
        enum:
          - none
          - days
          - count
        interpolatable: false

      - name: days
        type: number
        required: false
        description: Max age in days (required if strategy=days)
        interpolatable: false

      - name: count
        type: number
        required: false
        description: Max files to keep (required if strategy=count)
        interpolatable: false

      - name: pattern
        type: string
        required: false
        default: "*.yaml"
        description: Glob pattern for log files
        interpolatable: false

    payload:
      kind: side_effect
      tool: null
      effect: |
        if strategy == "none":
          return

        files = glob(path, pattern ?? "*.yaml").sort_by_mtime()

        if strategy == "count":
          to_delete = files[count:]
        elif strategy == "days":
          cutoff = now() - days * 86400
          to_delete = files.filter(f => mtime(f) < cutoff)

        for file in to_delete:
          delete_file(file)

        state.computed.logs_deleted = len(to_delete)
      state_writes:
        - "computed.logs_deleted"
      state_reads: []

    since: "1.0.0"

  # --------------------------------------------------------------------------
  # output_ci_summary
  # --------------------------------------------------------------------------
  output_ci_summary:
    category: core/logging
    description:
      brief: Format output for CI environments
      detail: |
        Formats and outputs log summary for CI environments like GitHub
        Actions. Can emit annotations for errors and warnings. Writes to
        GITHUB_STEP_SUMMARY when in GitHub Actions environment.
      notes:
        - "github format: writes to GITHUB_STEP_SUMMARY"
        - "plain format: prints to stdout"
        - "json format: prints JSON to stdout"
        - Annotations emit ::error and ::warning prefixes

    parameters:
      - name: format
        type: string
        required: false
        description: "CI format: github, plain, json, none"
        enum:
          - github
          - plain
          - json
          - none
        interpolatable: false

      - name: annotations
        type: boolean
        required: false
        default: true
        description: Emit annotations for errors/warnings
        interpolatable: false

      - name: output_file
        type: string
        required: false
        description: Override GITHUB_STEP_SUMMARY path
        interpolatable: true

    payload:
      kind: side_effect
      tool: null
      effect: |
        if format == "none":
          return

        if format == "github":
          summary_path = output_file ?? env.GITHUB_STEP_SUMMARY
          append_file(summary_path, format_github_summary(state.log))

          if annotations:
            for error in state.log.errors:
              echo "::error file={error.context.file},line={error.context.line}::{error.message}"
            for warning in state.log.warnings:
              echo "::warning::{warning.message}"

        elif format == "plain":
          print(format_plain_summary(state.log))

        elif format == "json":
          print(json_dumps(state.log))
      state_writes: []
      state_reads:
        - "log"

    since: "1.0.0"

  # ==========================================================================
  # category: core/state
  # ==========================================================================

  # --------------------------------------------------------------------------
  # set_flag
  # --------------------------------------------------------------------------
  set_flag:
    category: core/state
    description:
      brief: Set a boolean flag
      detail: |
        Sets a boolean flag in the state.flags namespace. Flags are used for
        simple true/false state that can be checked in conditional nodes.
      notes:
        - Flags are stored in state.flags namespace
        - Use for binary conditions checked in workflow branching

    parameters:
      - name: flag
        type: string
        required: true
        description: Flag name (alphanumeric and underscores)
        pattern: "^[a-zA-Z_][a-zA-Z0-9_]*$"
        interpolatable: false

      - name: value
        type: boolean
        required: true
        description: Boolean value to set
        interpolatable: false

    payload:
      kind: state_mutation
      tool: null
      effect: |
        state.flags[flag] = value
      state_writes:
        - "flags.${flag}"
      state_reads: []

    since: "1.0.0"

  # --------------------------------------------------------------------------
  # set_state
  # --------------------------------------------------------------------------
  set_state:
    category: core/state
    description:
      brief: Set any state field
      detail: |
        Sets a state field to a specified value. Supports dot notation for
        nested field access and ${} interpolation in values.
      notes:
        - Use computed.* prefix for derived values
        - Supports nested paths via dot notation
        - Value can include ${field} interpolation

    parameters:
      - name: field
        type: string
        required: true
        description: State field path (dot notation for nested)
        pattern: "^[a-zA-Z_][a-zA-Z0-9_.\\[\\]]*$"
        interpolatable: false

      - name: value
        type: any
        required: true
        description: Value to set (supports ${} interpolation)
        interpolatable: true

    payload:
      kind: state_mutation
      tool: null
      effect: |
        path_parts = split(field, ".")
        target = state
        for part in path_parts[:-1]:
          target = target[part]
        target[path_parts[-1]] = interpolate(value)
      state_writes:
        - "${field}"
      state_reads: []

    since: "1.0.0"

  # --------------------------------------------------------------------------
  # append_state
  # --------------------------------------------------------------------------
  append_state:
    category: core/state
    description:
      brief: Append value to array field
      detail: |
        Appends a value to an array field in state. Creates the array if it
        doesn't exist. Useful for building up lists during workflow execution.
      notes:
        - Array is created if field doesn't exist
        - Value can be any type (object, string, etc.)

    parameters:
      - name: field
        type: string
        required: true
        description: Array field path
        pattern: "^[a-zA-Z_][a-zA-Z0-9_.\\[\\]]*$"
        interpolatable: false

      - name: value
        type: any
        required: true
        description: Value to append (supports ${} interpolation)
        interpolatable: true

    payload:
      kind: state_mutation
      tool: null
      effect: |
        array = get_state_value(field) ?? []
        array.push(interpolate(value))
        set_state_value(field, array)
      state_writes:
        - "${field}"
      state_reads:
        - "${field}"

    since: "1.0.0"

  # --------------------------------------------------------------------------
  # clear_state
  # --------------------------------------------------------------------------
  clear_state:
    category: core/state
    description:
      brief: Reset field to null
      detail: |
        Resets a state field to null/empty. Useful for clearing computed
        values between iterations or resetting state for retry.
      notes:
        - Sets field to null (not undefined)
        - Does not delete the field, just clears its value

    parameters:
      - name: field
        type: string
        required: true
        description: Field to clear
        pattern: "^[a-zA-Z_][a-zA-Z0-9_.\\[\\]]*$"
        interpolatable: false

    payload:
      kind: state_mutation
      tool: null
      effect: |
        set_state_value(field, null)
      state_writes:
        - "${field}"
      state_reads: []

    since: "1.0.0"

  # --------------------------------------------------------------------------
  # merge_state
  # --------------------------------------------------------------------------
  merge_state:
    category: core/state
    description:
      brief: Merge object into state field
      detail: |
        Merges an object into an existing state field. Existing properties
        are overwritten, new properties are added. Useful for partial updates.
      notes:
        - Shallow merge (Object.assign semantics)
        - Creates target field if it doesn't exist
        - Values support ${} interpolation

    parameters:
      - name: field
        type: string
        required: true
        description: Object field to merge into
        pattern: "^[a-zA-Z_][a-zA-Z0-9_.\\[\\]]*$"
        interpolatable: false

      - name: value
        type: object
        required: true
        description: Object to merge (supports ${} interpolation in values)
        interpolatable: true

    payload:
      kind: state_mutation
      tool: null
      effect: |
        existing = get_state_value(field) ?? {}
        merged = Object.assign(existing, interpolate(value))
        set_state_value(field, merged)
      state_writes:
        - "${field}"
      state_reads:
        - "${field}"

    since: "1.0.0"

  # ==========================================================================
  # category: core/utility
  # ==========================================================================

  # --------------------------------------------------------------------------
  # set_timestamp
  # --------------------------------------------------------------------------
  set_timestamp:
    category: core/utility
    description:
      brief: Set current ISO timestamp
      detail: |
        Stores the current date/time as an ISO 8601 formatted string.
        Used for recording when operations occurred, cache invalidation,
        and audit trails.
      notes:
        - "Format: 2025-01-23T14:30:00.000Z"
        - Always uses UTC timezone
        - Useful for last_indexed_at, created_at fields

    parameters:
      - name: store_as
        type: string
        required: true
        description: State field for the timestamp
        pattern: "^[a-zA-Z_][a-zA-Z0-9_.\\[\\]]*$"
        interpolatable: false

    payload:
      kind: computation
      tool: null
      effect: |
        timestamp = new Date().toISOString()
        set_state_value(store_as, timestamp)
      state_writes:
        - "${store_as}"
      state_reads: []

    since: "1.0.0"

  # --------------------------------------------------------------------------
  # compute_hash
  # --------------------------------------------------------------------------
  compute_hash:
    category: core/utility
    description:
      brief: Compute SHA-256 hash of content
      detail: |
        Computes a SHA-256 hash of content stored in state. Useful for
        change detection, cache invalidation, and content verification.
        Output includes algorithm prefix.
      notes:
        - Uses SHA-256 algorithm
        - "Output format: sha256:abc123def456..."
        - "The sha256: prefix identifies the algorithm"
        - Useful for comparing content versions

    parameters:
      - name: from
        type: string
        required: true
        description: State field containing content to hash
        pattern: "^[a-zA-Z_][a-zA-Z0-9_.\\[\\]]*$"
        interpolatable: false

      - name: store_as
        type: string
        required: true
        description: State field for the hash result
        pattern: "^[a-zA-Z_][a-zA-Z0-9_.\\[\\]]*$"
        interpolatable: false

    payload:
      kind: computation
      tool: null
      effect: |
        content = get_state_value(from)
        hash = sha256(content)
        set_state_value(store_as, "sha256:" + hash)
      state_writes:
        - "${store_as}"
      state_reads:
        - "${from}"

    since: "1.0.0"

  # --------------------------------------------------------------------------
  # display (alias for display_message with content parameter)
  # --------------------------------------------------------------------------
  display:
    category: core/interaction
    description:
      brief: Display content to user (alias for display_message)
      detail: |
        Displays content to the user. This is an alias for display_message
        that uses 'content' as the parameter name instead of 'message'.
        Supports markdown formatting and ${} interpolation from state.
      notes:
        - Supports multiline content using YAML | syntax
        - All ${} placeholders interpolated from state
        - Markdown formatting is preserved
        - No state changes occur

    parameters:
      - name: content
        type: string
        required: true
        description: Content text with ${} interpolation
        interpolatable: true

    payload:
      kind: side_effect
      tool: null
      effect: |
        interpolated = interpolate(content, state)
        display_to_user(interpolated)
      state_writes: []
      state_reads: []

    since: "2.0.0"

  # ==========================================================================
  # category: core/intent
  # ==========================================================================

  # --------------------------------------------------------------------------
  # evaluate_keywords
  # --------------------------------------------------------------------------
  evaluate_keywords:
    category: core/intent
    description:
      brief: Match keywords to detect intent
      detail: |
        Matches user input against keyword sets to detect intent. Returns
        the first matching intent (case-insensitive). For compound intent
        handling, use parse_intent_flags + match_3vl_rules instead.
      notes:
        - Matches first keyword set containing a phrase found in input
        - Case-insensitive matching
        - Returns null if no match found
        - Simple approach for single-intent detection

    parameters:
      - name: input
        type: string
        required: true
        description: User input to match against
        interpolatable: true

      - name: keyword_sets
        type: object
        required: true
        description: Map of intent names to keyword arrays
        interpolatable: false

      - name: store_as
        type: string
        required: true
        description: State field for matched intent
        pattern: "^[a-zA-Z_][a-zA-Z0-9_.\\[\\]]*$"
        interpolatable: false

    payload:
      kind: computation
      tool: null
      effect: |
        for keyword_set_name, keywords in keyword_sets:
          for keyword in keywords:
            if input.toLowerCase().includes(keyword.toLowerCase()):
              set_state_value(store_as, keyword_set_name)
              return success
        set_state_value(store_as, null)
        return success
      state_writes:
        - "${store_as}"
      state_reads: []

    since: "1.0.0"

  # --------------------------------------------------------------------------
  # parse_intent_flags
  # --------------------------------------------------------------------------
  parse_intent_flags:
    category: core/intent
    description:
      brief: Parse 3VL flags from user input
      detail: |
        Parses user input and sets 3-valued logic (3VL) flags for intent
        detection. Each flag can be True (T), False (F), or Unknown (U)
        based on keyword matching.
      notes:
        - "3VL values: T (True), F (False), U (Unknown)"
        - Negative keywords checked first (more specific)
        - Unknown is the default when no keywords match

    parameters:
      - name: input
        type: string
        required: true
        description: User input to parse
        interpolatable: true

      - name: flag_definitions
        type: object
        required: true
        description: Map of flag names to keyword definitions
        interpolatable: true

      - name: store_as
        type: string
        required: true
        description: State field for flag values
        pattern: "^[a-zA-Z_][a-zA-Z0-9_.\\[\\]]*$"
        interpolatable: false

    payload:
      kind: computation
      tool: null
      effect: |
        flags = {}
        for flag_name, definition in flag_definitions:
          flags[flag_name] = "U"  # Default: Unknown

          # Check negative keywords first (more specific)
          if definition.negative_keywords:
            for keyword in definition.negative_keywords:
              if input.toLowerCase().includes(keyword.toLowerCase()):
                flags[flag_name] = "F"
                break

          # Check positive keywords (if not already F)
          if flags[flag_name] != "F":
            for keyword in definition.keywords:
              if input.toLowerCase().includes(keyword.toLowerCase()):
                flags[flag_name] = "T"
                break

        set_state_value(store_as, flags)
        return success
      state_writes:
        - "${store_as}"
      state_reads: []

    since: "1.0.0"

  # --------------------------------------------------------------------------
  # match_3vl_rules
  # --------------------------------------------------------------------------
  match_3vl_rules:
    category: core/intent
    description:
      brief: Match 3VL flags against rule table
      detail: |
        Matches 3VL flags against a rule table and ranks candidate actions.
        Uses 3-valued logic scoring: hard matches (+2), soft matches (+1),
        exclusions (candidate removed). Determines if there's a clear winner.
      notes:
        - "Hard match: state and rule both T or both F (+2)"
        - "Soft match: one is U, other is T/F (+1)"
        - "Exclusion: T vs F or F vs T (candidate removed)"
        - Clear winner requires 2+ point lead

    parameters:
      - name: flags
        type: object
        required: true
        description: Map of flag names to 3VL values (T/F/U)
        interpolatable: true

      - name: rules
        type: array
        required: true
        description: Array of intent rules with conditions
        interpolatable: true

      - name: store_as
        type: string
        required: true
        description: State field for match results
        pattern: "^[a-zA-Z_][a-zA-Z0-9_.\\[\\]]*$"
        interpolatable: false

    payload:
      kind: computation
      tool: null
      effect: |
        candidates = []

        for rule in rules:
          hard_matches = 0
          condition_count = len(rule.conditions)
          excluded = False

          for condition_key, rule_val in rule.conditions:
            state_val = flags[condition_key] ?? "U"

            if (state_val == "T" and rule_val == "T") or \
               (state_val == "F" and rule_val == "F"):
              hard_matches += 1          # Definite match
            elif (state_val == "T" and rule_val == "F") or \
                 (state_val == "F" and rule_val == "T"):
              excluded = True            # Contradiction
              break
            # else: U involved = unknown = no contribution

          if not excluded:
            candidates.append({
              rule: rule,
              score: hard_matches,
              condition_count: condition_count
            })

        # Sort by: hard matches (desc), then condition count (asc)
        candidates.sort(by: (-score, +condition_count))

        # Determine if clear winner
        if len(candidates) == 0:
          clear_winner = False
          winner = null
        elif len(candidates) == 1:
          clear_winner = True
          winner = candidates[0].rule
        else:
          top = candidates[0]

          # Count how many candidates tie with the top
          tied_at_top = [c for c in candidates
                        if c.score == top.score and c.condition_count == top.condition_count]

          if len(tied_at_top) == 1:
            clear_winner = True
            winner = top.rule
          else:
            clear_winner = False
            winner = null

        result = {
          clear_winner: clear_winner,
          winner: winner,
          tied_candidates: tied_at_top if not clear_winner else [],
          top_candidates: candidates[0:3],
          all_candidates: candidates
        }

        set_state_value(store_as, result)
        return success
      state_writes:
        - "${store_as}"
      state_reads: []

    since: "1.0.0"

  # --------------------------------------------------------------------------
  # dynamic_route
  # --------------------------------------------------------------------------
  dynamic_route:
    category: core/intent
    description:
      brief: Execute dynamically determined node transition
      detail: |
        Sets the next node based on a value computed at runtime. Enables
        rule-based routing where the target node is determined from state
        rather than being statically defined in the workflow.
      notes:
        - Workflow engine checks computed.dynamic_target after this consequence
        - Used when on_success should be determined at runtime
        - Typically follows match_3vl_rules

    parameters:
      - name: action
        type: string
        required: true
        description: Node name to transition to
        interpolatable: true

    payload:
      kind: state_mutation
      tool: null
      effect: |
        target_node = interpolate(action)
        set_state_value("computed.dynamic_target", target_node)
        return success
      state_writes:
        - "computed.dynamic_target"
      state_reads: []

    since: "1.0.0"

  # ==========================================================================
  # category: extensions/file-system
  # ==========================================================================

  # --------------------------------------------------------------------------
  # read_file
  # --------------------------------------------------------------------------
  read_file:
    category: extensions/file-system
    description:
      brief: Read arbitrary file content
      detail: |
        Reads the contents of a file and stores it in state. Supports
        ${} interpolation in the path. Fails if file doesn't exist.
      notes:
        - Path supports ${} interpolation
        - Fails if file doesn't exist
        - Content stored as string

    parameters:
      - name: path
        type: string
        required: true
        description: File path to read
        interpolatable: true

      - name: store_as
        type: string
        required: true
        description: State field for content
        pattern: "^[a-zA-Z_][a-zA-Z0-9_.\\[\\]]*$"
        interpolatable: false

    payload:
      kind: tool_call
      tool: Read
      effect: |
        content = Read(interpolate(path))
        set_state_value(store_as, content)
      state_writes:
        - "${store_as}"
      state_reads: []

    since: "1.0.0"

  # --------------------------------------------------------------------------
  # write_file
  # --------------------------------------------------------------------------
  write_file:
    category: extensions/file-system
    description:
      brief: Write content to file
      detail: |
        Writes content to a file. Creates parent directories if needed.
        Overwrites existing content. Both path and content support
        ${} interpolation.
      notes:
        - Creates parent directories if needed
        - Overwrites existing content
        - Path and content support interpolation

    parameters:
      - name: path
        type: string
        required: true
        description: File path to write
        interpolatable: true

      - name: content
        type: string
        required: true
        description: Content to write
        interpolatable: true

    payload:
      kind: tool_call
      tool: Write
      effect: |
        resolved_path = interpolate(path)
        resolved_content = interpolate(content)
        mkdir -p dirname(resolved_path)
        Write(resolved_path, resolved_content)
      state_writes: []
      state_reads: []

    since: "1.0.0"

  # --------------------------------------------------------------------------
  # create_directory
  # --------------------------------------------------------------------------
  create_directory:
    category: extensions/file-system
    description:
      brief: Create directory including parents
      detail: |
        Creates a directory at the specified path. Creates parent
        directories if they don't exist (like mkdir -p). Does not
        fail if directory already exists.
      notes:
        - Creates parent directories (mkdir -p behavior)
        - No error if directory already exists
        - Path supports ${} interpolation

    parameters:
      - name: path
        type: string
        required: true
        description: Directory path to create
        interpolatable: true

    payload:
      kind: tool_call
      tool: Bash
      effect: |
        mkdir -p interpolate(path)
      state_writes: []
      state_reads: []

    since: "1.0.0"

  # --------------------------------------------------------------------------
  # delete_file
  # --------------------------------------------------------------------------
  delete_file:
    category: extensions/file-system
    description:
      brief: Delete file if exists
      detail: |
        Deletes a file at the specified path. Does not fail if file
        doesn't exist. Does not delete directories.
      notes:
        - No error if file doesn't exist
        - Does not delete directories
        - Path supports ${} interpolation

    parameters:
      - name: path
        type: string
        required: true
        description: File to delete
        interpolatable: true

    payload:
      kind: tool_call
      tool: Bash
      effect: |
        rm -f interpolate(path)
      state_writes: []
      state_reads: []

    since: "1.0.0"

  # ==========================================================================
  # category: extensions/git
  # ==========================================================================

  # --------------------------------------------------------------------------
  # clone_repo
  # --------------------------------------------------------------------------
  clone_repo:
    category: extensions/git
    description:
      brief: Clone git repository
      detail: |
        Clones a git repository to the specified destination. Supports
        shallow clones (recommended for documentation indexing) and
        branch selection.
      notes:
        - Creates destination directory
        - Shallow clone (depth 1) recommended for documentation
        - Fails if destination exists (use git_pull for updates)

    parameters:
      - name: url
        type: string
        required: true
        description: Repository URL
        interpolatable: true

      - name: dest
        type: string
        required: true
        description: Destination path
        interpolatable: true

      - name: branch
        type: string
        required: false
        description: Branch to clone (default branch if not specified)
        interpolatable: true

      - name: depth
        type: number
        required: false
        default: 1
        description: Shallow clone depth
        interpolatable: false

    payload:
      kind: tool_call
      tool: Bash
      effect: |
        cmd = "git clone"
        if depth:
          cmd += " --depth " + depth
        if branch:
          cmd += " --branch " + interpolate(branch)
        cmd += " " + interpolate(url) + " " + interpolate(dest)
        Bash(cmd)
      state_writes: []
      state_reads: []

    since: "1.0.0"

  # --------------------------------------------------------------------------
  # get_sha
  # --------------------------------------------------------------------------
  get_sha:
    category: extensions/git
    description:
      brief: Get HEAD commit SHA
      detail: |
        Retrieves the HEAD commit SHA from a git repository. Returns
        the full 40-character SHA. Useful for tracking which version
        was indexed.
      notes:
        - Returns full 40-character SHA
        - Fails if path is not a git repository
        - Use after clone or pull to record version

    parameters:
      - name: repo_path
        type: string
        required: true
        description: Path to git repository
        interpolatable: true

      - name: store_as
        type: string
        required: true
        description: State field for SHA
        pattern: "^[a-zA-Z_][a-zA-Z0-9_.\\[\\]]*$"
        interpolatable: false

    payload:
      kind: tool_call
      tool: Bash
      effect: |
        sha = Bash("git -C " + interpolate(repo_path) + " rev-parse HEAD").trim()
        set_state_value(store_as, sha)
      state_writes:
        - "${store_as}"
      state_reads: []

    since: "1.0.0"

  # --------------------------------------------------------------------------
  # git_pull
  # --------------------------------------------------------------------------
  git_pull:
    category: extensions/git
    description:
      brief: Pull latest changes
      detail: |
        Pulls the latest changes from the remote repository using
        fast-forward only. Fails if there are local changes that
        would be overwritten or if fast-forward is not possible.
      notes:
        - Uses fast-forward only to avoid merge conflicts
        - Fails if local changes would be overwritten
        - Fails if fast-forward not possible

    parameters:
      - name: repo_path
        type: string
        required: true
        description: Path to git repository
        interpolatable: true

    payload:
      kind: tool_call
      tool: Bash
      effect: |
        Bash("git -C " + interpolate(repo_path) + " pull --ff-only")
      state_writes: []
      state_reads: []

    since: "1.0.0"

  # --------------------------------------------------------------------------
  # git_fetch
  # --------------------------------------------------------------------------
  git_fetch:
    category: extensions/git
    description:
      brief: Fetch remote refs
      detail: |
        Fetches remote refs without modifying the working directory.
        Useful for checking if updates are available before pulling.
      notes:
        - Updates remote tracking branches
        - Does not modify working directory
        - Use before comparing local vs remote SHA

    parameters:
      - name: repo_path
        type: string
        required: true
        description: Path to git repository
        interpolatable: true

    payload:
      kind: tool_call
      tool: Bash
      effect: |
        Bash("git -C " + interpolate(repo_path) + " fetch")
      state_writes: []
      state_reads: []

    since: "1.0.0"

  # ==========================================================================
  # category: extensions/web
  # ==========================================================================

  # --------------------------------------------------------------------------
  # web_fetch
  # --------------------------------------------------------------------------
  web_fetch:
    category: extensions/web
    description:
      brief: Fetch URL content
      detail: |
        Fetches content from a URL using Claude's WebFetch tool. HTML is
        automatically converted to markdown. Supports optional prompt for
        extraction guidance and allow_failure for graceful HTTP error handling.
      notes:
        - Uses Claude's WebFetch tool
        - HTML converted to markdown automatically
        - Prompt guides extraction if specified
        - With allow_failure, HTTP errors populate result but don't fail

    parameters:
      - name: url
        type: string
        required: true
        description: URL to fetch
        interpolatable: true

      - name: store_as
        type: string
        required: true
        description: State field for result
        pattern: "^[a-zA-Z_][a-zA-Z0-9_.\\[\\]]*$"
        interpolatable: false

      - name: allow_failure
        type: boolean
        required: false
        default: false
        description: If true, 4xx/5xx doesn't fail action
        interpolatable: false

      - name: prompt
        type: string
        required: false
        description: Prompt for WebFetch tool to guide extraction
        interpolatable: true

    payload:
      kind: tool_call
      tool: WebFetch
      effect: |
        result = WebFetch(
          url: interpolate(url),
          prompt: interpolate(prompt) ?? "Extract the main content"
        )
        stored_result = {
          status: result.status,
          content: result.content,
          url: interpolate(url)
        }
        if not allow_failure and result.status >= 400:
          throw Error("HTTP " + result.status)
        set_state_value(store_as, stored_result)
      state_writes:
        - "${store_as}"
      state_reads: []

    since: "1.0.0"

  # --------------------------------------------------------------------------
  # cache_web_content
  # --------------------------------------------------------------------------
  cache_web_content:
    category: extensions/web
    description:
      brief: Save fetched content to cache
      detail: |
        Saves the content from a web fetch result to a cache file.
        Creates parent directories if needed. Optionally stores the
        cache path in state for later reference.
      notes:
        - Creates parent directories if needed
        - Extracts content field from fetch result
        - Optional store_path_as records where file was written

    parameters:
      - name: from
        type: string
        required: true
        description: State field with fetch result
        pattern: "^[a-zA-Z_][a-zA-Z0-9_.\\[\\]]*$"
        interpolatable: false

      - name: dest
        type: string
        required: true
        description: Destination file path
        interpolatable: true

      - name: store_path_as
        type: string
        required: false
        description: State field to store the written path
        pattern: "^[a-zA-Z_][a-zA-Z0-9_.\\[\\]]*$"
        interpolatable: false

    payload:
      kind: composite
      tool: null
      effect: |
        fetch_result = get_state_value(from)
        content = fetch_result.content
        resolved_dest = interpolate(dest)
        mkdir -p dirname(resolved_dest)
        write_file(resolved_dest, content)
        if store_path_as:
          set_state_value(store_path_as, resolved_dest)
      state_writes:
        - "${store_path_as}"
      state_reads:
        - "${from}"

    since: "1.0.0"

  # ==========================================================================
  # category: extensions/scripting
  # ==========================================================================

  # --------------------------------------------------------------------------
  # run_script
  # --------------------------------------------------------------------------
  run_script:
    category: extensions/scripting
    description:
      brief: Execute script with auto-detected interpreter
      detail: |
        Executes a script file from the repository. Automatically detects the
        interpreter from the file extension (.py -> python3, .sh -> bash, .js -> node).
        Supports argument interpolation and output capture.
      notes:
        - Interpreter auto-detected from extension
        - Script path relative to repo root
        - Args support ${} interpolation
        - Use store_as to capture stdout

    parameters:
      - name: script
        type: string
        required: true
        description: Path to script (relative to repo root)
        interpolatable: true

      - name: args
        type: array
        required: false
        description: Arguments to pass to script
        interpolatable: true

      - name: store_as
        type: string
        required: false
        description: State field for captured output
        pattern: "^[a-zA-Z_][a-zA-Z0-9_.\\[\\]]*$"
        interpolatable: false

      - name: working_directory
        type: string
        required: false
        description: Working directory for script execution
        interpolatable: true

    payload:
      kind: tool_call
      tool: Bash
      effect: |
        script_path = interpolate(script)
        extension = script_path.split('.').pop()

        interpreter = match extension:
          "py" -> "python3"
          "sh" -> "bash"
          "bash" -> "bash"
          "js" -> "node"
          "ts" -> "npx ts-node"
          "rb" -> "ruby"
          _ -> null  # Use shebang

        cmd = interpreter ? interpreter + " " : "./"
        cmd += script_path
        if args:
          cmd += " " + args.map(interpolate).join(" ")

        if working_directory:
          cmd = "cd " + interpolate(working_directory) + " && " + cmd

        result = Bash(cmd)
        if store_as:
          set_state_value(store_as, result.stdout.trim())
      state_writes:
        - "${store_as}"
      state_reads: []

    since: "1.1.0"

  # --------------------------------------------------------------------------
  # run_python
  # --------------------------------------------------------------------------
  run_python:
    category: extensions/scripting
    description:
      brief: Execute Python script
      detail: |
        Executes a Python script with python3. Supports virtual environment
        activation, argument passing, and output capture.
      notes:
        - Uses python3 interpreter
        - Optional venv activation
        - Args support ${} interpolation

    parameters:
      - name: script
        type: string
        required: true
        description: Path to Python script
        interpolatable: true

      - name: args
        type: array
        required: false
        description: Arguments to pass
        interpolatable: true

      - name: venv
        type: string
        required: false
        description: Virtual environment path to activate
        interpolatable: true

      - name: store_as
        type: string
        required: false
        description: State field for captured output
        pattern: "^[a-zA-Z_][a-zA-Z0-9_.\\[\\]]*$"
        interpolatable: false

    payload:
      kind: tool_call
      tool: Bash
      effect: |
        cmd = ""
        if venv:
          cmd = "source " + interpolate(venv) + "/bin/activate && "
        cmd += "python3 " + interpolate(script)
        if args:
          cmd += " " + args.map(interpolate).join(" ")

        result = Bash(cmd)
        if store_as:
          set_state_value(store_as, result.stdout.trim())
      state_writes:
        - "${store_as}"
      state_reads: []

    since: "1.1.0"

  # --------------------------------------------------------------------------
  # run_bash
  # --------------------------------------------------------------------------
  run_bash:
    category: extensions/scripting
    description:
      brief: Execute Bash script
      detail: |
        Executes a Bash script. Supports environment variable injection,
        argument passing, and output capture.
      notes:
        - Uses bash interpreter explicitly
        - Env vars can be set inline
        - Args support ${} interpolation

    parameters:
      - name: script
        type: string
        required: true
        description: Path to Bash script
        interpolatable: true

      - name: args
        type: array
        required: false
        description: Arguments to pass
        interpolatable: true

      - name: env
        type: object
        required: false
        description: Environment variables to set
        interpolatable: true

      - name: store_as
        type: string
        required: false
        description: State field for captured output
        pattern: "^[a-zA-Z_][a-zA-Z0-9_.\\[\\]]*$"
        interpolatable: false

    payload:
      kind: tool_call
      tool: Bash
      effect: |
        cmd = ""
        if env:
          for key, value in env:
            cmd += key + "=" + interpolate(value) + " "
        cmd += "bash " + interpolate(script)
        if args:
          cmd += " " + args.map(interpolate).join(" ")

        result = Bash(cmd)
        if store_as:
          set_state_value(store_as, result.stdout.trim())
      state_writes:
        - "${store_as}"
      state_reads: []

    since: "1.1.0"

  # ==========================================================================
  # category: extensions/package
  # ==========================================================================

  # --------------------------------------------------------------------------
  # install_tool
  # --------------------------------------------------------------------------
  install_tool:
    category: extensions/package
    description:
      brief: Install a CLI tool if not already available
      detail: |
        Attempts to install a CLI tool using an appropriate package manager
        or install command. Uses the tool registry for install hints, or
        accepts a custom install command. Skips installation if tool is
        already available.
      notes:
        - Checks if tool is already installed first
        - Uses registry install_hint if no custom command provided
        - Requires network access for installation
        - May require elevated permissions depending on install method

    parameters:
      - name: tool
        type: string
        required: true
        description: Name of the tool to install
        pattern: "^[a-zA-Z0-9_-]+$"
        interpolatable: false

      - name: install_command
        type: string
        required: false
        description: Custom install command (overrides registry hint)
        interpolatable: true

      - name: skip_if_available
        type: boolean
        required: false
        default: true
        description: Skip installation if tool already available
        interpolatable: false

    payload:
      kind: side_effect
      tool: Bash
      effect: |
        # Check if already installed
        if skip_if_available and tool_available(tool):
          return { status: "skipped", message: "Tool already available" }

        # Get install command
        if install_command:
          cmd = interpolate(install_command)
        else:
          hint = registry_lookup(tool, "install_hint")
          if not hint:
            error("No install command for tool: " + tool)
          # Use first option from hint (e.g., "apt install X / brew install X")
          cmd = hint.split(" / ")[0]

        # Execute installation
        result = Bash(cmd)
        if result.exit_code != 0:
          error("Installation failed for " + tool + ": " + result.stderr)

        # Verify installation
        if not tool_available(tool):
          error("Tool not available after installation: " + tool)

        return { status: "installed", message: "Successfully installed " + tool }

      state_writes:
        - computed.install_result
      state_reads: []

    since: "2.0.0"
