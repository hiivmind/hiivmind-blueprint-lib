# Blueprint Consequence Type Definitions
# v3.0.0 - Consolidated types for reduced over-specification

schema_version: "1.0"
category: core
description: Consequence type definitions for workflow actions

consequences:
  # ==========================================================================
  # category: core/control
  # ==========================================================================

  # --------------------------------------------------------------------------
  # create_checkpoint
  # --------------------------------------------------------------------------
  create_checkpoint:
    category: core/control
    description:
      brief: Save state snapshot for potential rollback
      detail: |
        Creates a deep copy of the entire state at a named checkpoint.
        Used before risky operations to enable state restoration if
        something fails.
      notes:
        - Creates deep copy of entire state
        - Multiple checkpoints can coexist
        - Checkpoint names should be descriptive
        - Does NOT checkpoint file system - only state

    parameters:
      - name: name
        type: string
        required: true
        description: Checkpoint identifier
        pattern: "^[a-zA-Z_][a-zA-Z0-9_-]*$"
        interpolatable: false

    payload:
      kind: state_mutation
      tool: null
      effect: |
        state.checkpoints = state.checkpoints ?? {}
        state.checkpoints[name] = deep_copy(state)
      state_writes:
        - "checkpoints.${name}"
      state_reads: []

    since: "1.0.0"

  # --------------------------------------------------------------------------
  # rollback_checkpoint
  # --------------------------------------------------------------------------
  rollback_checkpoint:
    category: core/control
    description:
      brief: Restore state from checkpoint
      detail: |
        Restores the entire state from a previously created checkpoint.
        Used in error handling to reset state after a failed operation.
      notes:
        - Restores complete state snapshot
        - Does NOT rollback file system changes
        - Fails if checkpoint doesn't exist

    parameters:
      - name: name
        type: string
        required: true
        description: Checkpoint to restore
        pattern: "^[a-zA-Z_][a-zA-Z0-9_-]*$"
        interpolatable: false

    payload:
      kind: state_mutation
      tool: null
      effect: |
        if not state.checkpoints or not state.checkpoints[name]:
          throw Error("Checkpoint not found: " + name)
        state = state.checkpoints[name]
      state_writes:
        - "*"
      state_reads:
        - "checkpoints.${name}"

    since: "1.0.0"

  # --------------------------------------------------------------------------
  # spawn_agent
  # --------------------------------------------------------------------------
  spawn_agent:
    category: core/control
    description:
      brief: Launch a Task agent for parallel work
      detail: |
        Spawns a Claude Task agent to perform work in parallel. Can run
        synchronously or in the background. Results are stored in state
        when the agent completes.
      notes:
        - Uses Claude's Task tool to spawn subagent
        - Background agents run concurrently
        - Results stored when agent completes
        - Multiple spawn_agent calls can run in parallel

    parameters:
      - name: subagent_type
        type: string
        required: true
        description: Agent type from available Task agents
        interpolatable: false

      - name: prompt
        type: string
        required: true
        description: Task prompt for the agent
        interpolatable: true

      - name: store_as
        type: string
        required: true
        description: State field for agent result
        pattern: "^[a-zA-Z_][a-zA-Z0-9_.\\[\\]]*$"
        interpolatable: true

      - name: run_in_background
        type: boolean
        required: false
        default: false
        description: Run agent asynchronously
        interpolatable: false

    payload:
      kind: tool_call
      tool: Task
      effect: |
        agent_result = Task(
          subagent_type: subagent_type,
          prompt: interpolate(prompt),
          run_in_background: run_in_background ?? false
        )
        set_state_value(interpolate(store_as), agent_result)
      state_writes:
        - "${store_as}"
      state_reads: []

    since: "1.0.0"

  # --------------------------------------------------------------------------
  # invoke_skill
  # --------------------------------------------------------------------------
  invoke_skill:
    category: core/control
    description:
      brief: Invoke another skill and wait for completion
      detail: |
        Delegates to another skill using Claude's Skill tool. The invoked
        skill takes over the conversation. Typically used as the last
        action before reaching a success ending.
      notes:
        - Uses Claude's Skill tool to invoke
        - The invoked skill takes over the conversation
        - Control returns to workflow when skill completes
        - Typically the last action before ending

    parameters:
      - name: skill
        type: string
        required: true
        description: Skill name (without plugin prefix)
        interpolatable: true

      - name: args
        type: string
        required: false
        description: Arguments to pass to the skill
        default: ""
        interpolatable: true

    payload:
      kind: tool_call
      tool: Skill
      effect: |
        Skill(
          skill: interpolate(skill),
          args: interpolate(args) ?? ""
        )
      state_writes: []
      state_reads: []

    since: "1.0.0"

  # --------------------------------------------------------------------------
  # inline
  # --------------------------------------------------------------------------
  inline:
    category: core/control
    description:
      brief: Execute embedded pseudocode for non-reusable logic
      detail: |
        Allows embedding custom logic directly in a workflow when the operation
        is too specific to warrant a reusable consequence type. The pseudocode
        is executed by the workflow engine with access to state.

        Use sparingly - prefer reusable consequence types when the logic might
        be needed elsewhere.
      notes:
        - Pseudocode has full access to state
        - Can read and write state fields
        - Results can be stored via store_as
        - Use for workflow-specific transformations
        - Consider extracting to a reusable type if used more than once

    parameters:
      - name: description
        type: string
        required: true
        description: Human-readable description of what this code does
        interpolatable: false

      - name: pseudocode
        type: string
        required: true
        description: |
          The logic to execute. Has access to 'state' object and can use
          standard operations like get_state_value(), set_state_value().
        interpolatable: false

      - name: store_as
        type: string
        required: false
        description: State field to store the result in (if pseudocode returns a value)
        pattern: "^[a-zA-Z_][a-zA-Z0-9_.\\[\\]]*$"
        interpolatable: true

      - name: state_reads
        type: array
        required: false
        description: Document which state fields this code reads
        items: { type: string }

      - name: state_writes
        type: array
        required: false
        description: Document which state fields this code writes
        items: { type: string }

    payload:
      kind: computation
      tool: null
      effect: |
        # Execute the embedded pseudocode
        result = execute_pseudocode(pseudocode, state)

        # Store result if store_as is specified
        if store_as:
          set_state_value(interpolate(store_as), result)
      state_writes:
        - "${store_as}"
      state_reads: []

    since: "2.0.0"

  # ==========================================================================
  # category: core/evaluation
  # ==========================================================================

  # --------------------------------------------------------------------------
  # evaluate
  # --------------------------------------------------------------------------
  evaluate:
    category: core/evaluation
    description:
      brief: Evaluate expression and set flag based on result
      detail: |
        Evaluates a boolean expression and stores the result in a flag.
        Used for deriving boolean conditions from state that can then be
        used in conditional node branching.
      notes:
        - Expression must evaluate to boolean
        - Same syntax as evaluate_expression precondition
        - Supports comparison, logical operators, and functions

    parameters:
      - name: expression
        type: string
        required: true
        description: Boolean expression to evaluate
        interpolatable: false

      - name: set_flag
        type: string
        required: true
        description: Flag name to store the result
        pattern: "^[a-zA-Z_][a-zA-Z0-9_]*$"
        interpolatable: false

    payload:
      kind: computation
      tool: null
      effect: |
        result = eval_expression(expression, state)
        state.flags[set_flag] = result
      state_writes:
        - "flags.${set_flag}"
      state_reads: []

    since: "1.0.0"

  # --------------------------------------------------------------------------
  # compute
  # --------------------------------------------------------------------------
  compute:
    category: core/evaluation
    description:
      brief: Run expression and store result
      detail: |
        Evaluates an expression and stores the computed result in a state
        field. Unlike evaluate, this can return any type (string, number,
        array, object) not just booleans.
      notes:
        - Expression can return any type
        - Supports string operations, array methods, arithmetic
        - Result stored in specified state field

    parameters:
      - name: expression
        type: string
        required: true
        description: Expression to evaluate
        interpolatable: false

      - name: store_as
        type: string
        required: true
        description: State field to store the result
        pattern: "^[a-zA-Z_][a-zA-Z0-9_.\\[\\]]*$"
        interpolatable: false

    payload:
      kind: computation
      tool: null
      effect: |
        result = eval_expression(expression, state)
        set_state_value(store_as, result)
      state_writes:
        - "${store_as}"
      state_reads: []

    since: "1.0.0"

  # ==========================================================================
  # category: core/interaction
  # ==========================================================================

  # --------------------------------------------------------------------------
  # display
  # --------------------------------------------------------------------------
  display:
    category: core/interaction
    description:
      brief: Display content to user in various formats
      detail: |
        Displays content to the user. Supports multiple formats including
        plain text, markdown tables, JSON, and more. Supports ${} interpolation
        from state in both content and title.
      notes:
        - "format: text - plain text or markdown"
        - "format: table - requires headers and content as array of rows"
        - "format: json - pretty-prints content as JSON"
        - "format: markdown - alias for text"
        - All ${} placeholders interpolated from state
        - No state changes occur

    parameters:
      - name: format
        type: string
        required: false
        default: text
        description: "Output format: text, table, json, markdown"
        enum:
          - text
          - table
          - json
          - markdown
        interpolatable: false

      - name: content
        type: any
        required: true
        description: Content to display (string for text, array for table rows)
        interpolatable: true

      - name: title
        type: string
        required: false
        description: Optional title (displayed above content)
        interpolatable: true

      - name: headers
        type: array
        required: false
        description: Column headers (required for table format)
        items: { type: string }
        interpolatable: false

    payload:
      kind: side_effect
      tool: null
      effect: |
        resolved_content = interpolate(content, state)

        if format == "table":
          table = format_markdown_table(headers, resolved_content)
          if title:
            display_to_user("### " + interpolate(title) + "\n\n" + table)
          else:
            display_to_user(table)

        elif format == "json":
          json_str = json_dumps(resolved_content, indent=2)
          if title:
            display_to_user("### " + interpolate(title) + "\n\n```json\n" + json_str + "\n```")
          else:
            display_to_user("```json\n" + json_str + "\n```")

        else:  # text or markdown
          if title:
            display_to_user("### " + interpolate(title) + "\n\n" + resolved_content)
          else:
            display_to_user(resolved_content)
      state_writes: []
      state_reads: []

    since: "3.0.0"
    replaces:
      - display_message
      - display_table

  # ==========================================================================
  # category: core/logging
  # ==========================================================================

  # --------------------------------------------------------------------------
  # init_log
  # --------------------------------------------------------------------------
  init_log:
    category: core/logging
    description:
      brief: Initialize log structure with workflow metadata
      detail: |
        Initializes the log structure at workflow start. Sets up metadata,
        session tracking, and prepares arrays for events, warnings, and
        errors. Should be called once at the beginning of workflow execution.
      notes:
        - Call once at workflow start
        - Session context captured from environment variables
        - Creates state.log structure
        - Sets flags.log_initialized to true

    parameters:
      - name: workflow_name
        type: string
        required: true
        description: Workflow identifier
        interpolatable: true

      - name: workflow_version
        type: string
        required: false
        default: "1.0"
        description: Workflow version
        interpolatable: true

      - name: skill_name
        type: string
        required: false
        description: Name of invoking skill
        interpolatable: true

      - name: plugin_name
        type: string
        required: false
        description: Name of parent plugin
        interpolatable: true

      - name: execution_path
        type: string
        required: false
        description: Skill/command path (auto-detected if not provided)
        interpolatable: true

    payload:
      kind: composite
      tool: null
      effect: |
        # Session state management
        session_state_path = ".logs/.session-state.yaml"
        session_state = read_yaml(session_state_path) ?? { current_session: null }

        current_id = env.BLUEPRINT_SESSION_ID
        if session_state.current_session?.id != current_id:
          session_state.current_session = {
            id: current_id,
            invocation_count: 0,
            invocations: []
          }

        session_state.current_session.invocation_count += 1
        invocation_index = session_state.current_session.invocation_count

        computed_log_path = format_log_path(skill_name, now_iso8601())

        session_state.current_session.invocations.push({
          index: invocation_index,
          skill: skill_name,
          log_path: computed_log_path,
          timestamp: now_iso8601()
        })

        mkdir -p dirname(session_state_path)
        write_yaml(session_state_path, session_state)

        state.log = {
          metadata: {
            workflow_name: workflow_name,
            workflow_version: workflow_version ?? "1.0",
            skill_name: skill_name ?? null,
            plugin_name: plugin_name ?? null,
            execution_path: execution_path ?? cwd,
            session: {
              id: env.BLUEPRINT_SESSION_ID ?? null,
              transcript_path: env.BLUEPRINT_TRANSCRIPT_PATH ?? null,
              invocation_index: invocation_index,
              snapshot_points: []
            }
          },
          parameters: extract_flags(initial_state.flags),
          execution: {
            start_time: now_iso8601(),
            end_time: null,
            duration_seconds: null,
            outcome: null,
            ending_node: null
          },
          node_history: [],
          events: [],
          warnings: [],
          errors: [],
          summary: null
        }
        state.flags.log_initialized = true
        state.computed.expected_log_path = computed_log_path
      state_writes:
        - "log"
        - "flags.log_initialized"
        - "computed.expected_log_path"
      state_reads: []

    since: "1.0.0"

  # --------------------------------------------------------------------------
  # log_node
  # --------------------------------------------------------------------------
  log_node:
    category: core/logging
    description:
      brief: Record node execution in history
      detail: |
        Records a node execution event in the log history. Captures the
        node ID, outcome, timestamp, and optional details. Subject to
        logging level configuration.
      notes:
        - Requires logging level >= info
        - Details can include any key-value pairs
        - Timestamp auto-generated

    parameters:
      - name: node
        type: string
        required: true
        description: Node identifier
        interpolatable: true

      - name: outcome
        type: string
        required: true
        description: "Execution result: success, skipped, error, blocked"
        enum:
          - success
          - skipped
          - error
          - blocked
        interpolatable: true

      - name: details
        type: object
        required: false
        description: Arbitrary key-value pairs for context
        interpolatable: true

    payload:
      kind: state_mutation
      tool: null
      effect: |
        if logging.level >= "info":
          state.log.node_history.push({
            node: node,
            timestamp: now_iso8601(),
            outcome: outcome,
            details: details ?? {}
          })
      state_writes:
        - "log.node_history"
      state_reads: []

    since: "1.0.0"

  # --------------------------------------------------------------------------
  # log_entry
  # --------------------------------------------------------------------------
  log_entry:
    category: core/logging
    description:
      brief: Log event, warning, or error with context
      detail: |
        Unified logging consequence that handles events, warnings, and errors.
        The level parameter determines how the entry is stored and displayed.
        Events go to state.log.events, warnings to state.log.warnings,
        errors to state.log.errors.
      notes:
        - "level: info/debug - logged as event"
        - "level: warning - logged as warning"
        - "level: error - logged as error"
        - Context can be any structured object
        - error_type and recoverable only used for error level

    parameters:
      - name: level
        type: string
        required: true
        description: "Log level: debug, info, warning, error"
        enum:
          - debug
          - info
          - warning
          - error
        interpolatable: false

      - name: message
        type: string
        required: true
        description: Log message
        interpolatable: true

      - name: context
        type: object
        required: false
        description: Additional context for debugging
        interpolatable: true

      - name: event_type
        type: string
        required: false
        description: Domain-specific event type (for info/debug levels)
        interpolatable: true

      - name: error_type
        type: string
        required: false
        description: Error classification (for error level)
        interpolatable: true

      - name: recoverable
        type: boolean
        required: false
        default: false
        description: Whether workflow continued after this error
        interpolatable: false

      - name: node
        type: string
        required: false
        description: Node that generated entry (auto-detected)
        interpolatable: true

    payload:
      kind: state_mutation
      tool: null
      effect: |
        if level == "error":
          if logging.level >= "error":
            state.log.errors.push({
              message: message,
              error_type: error_type ?? "unknown",
              timestamp: now_iso8601(),
              node: node ?? current_node.id,
              context: context ?? {},
              recoverable: recoverable ?? false
            })

        elif level == "warning":
          if logging.level >= "warn":
            state.log.warnings.push({
              message: message,
              timestamp: now_iso8601(),
              node: node ?? current_node.id,
              context: context ?? {}
            })

        else:  # info or debug
          effective_level = level ?? "info"
          if logging.level >= effective_level:
            state.log.events.push({
              type: event_type ?? "log",
              timestamp: now_iso8601(),
              message: message,
              data: context ?? {}
            })
      state_writes:
        - "log.events"
        - "log.warnings"
        - "log.errors"
      state_reads: []

    since: "3.0.0"
    replaces:
      - log_event
      - log_warning
      - log_error

  # --------------------------------------------------------------------------
  # log_session_snapshot
  # --------------------------------------------------------------------------
  log_session_snapshot:
    category: core/logging
    description:
      brief: Record mid-session checkpoint
      detail: |
        Records a snapshot at a critical decision point. Useful for
        long-running workflows where you want checkpoints at significant
        moments. Can optionally write an intermediate log file.
      notes:
        - Always executes (level-independent)
        - write_intermediate creates a snapshot file
        - Useful before destructive operations

    parameters:
      - name: description
        type: string
        required: true
        description: What decision or event occurred
        interpolatable: true

      - name: write_intermediate
        type: boolean
        required: false
        default: false
        description: Write log to file at this point
        interpolatable: false

      - name: node
        type: string
        required: false
        description: Node identifier (auto-detected)
        interpolatable: true

    payload:
      kind: composite
      tool: null
      effect: |
        snapshot = {
          timestamp: now_iso8601(),
          node: node ?? current_node.id,
          description: description,
          log_path: null
        }

        if write_intermediate:
          snapshot_count = len(state.log.metadata.session.snapshot_points) + 1
          snapshot_path = format_snapshot_path(
            state.log.metadata.skill_name,
            now_iso8601(),
            snapshot_count
          )

          log_content = format_log(state.log, "yaml")
          mkdir -p dirname(snapshot_path)
          write_file(snapshot_path, log_content)

          snapshot.log_path = snapshot_path

        state.log.metadata.session.snapshot_points.push(snapshot)
      state_writes:
        - "log.metadata.session.snapshot_points"
      state_reads: []

    since: "1.0.0"

  # --------------------------------------------------------------------------
  # finalize_log
  # --------------------------------------------------------------------------
  finalize_log:
    category: core/logging
    description:
      brief: Complete log with timing and outcome
      detail: |
        Completes the log with execution timing, outcome, and summary.
        Should be called at workflow end (success, error, or cancel).
        Sets flags.log_finalized to true.
      notes:
        - Call at workflow end (any ending node)
        - Calculates duration from start_time
        - Auto-generates summary if not provided

    parameters:
      - name: outcome
        type: string
        required: true
        description: "Final result: success, partial, error, cancelled"
        enum:
          - success
          - partial
          - error
          - cancelled
        interpolatable: true

      - name: ending_node
        type: string
        required: false
        description: Last executed node (auto-detected)
        interpolatable: true

      - name: summary
        type: string
        required: false
        description: Human-readable execution summary
        interpolatable: true

    payload:
      kind: state_mutation
      tool: null
      effect: |
        state.log.execution.end_time = now_iso8601()
        state.log.execution.duration_seconds = time_diff_seconds(
          state.log.execution.start_time,
          state.log.execution.end_time
        )
        state.log.execution.outcome = outcome
        state.log.execution.ending_node = ending_node ?? current_node.id
        state.log.summary = summary ?? auto_generate_summary()
        state.flags.log_finalized = true
      state_writes:
        - "log.execution"
        - "log.summary"
        - "flags.log_finalized"
      state_reads:
        - "log.execution.start_time"

    since: "1.0.0"

  # --------------------------------------------------------------------------
  # write_log
  # --------------------------------------------------------------------------
  write_log:
    category: core/logging
    description:
      brief: Write log to file
      detail: |
        Writes the finalized log to a file. Supports multiple output
        formats (YAML, JSON, Markdown). Path supports interpolation and
        has sensible defaults.
      notes:
        - Default path pattern based on skill name and timestamp
        - Creates parent directories if needed
        - Stores actual path in computed.log_path

    parameters:
      - name: format
        type: string
        required: false
        default: yaml
        description: "Output format: yaml, json, markdown"
        enum:
          - yaml
          - json
          - markdown
        interpolatable: false

      - name: path
        type: string
        required: false
        description: Output path (default based on skill name and timestamp)
        interpolatable: true

      - name: include_node_history
        type: boolean
        required: false
        default: true
        description: Include node_history array
        interpolatable: false

      - name: include_events
        type: boolean
        required: false
        default: true
        description: Include events array
        interpolatable: false

    payload:
      kind: side_effect
      tool: null
      effect: |
        log_content = format_log(state.log, format, {
          include_node_history: include_node_history ?? true,
          include_events: include_events ?? true
        })
        effective_path = path ?? format_default_log_path(
          state.log.metadata.skill_name,
          state.log.execution.start_time,
          format
        )
        mkdir -p dirname(effective_path)
        write_file(effective_path, log_content)
        state.computed.log_path = effective_path
      state_writes:
        - "computed.log_path"
      state_reads:
        - "log"

    since: "1.0.0"

  # --------------------------------------------------------------------------
  # apply_log_retention
  # --------------------------------------------------------------------------
  apply_log_retention:
    category: core/logging
    description:
      brief: Clean up old log files
      detail: |
        Cleans up old log files according to retention policy. Supports
        count-based (keep N newest) or time-based (keep files newer than
        N days) retention strategies.
      notes:
        - "strategy: none - no cleanup"
        - "strategy: count - keep N newest files"
        - "strategy: days - keep files newer than N days"
        - Stores count of deleted files in computed.logs_deleted

    parameters:
      - name: path
        type: string
        required: true
        description: Directory containing logs
        interpolatable: true

      - name: strategy
        type: string
        required: true
        description: "Retention strategy: none, days, count"
        enum:
          - none
          - days
          - count
        interpolatable: false

      - name: days
        type: number
        required: false
        description: Max age in days (required if strategy=days)
        interpolatable: false

      - name: count
        type: number
        required: false
        description: Max files to keep (required if strategy=count)
        interpolatable: false

      - name: pattern
        type: string
        required: false
        default: "*.yaml"
        description: Glob pattern for log files
        interpolatable: false

    payload:
      kind: side_effect
      tool: null
      effect: |
        if strategy == "none":
          return

        files = glob(path, pattern ?? "*.yaml").sort_by_mtime()

        if strategy == "count":
          to_delete = files[count:]
        elif strategy == "days":
          cutoff = now() - days * 86400
          to_delete = files.filter(f => mtime(f) < cutoff)

        for file in to_delete:
          delete_file(file)

        state.computed.logs_deleted = len(to_delete)
      state_writes:
        - "computed.logs_deleted"
      state_reads: []

    since: "1.0.0"

  # --------------------------------------------------------------------------
  # output_ci_summary
  # --------------------------------------------------------------------------
  output_ci_summary:
    category: core/logging
    description:
      brief: Format output for CI environments
      detail: |
        Formats and outputs log summary for CI environments like GitHub
        Actions. Can emit annotations for errors and warnings. Writes to
        GITHUB_STEP_SUMMARY when in GitHub Actions environment.
      notes:
        - "github format: writes to GITHUB_STEP_SUMMARY"
        - "plain format: prints to stdout"
        - "json format: prints JSON to stdout"
        - Annotations emit ::error and ::warning prefixes

    parameters:
      - name: format
        type: string
        required: false
        description: "CI format: github, plain, json, none"
        enum:
          - github
          - plain
          - json
          - none
        interpolatable: false

      - name: annotations
        type: boolean
        required: false
        default: true
        description: Emit annotations for errors/warnings
        interpolatable: false

      - name: output_file
        type: string
        required: false
        description: Override GITHUB_STEP_SUMMARY path
        interpolatable: true

    payload:
      kind: side_effect
      tool: null
      effect: |
        if format == "none":
          return

        if format == "github":
          summary_path = output_file ?? env.GITHUB_STEP_SUMMARY
          append_file(summary_path, format_github_summary(state.log))

          if annotations:
            for error in state.log.errors:
              echo "::error file={error.context.file},line={error.context.line}::{error.message}"
            for warning in state.log.warnings:
              echo "::warning::{warning.message}"

        elif format == "plain":
          print(format_plain_summary(state.log))

        elif format == "json":
          print(json_dumps(state.log))
      state_writes: []
      state_reads:
        - "log"

    since: "1.0.0"

  # ==========================================================================
  # category: core/state
  # ==========================================================================

  # --------------------------------------------------------------------------
  # set_flag
  # --------------------------------------------------------------------------
  set_flag:
    category: core/state
    description:
      brief: Set a boolean flag
      detail: |
        Sets a boolean flag in the state.flags namespace. Flags are used for
        simple true/false state that can be checked in conditional nodes.
      notes:
        - Flags are stored in state.flags namespace
        - Use for binary conditions checked in workflow branching

    parameters:
      - name: flag
        type: string
        required: true
        description: Flag name (alphanumeric and underscores)
        pattern: "^[a-zA-Z_][a-zA-Z0-9_]*$"
        interpolatable: false

      - name: value
        type: boolean
        required: true
        description: Boolean value to set
        interpolatable: false

    payload:
      kind: state_mutation
      tool: null
      effect: |
        state.flags[flag] = value
      state_writes:
        - "flags.${flag}"
      state_reads: []

    since: "1.0.0"

  # --------------------------------------------------------------------------
  # mutate_state
  # --------------------------------------------------------------------------
  mutate_state:
    category: core/state
    description:
      brief: Perform state mutations (set, append, clear, merge)
      detail: |
        Unified state mutation consequence. The operation parameter determines
        what type of mutation is performed on the specified field.
      notes:
        - "operation: set - set field to value"
        - "operation: append - append value to array field"
        - "operation: clear - set field to null"
        - "operation: merge - shallow merge object into field"
        - Value supports ${} interpolation

    parameters:
      - name: operation
        type: string
        required: true
        description: "Mutation type: set, append, clear, merge"
        enum:
          - set
          - append
          - clear
          - merge
        interpolatable: false

      - name: field
        type: string
        required: true
        description: State field path (dot notation for nested)
        pattern: "^[a-zA-Z_][a-zA-Z0-9_.\\[\\]]*$"
        interpolatable: false

      - name: value
        type: any
        required: false
        description: Value for set/append/merge (ignored for clear)
        interpolatable: true

    payload:
      kind: state_mutation
      tool: null
      effect: |
        if operation == "set":
          set_state_value(field, interpolate(value))

        elif operation == "append":
          array = get_state_value(field) ?? []
          array.push(interpolate(value))
          set_state_value(field, array)

        elif operation == "clear":
          set_state_value(field, null)

        elif operation == "merge":
          existing = get_state_value(field) ?? {}
          merged = Object.assign(existing, interpolate(value))
          set_state_value(field, merged)
      state_writes:
        - "${field}"
      state_reads:
        - "${field}"

    since: "3.0.0"
    replaces:
      - set_state
      - append_state
      - clear_state
      - merge_state

  # ==========================================================================
  # category: core/utility
  # ==========================================================================

  # --------------------------------------------------------------------------
  # set_timestamp
  # --------------------------------------------------------------------------
  set_timestamp:
    category: core/utility
    description:
      brief: Set current ISO timestamp
      detail: |
        Stores the current date/time as an ISO 8601 formatted string.
        Used for recording when operations occurred, cache invalidation,
        and audit trails.
      notes:
        - "Format: 2025-01-23T14:30:00.000Z"
        - Always uses UTC timezone
        - Useful for last_indexed_at, created_at fields

    parameters:
      - name: store_as
        type: string
        required: true
        description: State field for the timestamp
        pattern: "^[a-zA-Z_][a-zA-Z0-9_.\\[\\]]*$"
        interpolatable: false

    payload:
      kind: computation
      tool: null
      effect: |
        timestamp = new Date().toISOString()
        set_state_value(store_as, timestamp)
      state_writes:
        - "${store_as}"
      state_reads: []

    since: "1.0.0"

  # --------------------------------------------------------------------------
  # compute_hash
  # --------------------------------------------------------------------------
  compute_hash:
    category: core/utility
    description:
      brief: Compute SHA-256 hash of content
      detail: |
        Computes a SHA-256 hash of content stored in state. Useful for
        change detection, cache invalidation, and content verification.
        Output includes algorithm prefix.
      notes:
        - Uses SHA-256 algorithm
        - "Output format: sha256:abc123def456..."
        - "The sha256: prefix identifies the algorithm"
        - Useful for comparing content versions

    parameters:
      - name: from
        type: string
        required: true
        description: State field containing content to hash
        pattern: "^[a-zA-Z_][a-zA-Z0-9_.\\[\\]]*$"
        interpolatable: false

      - name: store_as
        type: string
        required: true
        description: State field for the hash result
        pattern: "^[a-zA-Z_][a-zA-Z0-9_.\\[\\]]*$"
        interpolatable: false

    payload:
      kind: computation
      tool: null
      effect: |
        content = get_state_value(from)
        hash = sha256(content)
        set_state_value(store_as, "sha256:" + hash)
      state_writes:
        - "${store_as}"
      state_reads:
        - "${from}"

    since: "1.0.0"

  # ==========================================================================
  # category: core/intent
  # ==========================================================================

  # --------------------------------------------------------------------------
  # evaluate_keywords
  # --------------------------------------------------------------------------
  evaluate_keywords:
    category: core/intent
    description:
      brief: Match keywords to detect intent
      detail: |
        Matches user input against keyword sets to detect intent. Returns
        the first matching intent (case-insensitive). For compound intent
        handling, use parse_intent_flags + match_3vl_rules instead.
      notes:
        - Matches first keyword set containing a phrase found in input
        - Case-insensitive matching
        - Returns null if no match found
        - Simple approach for single-intent detection

    parameters:
      - name: input
        type: string
        required: true
        description: User input to match against
        interpolatable: true

      - name: keyword_sets
        type: object
        required: true
        description: Map of intent names to keyword arrays
        interpolatable: false

      - name: store_as
        type: string
        required: true
        description: State field for matched intent
        pattern: "^[a-zA-Z_][a-zA-Z0-9_.\\[\\]]*$"
        interpolatable: false

    payload:
      kind: computation
      tool: null
      effect: |
        for keyword_set_name, keywords in keyword_sets:
          for keyword in keywords:
            if input.toLowerCase().includes(keyword.toLowerCase()):
              set_state_value(store_as, keyword_set_name)
              return success
        set_state_value(store_as, null)
        return success
      state_writes:
        - "${store_as}"
      state_reads: []

    since: "1.0.0"

  # --------------------------------------------------------------------------
  # parse_intent_flags
  # --------------------------------------------------------------------------
  parse_intent_flags:
    category: core/intent
    description:
      brief: Parse 3VL flags from user input
      detail: |
        Parses user input and sets 3-valued logic (3VL) flags for intent
        detection. Each flag can be True (T), False (F), or Unknown (U)
        based on keyword matching.
      notes:
        - "3VL values: T (True), F (False), U (Unknown)"
        - Negative keywords checked first (more specific)
        - Unknown is the default when no keywords match

    parameters:
      - name: input
        type: string
        required: true
        description: User input to parse
        interpolatable: true

      - name: flag_definitions
        type: object
        required: true
        description: Map of flag names to keyword definitions
        interpolatable: true

      - name: store_as
        type: string
        required: true
        description: State field for flag values
        pattern: "^[a-zA-Z_][a-zA-Z0-9_.\\[\\]]*$"
        interpolatable: false

    payload:
      kind: computation
      tool: null
      effect: |
        flags = {}
        for flag_name, definition in flag_definitions:
          flags[flag_name] = "U"  # Default: Unknown

          # Check negative keywords first (more specific)
          if definition.negative_keywords:
            for keyword in definition.negative_keywords:
              if input.toLowerCase().includes(keyword.toLowerCase()):
                flags[flag_name] = "F"
                break

          # Check positive keywords (if not already F)
          if flags[flag_name] != "F":
            for keyword in definition.keywords:
              if input.toLowerCase().includes(keyword.toLowerCase()):
                flags[flag_name] = "T"
                break

        set_state_value(store_as, flags)
        return success
      state_writes:
        - "${store_as}"
      state_reads: []

    since: "1.0.0"

  # --------------------------------------------------------------------------
  # match_3vl_rules
  # --------------------------------------------------------------------------
  match_3vl_rules:
    category: core/intent
    description:
      brief: Match 3VL flags against rule table
      detail: |
        Matches 3VL flags against a rule table and ranks candidate actions.
        Uses Kleene 3-valued logic with proper U (unknown) handling:
        - Rule U = "don't care" (wildcard) - condition is skipped
        - State U = uncertain - counts as soft match if rule expects T/F
        - Hard match: both state and rule are T, or both are F
        - Soft match: state is U but rule expects T/F (uncertain satisfaction)
        - Exclusion: state T vs rule F, or state F vs rule T (contradiction)

        Ranking: (-hard_matches, +soft_matches, +effective_conditions)
        This prefers rules with more definite matches, fewer uncertain matches,
        and fewer effective conditions (more specific rules win ties).
      notes:
        - "Rule U = don't care (wildcard, skip this condition)"
        - "State U vs Rule T/F = soft match (uncertain satisfaction)"
        - "Hard match: state T + rule T, or state F + rule F"
        - "Exclusion: state T + rule F, or state F + rule T"
        - "Effective conditions = non-U conditions in rule"
        - Clear winner determined by full ranking tuple

    parameters:
      - name: flags
        type: object
        required: true
        description: Map of flag names to 3VL values (T/F/U)
        interpolatable: true

      - name: rules
        type: array
        required: true
        description: Array of intent rules with conditions
        interpolatable: true

      - name: store_as
        type: string
        required: true
        description: State field for match results
        pattern: "^[a-zA-Z_][a-zA-Z0-9_.\\[\\]]*$"
        interpolatable: false

    payload:
      kind: computation
      tool: null
      effect: |
        candidates = []

        for rule in rules:
          hard_matches = 0
          soft_matches = 0
          effective_conditions = 0  # Non-U conditions in rule
          excluded = False

          for condition_key, rule_val in rule.conditions:
            state_val = flags[condition_key] ?? "U"

            # Rule says "don't care" - skip this condition entirely
            if rule_val == "U":
              continue

            # Count effective (non-U) conditions in rule
            effective_conditions += 1

            if (state_val == "T" and rule_val == "T") or \
               (state_val == "F" and rule_val == "F"):
              hard_matches += 1          # Definite match
            elif state_val == "U":
              soft_matches += 1          # Uncertain satisfaction
            else:
              # state T vs rule F, or state F vs rule T
              excluded = True            # Contradiction
              break

          if not excluded:
            candidates.append({
              rule: rule,
              hard_matches: hard_matches,
              soft_matches: soft_matches,
              effective_conditions: effective_conditions,
              # Legacy compatibility fields
              score: hard_matches,
              condition_count: effective_conditions
            })

        # Sort by: hard matches (desc), soft matches (asc), effective conditions (asc)
        # More hard matches = better, fewer soft matches = more certain,
        # fewer conditions = more specific rule
        candidates.sort(by: (-hard_matches, +soft_matches, +effective_conditions))

        # Determine if clear winner using full ranking tuple
        if len(candidates) == 0:
          clear_winner = False
          winner = null
          tied_at_top = []
        elif len(candidates) == 1:
          clear_winner = True
          winner = candidates[0].rule
          tied_at_top = []
        else:
          top = candidates[0]

          # Count how many candidates tie with the top using full tuple
          tied_at_top = [c for c in candidates
                        if c.hard_matches == top.hard_matches and \
                           c.soft_matches == top.soft_matches and \
                           c.effective_conditions == top.effective_conditions]

          if len(tied_at_top) == 1:
            clear_winner = True
            winner = top.rule
          else:
            clear_winner = False
            winner = null

        result = {
          clear_winner: clear_winner,
          winner: winner,
          tied_candidates: tied_at_top if not clear_winner else [],
          top_candidates: candidates[0:3],
          all_candidates: candidates
        }

        set_state_value(store_as, result)
        return success
      state_writes:
        - "${store_as}"
      state_reads: []

    since: "1.0.0"
    updated: "2.1.0"

  # --------------------------------------------------------------------------
  # dynamic_route
  # --------------------------------------------------------------------------
  dynamic_route:
    category: core/intent
    description:
      brief: Execute dynamically determined node transition
      detail: |
        Sets the next node based on a value computed at runtime. Enables
        rule-based routing where the target node is determined from state
        rather than being statically defined in the workflow.
      notes:
        - Workflow engine checks computed.dynamic_target after this consequence
        - Used when on_success should be determined at runtime
        - Typically follows match_3vl_rules

    parameters:
      - name: action
        type: string
        required: true
        description: Node name to transition to
        interpolatable: true

    payload:
      kind: state_mutation
      tool: null
      effect: |
        target_node = interpolate(action)
        set_state_value("computed.dynamic_target", target_node)
        return success
      state_writes:
        - "computed.dynamic_target"
      state_reads: []

    since: "1.0.0"

  # ==========================================================================
  # category: extensions/file-system
  # ==========================================================================

  # --------------------------------------------------------------------------
  # local_file_ops
  # --------------------------------------------------------------------------
  local_file_ops:
    category: extensions/file-system
    description:
      brief: Perform file system operations (read, write, mkdir, delete)
      detail: |
        Unified file system consequence for read, write, mkdir, and delete
        operations. The operation parameter determines what action is performed.
      notes:
        - "operation: read - read file content into state"
        - "operation: write - write content to file (creates parent dirs)"
        - "operation: mkdir - create directory (like mkdir -p)"
        - "operation: delete - delete file if exists"
        - Path and content support ${} interpolation

    parameters:
      - name: operation
        type: string
        required: true
        description: "File operation: read, write, mkdir, delete"
        enum:
          - read
          - write
          - mkdir
          - delete
        interpolatable: false

      - name: path
        type: string
        required: true
        description: File or directory path
        interpolatable: true

      - name: content
        type: string
        required: false
        description: Content for write operation
        interpolatable: true

      - name: store_as
        type: string
        required: false
        description: State field for read operation result
        pattern: "^[a-zA-Z_][a-zA-Z0-9_.\\[\\]]*$"
        interpolatable: false

    payload:
      kind: tool_call
      tool: null
      effect: |
        resolved_path = interpolate(path)

        if operation == "read":
          content = Read(resolved_path)
          set_state_value(store_as, content)

        elif operation == "write":
          resolved_content = interpolate(content)
          mkdir -p dirname(resolved_path)
          Write(resolved_path, resolved_content)

        elif operation == "mkdir":
          mkdir -p resolved_path

        elif operation == "delete":
          rm -f resolved_path
      state_writes:
        - "${store_as}"
      state_reads: []

    since: "3.0.0"
    replaces:
      - read_file
      - write_file
      - create_directory
      - delete_file

  # ==========================================================================
  # category: extensions/git
  # ==========================================================================

  # --------------------------------------------------------------------------
  # git_ops_local
  # --------------------------------------------------------------------------
  git_ops_local:
    category: extensions/git
    description:
      brief: Perform git operations (clone, pull, fetch, get-sha)
      detail: |
        Unified git operations consequence for local repository operations.
        The operation parameter determines what git command is executed.
      notes:
        - "operation: clone - clone repository to dest"
        - "operation: pull - pull latest changes (fast-forward only)"
        - "operation: fetch - fetch remote refs"
        - "operation: get-sha - get HEAD commit SHA"
        - Args object contains operation-specific parameters

    parameters:
      - name: operation
        type: string
        required: true
        description: "Git operation: clone, pull, fetch, get-sha"
        enum:
          - clone
          - pull
          - fetch
          - get-sha
        interpolatable: false

      - name: repo_path
        type: string
        required: false
        description: Path to git repository (for pull, fetch, get-sha)
        interpolatable: true

      - name: args
        type: object
        required: false
        description: "Operation-specific args: {url, dest, branch, depth} for clone"
        interpolatable: true

      - name: store_as
        type: string
        required: false
        description: State field for result (for get-sha)
        pattern: "^[a-zA-Z_][a-zA-Z0-9_.\\[\\]]*$"
        interpolatable: false

    payload:
      kind: tool_call
      tool: Bash
      effect: |
        if operation == "clone":
          url = interpolate(args.url)
          dest = interpolate(args.dest)
          cmd = "git clone"
          if args.depth:
            cmd += " --depth " + args.depth
          if args.branch:
            cmd += " --branch " + interpolate(args.branch)
          cmd += " " + url + " " + dest
          Bash(cmd)

        elif operation == "pull":
          Bash("git -C " + interpolate(repo_path) + " pull --ff-only")

        elif operation == "fetch":
          Bash("git -C " + interpolate(repo_path) + " fetch")

        elif operation == "get-sha":
          sha = Bash("git -C " + interpolate(repo_path) + " rev-parse HEAD").trim()
          set_state_value(store_as, sha)
      state_writes:
        - "${store_as}"
      state_reads: []

    since: "3.0.0"
    replaces:
      - clone_repo
      - git_pull
      - git_fetch
      - get_sha

  # ==========================================================================
  # category: extensions/web
  # ==========================================================================

  # --------------------------------------------------------------------------
  # web_ops
  # --------------------------------------------------------------------------
  web_ops:
    category: extensions/web
    description:
      brief: Perform web operations (fetch, cache)
      detail: |
        Unified web operations consequence for fetching and caching web content.
        The operation parameter determines what action is performed.
      notes:
        - "operation: fetch - fetch URL content using WebFetch"
        - "operation: cache - save fetched content to file"
        - HTML is automatically converted to markdown for fetch
        - allow_failure prevents HTTP errors from failing the action

    parameters:
      - name: operation
        type: string
        required: true
        description: "Web operation: fetch, cache"
        enum:
          - fetch
          - cache
        interpolatable: false

      - name: url
        type: string
        required: false
        description: URL to fetch (for fetch operation)
        interpolatable: true

      - name: prompt
        type: string
        required: false
        description: Prompt for WebFetch tool to guide extraction
        interpolatable: true

      - name: allow_failure
        type: boolean
        required: false
        default: false
        description: If true, 4xx/5xx doesn't fail action
        interpolatable: false

      - name: from
        type: string
        required: false
        description: State field with fetch result (for cache operation)
        pattern: "^[a-zA-Z_][a-zA-Z0-9_.\\[\\]]*$"
        interpolatable: false

      - name: dest
        type: string
        required: false
        description: Destination file path (for cache operation)
        interpolatable: true

      - name: store_as
        type: string
        required: false
        description: State field for result
        pattern: "^[a-zA-Z_][a-zA-Z0-9_.\\[\\]]*$"
        interpolatable: false

    payload:
      kind: tool_call
      tool: WebFetch
      effect: |
        if operation == "fetch":
          result = WebFetch(
            url: interpolate(url),
            prompt: interpolate(prompt) ?? "Extract the main content"
          )
          stored_result = {
            status: result.status,
            content: result.content,
            url: interpolate(url)
          }
          if not allow_failure and result.status >= 400:
            throw Error("HTTP " + result.status)
          set_state_value(store_as, stored_result)

        elif operation == "cache":
          fetch_result = get_state_value(from)
          content = fetch_result.content
          resolved_dest = interpolate(dest)
          mkdir -p dirname(resolved_dest)
          write_file(resolved_dest, content)
          if store_as:
            set_state_value(store_as, resolved_dest)
      state_writes:
        - "${store_as}"
      state_reads:
        - "${from}"

    since: "3.0.0"
    replaces:
      - web_fetch
      - cache_web_content

  # ==========================================================================
  # category: extensions/scripting
  # ==========================================================================

  # --------------------------------------------------------------------------
  # run_command
  # --------------------------------------------------------------------------
  run_command:
    category: extensions/scripting
    description:
      brief: Execute script with specified interpreter
      detail: |
        Unified command execution consequence. Executes a script with the
        specified interpreter (or auto-detects from extension).
      notes:
        - "interpreter: bash, python, node, ruby, or auto"
        - "auto mode detects from extension: .py->python3, .sh->bash, .js->node"
        - Args support ${} interpolation
        - Can activate Python venv before execution
        - Can set environment variables

    parameters:
      - name: interpreter
        type: string
        required: false
        default: auto
        description: "Interpreter: auto, bash, python, node, ruby"
        interpolatable: false

      - name: script
        type: string
        required: true
        description: Path to script (relative to repo root)
        interpolatable: true

      - name: args
        type: array
        required: false
        description: Arguments to pass to script
        interpolatable: true

      - name: store_as
        type: string
        required: false
        description: State field for captured output
        pattern: "^[a-zA-Z_][a-zA-Z0-9_.\\[\\]]*$"
        interpolatable: false

      - name: working_directory
        type: string
        required: false
        description: Working directory for script execution
        interpolatable: true

      - name: venv
        type: string
        required: false
        description: Python virtual environment path to activate
        interpolatable: true

      - name: env
        type: object
        required: false
        description: Environment variables to set
        interpolatable: true

    payload:
      kind: tool_call
      tool: Bash
      effect: |
        script_path = interpolate(script)

        # Determine interpreter
        if interpreter == "auto" or interpreter == null:
          extension = script_path.split('.').pop()
          interp = match extension:
            "py" -> "python3"
            "sh" -> "bash"
            "bash" -> "bash"
            "js" -> "node"
            "ts" -> "npx ts-node"
            "rb" -> "ruby"
            _ -> null  # Use shebang
        else:
          interp = interpreter

        # Build command
        cmd = ""

        # Add environment variables
        if env:
          for key, value in env:
            cmd += key + "=" + interpolate(value) + " "

        # Add venv activation
        if venv:
          cmd += "source " + interpolate(venv) + "/bin/activate && "

        # Add interpreter
        cmd += interp ? interp + " " : "./"
        cmd += script_path

        # Add arguments
        if args:
          cmd += " " + args.map(interpolate).join(" ")

        # Add working directory
        if working_directory:
          cmd = "cd " + interpolate(working_directory) + " && " + cmd

        result = Bash(cmd)
        if store_as:
          set_state_value(store_as, result.stdout.trim())
      state_writes:
        - "${store_as}"
      state_reads: []

    since: "3.0.0"
    replaces:
      - run_script
      - run_python
      - run_bash

  # ==========================================================================
  # category: extensions/package
  # ==========================================================================

  # --------------------------------------------------------------------------
  # install_tool
  # --------------------------------------------------------------------------
  install_tool:
    category: extensions/package
    description:
      brief: Install a CLI tool if not already available
      detail: |
        Attempts to install a CLI tool using an appropriate package manager
        or install command. Uses the tool registry for install hints, or
        accepts a custom install command. Skips installation if tool is
        already available.
      notes:
        - Checks if tool is already installed first
        - Uses registry install_hint if no custom command provided
        - Requires network access for installation
        - May require elevated permissions depending on install method

    parameters:
      - name: tool
        type: string
        required: true
        description: Name of the tool to install
        pattern: "^[a-zA-Z0-9_-]+$"
        interpolatable: false

      - name: install_command
        type: string
        required: false
        description: Custom install command (overrides registry hint)
        interpolatable: true

      - name: skip_if_available
        type: boolean
        required: false
        default: true
        description: Skip installation if tool already available
        interpolatable: false

    payload:
      kind: side_effect
      tool: Bash
      effect: |
        # Check if already installed
        if skip_if_available and tool_available(tool):
          return { status: "skipped", message: "Tool already available" }

        # Get install command
        if install_command:
          cmd = interpolate(install_command)
        else:
          hint = registry_lookup(tool, "install_hint")
          if not hint:
            error("No install command for tool: " + tool)
          # Use first option from hint (e.g., "apt install X / brew install X")
          cmd = hint.split(" / ")[0]

        # Execute installation
        result = Bash(cmd)
        if result.exit_code != 0:
          error("Installation failed for " + tool + ": " + result.stderr)

        # Verify installation
        if not tool_available(tool):
          error("Tool not available after installation: " + tool)

        return { status: "installed", message: "Successfully installed " + tool }

      state_writes:
        - computed.install_result
      state_reads: []

    since: "2.0.0"
