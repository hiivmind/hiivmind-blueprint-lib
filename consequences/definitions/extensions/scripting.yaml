# Scripting Extension Consequences
# Execute scripts with interpreter detection

schema_version: "1.1"
category: extensions/scripting
description: Execute repository scripts with automatic interpreter detection

consequences:
  # --------------------------------------------------------------------------
  # run_script
  # --------------------------------------------------------------------------
  - type: run_script
    description:
      brief: Execute script with auto-detected interpreter
      detail: |
        Executes a script file from the repository. Automatically detects the
        interpreter from the file extension (.py → python3, .sh → bash, .js → node).
        Supports argument interpolation and output capture.
      notes:
        - Interpreter auto-detected from extension
        - Script path relative to repo root
        - Args support ${} interpolation
        - Use store_as to capture stdout

    parameters:
      - name: script
        type: string
        required: true
        description: Path to script (relative to repo root)
        interpolatable: true

      - name: args
        type: array
        required: false
        description: Arguments to pass to script
        interpolatable: true

      - name: store_as
        type: string
        required: false
        description: State field for captured output
        pattern: "^[a-zA-Z_][a-zA-Z0-9_.\\[\\]]*$"
        interpolatable: false

      - name: working_directory
        type: string
        required: false
        description: Working directory for script execution
        interpolatable: true

    payload:
      kind: tool_call
      tool: Bash

      requires:
        shell: bash

      provides:
        features:
          - interpreter_detection
          - output_capture
        outputs:
          - field: "${store_as}"
            type: string
            description: "Captured stdout from script"

      effect: |
        script_path = interpolate(script)
        extension = script_path.split('.').pop()

        interpreter = match extension:
          "py" -> "python3"
          "sh" -> "bash"
          "bash" -> "bash"
          "js" -> "node"
          "ts" -> "npx ts-node"
          "rb" -> "ruby"
          _ -> null  # Use shebang

        cmd = interpreter ? interpreter + " " : "./"
        cmd += script_path
        if args:
          cmd += " " + args.map(interpolate).join(" ")

        if working_directory:
          cmd = "cd " + interpolate(working_directory) + " && " + cmd

        result = Bash(cmd)
        if store_as:
          set_state_value(store_as, result.stdout.trim())
      state_writes:
        - "${store_as}"
      state_reads: []

    examples:
      - title: Run Python script with args
        yaml: |
          - type: run_script
            script: "lib/tools/scraper.py"
            args:
              - "--url=${source_url}"
              - "--output=.cache/scraped"
            store_as: computed.scrape_result

      - title: Run shell script
        yaml: |
          - type: run_script
            script: "scripts/build.sh"
            args:
              - "${build_target}"
            working_directory: "${project_root}"

      - title: Run and capture output
        yaml: |
          - type: run_script
            script: "tools/version.py"
            store_as: computed.version

    related:
      - run_python
      - run_bash
    since: "1.1.0"

  # --------------------------------------------------------------------------
  # run_python
  # --------------------------------------------------------------------------
  - type: run_python
    description:
      brief: Execute Python script
      detail: |
        Executes a Python script with python3. Supports virtual environment
        activation, argument passing, and output capture.
      notes:
        - Uses python3 interpreter
        - Optional venv activation
        - Args support ${} interpolation

    parameters:
      - name: script
        type: string
        required: true
        description: Path to Python script
        interpolatable: true

      - name: args
        type: array
        required: false
        description: Arguments to pass
        interpolatable: true

      - name: venv
        type: string
        required: false
        description: Virtual environment path to activate
        interpolatable: true

      - name: store_as
        type: string
        required: false
        description: State field for captured output
        pattern: "^[a-zA-Z_][a-zA-Z0-9_.\\[\\]]*$"
        interpolatable: false

    payload:
      kind: tool_call
      tool: Bash

      requires:
        tools:
          - name: python3
            min_version: "3.9"
            check_command: "python3 --version"

      provides:
        outputs:
          - field: "${store_as}"
            type: string
            description: "Captured stdout"

      effect: |
        cmd = ""
        if venv:
          cmd = "source " + interpolate(venv) + "/bin/activate && "
        cmd += "python3 " + interpolate(script)
        if args:
          cmd += " " + args.map(interpolate).join(" ")

        result = Bash(cmd)
        if store_as:
          set_state_value(store_as, result.stdout.trim())
      state_writes:
        - "${store_as}"
      state_reads: []

    examples:
      - title: Run with venv
        yaml: |
          - type: run_python
            script: "tools/process.py"
            venv: ".venv"
            args:
              - "--input=${input_file}"
              - "--format=json"
            store_as: computed.result

      - title: Simple script execution
        yaml: |
          - type: run_python
            script: "scripts/analyze.py"
            args:
              - "${target_path}"

    related:
      - run_script
      - run_bash
    since: "1.1.0"

  # --------------------------------------------------------------------------
  # run_bash
  # --------------------------------------------------------------------------
  - type: run_bash
    description:
      brief: Execute Bash script
      detail: |
        Executes a Bash script. Supports environment variable injection,
        argument passing, and output capture.
      notes:
        - Uses bash interpreter explicitly
        - Env vars can be set inline
        - Args support ${} interpolation

    parameters:
      - name: script
        type: string
        required: true
        description: Path to Bash script
        interpolatable: true

      - name: args
        type: array
        required: false
        description: Arguments to pass
        interpolatable: true

      - name: env
        type: object
        required: false
        description: Environment variables to set
        interpolatable: true

      - name: store_as
        type: string
        required: false
        description: State field for captured output
        pattern: "^[a-zA-Z_][a-zA-Z0-9_.\\[\\]]*$"
        interpolatable: false

    payload:
      kind: tool_call
      tool: Bash

      requires:
        tools:
          - name: bash
            check_command: "bash --version"

      provides:
        outputs:
          - field: "${store_as}"
            type: string
            description: "Captured stdout"

      effect: |
        cmd = ""
        if env:
          for key, value in env:
            cmd += key + "=" + interpolate(value) + " "
        cmd += "bash " + interpolate(script)
        if args:
          cmd += " " + args.map(interpolate).join(" ")

        result = Bash(cmd)
        if store_as:
          set_state_value(store_as, result.stdout.trim())
      state_writes:
        - "${store_as}"
      state_reads: []

    examples:
      - title: Run with environment variables
        yaml: |
          - type: run_bash
            script: "scripts/deploy.sh"
            env:
              DEPLOY_ENV: "${environment}"
              VERSION: "${computed.version}"
            args:
              - "--target=${target}"

      - title: Simple script execution
        yaml: |
          - type: run_bash
            script: "scripts/setup.sh"
            store_as: computed.setup_output

    related:
      - run_script
      - run_python
    since: "1.1.0"
