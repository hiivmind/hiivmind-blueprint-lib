# hiivmind-blueprint-lib Bundle
# Single-file distribution of all type definitions and reusable workflows
#
# Usage: Reference this file directly in workflows:
#   definitions:
#     source: https://github.com/hiivmind/hiivmind-blueprint-lib/releases/download/v2.0.0/bundle.yaml

package:
  name: hiivmind-blueprint-lib
  version: "2.0.0"
  description: Externalized type definitions and reusable workflows for hiivmind-blueprint
  repository: https://github.com/hiivmind/hiivmind-blueprint-lib
  license: MIT

schemas:
  consequence: "1.1"
  precondition: "1.0"
  node: "1.0"
  workflow: "1.0"

# Statistics
stats:
  total_types: 76
  consequence_types: 44
  precondition_types: 27
  node_types: 5
  core_consequence_types: 31
  extension_consequence_types: 13
  core_precondition_types: 22
  extension_precondition_types: 5
  core_node_types: 5
  workflows: 1
  core_workflows: 1

# ============================================================================
# CONSEQUENCES (43 types)
# ============================================================================

consequences:
  schema_version: "1.1"

  # Master lookup table: type -> category
  type_lookup:
    # Core - State (5)
    set_flag: core/state
    set_state: core/state
    append_state: core/state
    clear_state: core/state
    merge_state: core/state

    # Core - Evaluation (2)
    evaluate: core/evaluation
    compute: core/evaluation

    # Core - Interaction (2)
    display_message: core/interaction
    display_table: core/interaction

    # Core - Control (4)
    create_checkpoint: core/control
    rollback_checkpoint: core/control
    spawn_agent: core/control
    inline: core/control

    # Core - Skill (2)
    invoke_pattern: core/skill
    invoke_skill: core/skill

    # Core - Utility (2)
    set_timestamp: core/utility
    compute_hash: core/utility

    # Core - Intent (4)
    evaluate_keywords: core/intent
    parse_intent_flags: core/intent
    match_3vl_rules: core/intent
    dynamic_route: core/intent

    # Core - Logging (10)
    init_log: core/logging
    log_node: core/logging
    log_event: core/logging
    log_warning: core/logging
    log_error: core/logging
    log_session_snapshot: core/logging
    finalize_log: core/logging
    write_log: core/logging
    apply_log_retention: core/logging
    output_ci_summary: core/logging

    # Extensions - File System (4)
    read_file: extensions/file-system
    write_file: extensions/file-system
    create_directory: extensions/file-system
    delete_file: extensions/file-system

    # Extensions - Git (4)
    clone_repo: extensions/git
    get_sha: extensions/git
    git_pull: extensions/git
    git_fetch: extensions/git

    # Extensions - Web (2)
    web_fetch: extensions/web
    cache_web_content: extensions/web

    # Extensions - Scripting (3)
    run_script: extensions/scripting
    run_python: extensions/scripting
    run_bash: extensions/scripting

  # Categories with brief descriptions
  categories:
    core/state:
      description: State mutation operations
      types: [set_flag, set_state, append_state, clear_state, merge_state]

    core/evaluation:
      description: Expression evaluation and computation
      types: [evaluate, compute]

    core/interaction:
      description: User interaction and display
      types: [display_message, display_table]

    core/control:
      description: Control flow, checkpoints, and inline execution
      types: [create_checkpoint, rollback_checkpoint, spawn_agent, inline]

    core/skill:
      description: Skill and pattern invocation
      types: [invoke_pattern, invoke_skill]

    core/utility:
      description: Utility operations
      types: [set_timestamp, compute_hash]

    core/intent:
      description: 3VL intent detection and routing
      types:
        [evaluate_keywords, parse_intent_flags, match_3vl_rules, dynamic_route]

    core/logging:
      description: Workflow execution logging
      types:
        [
          init_log,
          log_node,
          log_event,
          log_warning,
          log_error,
          log_session_snapshot,
          finalize_log,
          write_log,
          apply_log_retention,
          output_ci_summary,
        ]

    extensions/file-system:
      description: File system operations
      types: [read_file, write_file, create_directory, delete_file]

    extensions/git:
      description: Git repository operations
      types: [clone_repo, get_sha, git_pull, git_fetch]

    extensions/web:
      description: Web fetch and caching
      types: [web_fetch, cache_web_content]

    extensions/scripting:
      description: Script execution with interpreter detection
      types: [run_script, run_python, run_bash]

  # Type signatures (minimal for validation, full definitions in separate files)
  types:
    # --- Core State ---
    set_flag:
      brief: Set a boolean flag
      parameters:
        - { name: flag, type: string, required: true }
        - { name: value, type: boolean, required: true }
      payload: { kind: state_mutation }

    set_state:
      brief: Set any state field
      parameters:
        - { name: field, type: string, required: true }
        - { name: value, type: any, required: true }
      payload: { kind: state_mutation }

    append_state:
      brief: Append value to array field
      parameters:
        - { name: field, type: string, required: true }
        - { name: value, type: any, required: true }
      payload: { kind: state_mutation }

    clear_state:
      brief: Reset field to null
      parameters:
        - { name: field, type: string, required: true }
      payload: { kind: state_mutation }

    merge_state:
      brief: Merge object into state field
      parameters:
        - { name: field, type: string, required: true }
        - { name: value, type: object, required: true }
      payload: { kind: state_mutation }

    # --- Core Evaluation ---
    evaluate:
      brief: Evaluate expression and set flag based on result
      parameters:
        - { name: expression, type: string, required: true }
        - { name: set_flag, type: string, required: true }
      payload: { kind: computation }

    compute:
      brief: Run expression and store result
      parameters:
        - { name: expression, type: string, required: true }
        - { name: store_as, type: string, required: true }
      payload: { kind: computation }

    # --- Core Interaction ---
    display_message:
      brief: Show message to user
      parameters:
        - { name: message, type: string, required: true }
      payload: { kind: side_effect }

    display_table:
      brief: Show tabular data to user
      parameters:
        - { name: headers, type: array, required: true }
        - { name: rows, type: any, required: true }
        - { name: title, type: string, required: false }
      payload: { kind: side_effect }

    # --- Core Control ---
    create_checkpoint:
      brief: Save state snapshot for potential rollback
      parameters:
        - { name: name, type: string, required: true }
      payload: { kind: state_mutation }

    rollback_checkpoint:
      brief: Restore state from checkpoint
      parameters:
        - { name: name, type: string, required: true }
      payload: { kind: state_mutation }

    spawn_agent:
      brief: Launch a Task agent for parallel work
      parameters:
        - { name: subagent_type, type: string, required: true }
        - { name: prompt, type: string, required: true }
        - { name: store_as, type: string, required: true }
        - { name: run_in_background, type: boolean, required: false }
      payload: { kind: tool_call, tool: Task }

    inline:
      brief: Execute embedded pseudocode for non-reusable logic
      parameters:
        - { name: description, type: string, required: true }
        - { name: pseudocode, type: string, required: true }
        - { name: store_as, type: string, required: false }
        - { name: state_reads, type: array, required: false }
        - { name: state_writes, type: array, required: false }
      payload: { kind: computation }

    # --- Core Skill ---
    invoke_pattern:
      brief: Execute a pattern document section
      parameters:
        - { name: path, type: string, required: true }
        - { name: section, type: string, required: false }
        - { name: context, type: object, required: false }
      payload: { kind: composite }

    invoke_skill:
      brief: Invoke another skill and wait for completion
      parameters:
        - { name: skill, type: string, required: true }
        - { name: args, type: string, required: false }
      payload: { kind: tool_call, tool: Skill }

    # --- Core Utility ---
    set_timestamp:
      brief: Set current ISO timestamp
      parameters:
        - { name: store_as, type: string, required: true }
      payload: { kind: computation }

    compute_hash:
      brief: Compute SHA-256 hash of content
      parameters:
        - { name: from, type: string, required: true }
        - { name: store_as, type: string, required: true }
      payload: { kind: computation }

    # --- Core Intent ---
    evaluate_keywords:
      brief: Match keywords to detect intent
      parameters:
        - { name: input, type: string, required: true }
        - { name: keyword_sets, type: object, required: true }
        - { name: store_as, type: string, required: true }
      payload: { kind: computation }

    parse_intent_flags:
      brief: Parse 3VL flags from user input
      parameters:
        - { name: input, type: string, required: true }
        - { name: flag_definitions, type: object, required: true }
        - { name: store_as, type: string, required: true }
      payload: { kind: computation }

    match_3vl_rules:
      brief: Match 3VL flags against rule table
      parameters:
        - { name: flags, type: object, required: true }
        - { name: rules, type: array, required: true }
        - { name: store_as, type: string, required: true }
      payload: { kind: computation }

    dynamic_route:
      brief: Execute dynamically determined node transition
      parameters:
        - { name: action, type: string, required: true }
      payload: { kind: state_mutation }

    # --- Core Logging ---
    init_log:
      brief: Initialize log structure with workflow metadata
      parameters:
        - { name: workflow_name, type: string, required: true }
        - { name: workflow_version, type: string, required: false }
        - { name: skill_name, type: string, required: false }
        - { name: plugin_name, type: string, required: false }
        - { name: execution_path, type: string, required: false }
      payload: { kind: composite }

    log_node:
      brief: Record node execution in history
      parameters:
        - { name: node, type: string, required: true }
        - { name: outcome, type: string, required: true }
        - { name: details, type: object, required: false }
      payload: { kind: state_mutation }

    log_event:
      brief: Log domain-specific event
      parameters:
        - { name: event_type, type: string, required: true }
        - { name: data, type: object, required: false }
        - { name: level, type: string, required: false }
      payload: { kind: state_mutation }

    log_warning:
      brief: Add warning message to log
      parameters:
        - { name: message, type: string, required: true }
        - { name: context, type: object, required: false }
        - { name: node, type: string, required: false }
      payload: { kind: state_mutation }

    log_error:
      brief: Add error with context to log
      parameters:
        - { name: message, type: string, required: true }
        - { name: error_type, type: string, required: false }
        - { name: context, type: object, required: false }
        - { name: node, type: string, required: false }
        - { name: recoverable, type: boolean, required: false }
      payload: { kind: state_mutation }

    log_session_snapshot:
      brief: Record mid-session checkpoint
      parameters:
        - { name: description, type: string, required: true }
        - { name: write_intermediate, type: boolean, required: false }
        - { name: node, type: string, required: false }
      payload: { kind: composite }

    finalize_log:
      brief: Complete log with timing and outcome
      parameters:
        - { name: outcome, type: string, required: true }
        - { name: ending_node, type: string, required: false }
        - { name: summary, type: string, required: false }
      payload: { kind: state_mutation }

    write_log:
      brief: Write log to file
      parameters:
        - { name: format, type: string, required: false }
        - { name: path, type: string, required: false }
        - { name: include_node_history, type: boolean, required: false }
        - { name: include_events, type: boolean, required: false }
      payload: { kind: side_effect }

    apply_log_retention:
      brief: Clean up old log files
      parameters:
        - { name: path, type: string, required: true }
        - { name: strategy, type: string, required: true }
        - { name: days, type: number, required: false }
        - { name: count, type: number, required: false }
        - { name: pattern, type: string, required: false }
      payload: { kind: side_effect }

    output_ci_summary:
      brief: Format output for CI environments
      parameters:
        - { name: format, type: string, required: false }
        - { name: annotations, type: boolean, required: false }
        - { name: output_file, type: string, required: false }
      payload: { kind: side_effect }

    # --- Extensions - File System ---
    read_file:
      brief: Read arbitrary file content
      parameters:
        - { name: path, type: string, required: true }
        - { name: store_as, type: string, required: true }
      payload: { kind: tool_call, tool: Read }

    write_file:
      brief: Write content to file
      parameters:
        - { name: path, type: string, required: true }
        - { name: content, type: string, required: true }
      payload: { kind: tool_call, tool: Write }

    create_directory:
      brief: Create directory including parents
      parameters:
        - { name: path, type: string, required: true }
      payload: { kind: tool_call, tool: Bash }

    delete_file:
      brief: Delete file if exists
      parameters:
        - { name: path, type: string, required: true }
      payload: { kind: tool_call, tool: Bash }

    # --- Extensions - Git ---
    clone_repo:
      brief: Clone git repository
      parameters:
        - { name: url, type: string, required: true }
        - { name: dest, type: string, required: true }
        - { name: branch, type: string, required: false }
        - { name: depth, type: number, required: false }
      payload: { kind: tool_call, tool: Bash }

    get_sha:
      brief: Get HEAD commit SHA
      parameters:
        - { name: repo_path, type: string, required: true }
        - { name: store_as, type: string, required: true }
      payload: { kind: tool_call, tool: Bash }

    git_pull:
      brief: Pull latest changes
      parameters:
        - { name: repo_path, type: string, required: true }
      payload: { kind: tool_call, tool: Bash }

    git_fetch:
      brief: Fetch remote refs
      parameters:
        - { name: repo_path, type: string, required: true }
      payload: { kind: tool_call, tool: Bash }

    # --- Extensions - Web ---
    web_fetch:
      brief: Fetch URL content
      parameters:
        - { name: url, type: string, required: true }
        - { name: store_as, type: string, required: true }
        - { name: allow_failure, type: boolean, required: false }
        - { name: prompt, type: string, required: false }
      payload: { kind: tool_call, tool: WebFetch }

    cache_web_content:
      brief: Save fetched content to cache
      parameters:
        - { name: from, type: string, required: true }
        - { name: dest, type: string, required: true }
        - { name: store_path_as, type: string, required: false }
      payload: { kind: composite }

    # --- Extensions - Scripting ---
    run_script:
      brief: Execute script with auto-detected interpreter
      parameters:
        - { name: script, type: string, required: true }
        - { name: args, type: array, required: false }
        - { name: store_as, type: string, required: false }
        - { name: working_directory, type: string, required: false }
      payload: { kind: tool_call, tool: Bash }

    run_python:
      brief: Execute Python script
      parameters:
        - { name: script, type: string, required: true }
        - { name: args, type: array, required: false }
        - { name: venv, type: string, required: false }
        - { name: store_as, type: string, required: false }
      payload: { kind: tool_call, tool: Bash }

    run_bash:
      brief: Execute Bash script
      parameters:
        - { name: script, type: string, required: true }
        - { name: args, type: array, required: false }
        - { name: env, type: object, required: false }
        - { name: store_as, type: string, required: false }
      payload: { kind: tool_call, tool: Bash }

# ============================================================================
# PRECONDITIONS (27 types)
# ============================================================================

preconditions:
  schema_version: "1.0"

  # Master lookup table: type -> category
  type_lookup:
    # Core - Filesystem (5)
    config_exists: core/filesystem
    index_exists: core/filesystem
    index_is_placeholder: core/filesystem
    file_exists: core/filesystem
    directory_exists: core/filesystem

    # Core - State (8)
    flag_set: core/state
    flag_not_set: core/state
    state_equals: core/state
    state_not_null: core/state
    state_is_null: core/state
    count_equals: core/state
    count_above: core/state
    count_below: core/state

    # Core - Tool (2)
    tool_available: core/tool
    python_module_available: core/tool

    # Core - Composite (3)
    all_of: core/composite
    any_of: core/composite
    none_of: core/composite

    # Core - Expression (1)
    evaluate_expression: core/expression

    # Core - Logging (3)
    log_initialized: core/logging
    log_level_enabled: core/logging
    log_finalized: core/logging

    # Extensions - Source (3)
    source_exists: extensions/source
    source_cloned: extensions/source
    source_has_updates: extensions/source

    # Extensions - Web (2)
    fetch_succeeded: extensions/web
    fetch_returned_content: extensions/web

  # Categories with brief descriptions
  categories:
    core/filesystem:
      description: File and directory existence checks
      types:
        [
          config_exists,
          index_exists,
          index_is_placeholder,
          file_exists,
          directory_exists,
        ]

    core/state:
      description: State inspection and comparison
      types:
        [
          flag_set,
          flag_not_set,
          state_equals,
          state_not_null,
          state_is_null,
          count_equals,
          count_above,
          count_below,
        ]

    core/tool:
      description: Tool and module availability
      types: [tool_available, python_module_available]

    core/composite:
      description: Logical composition (AND, OR, NOR)
      types: [all_of, any_of, none_of]

    core/expression:
      description: Arbitrary expression evaluation
      types: [evaluate_expression]

    core/logging:
      description: Logging lifecycle checks
      types: [log_initialized, log_level_enabled, log_finalized]

    extensions/source:
      description: Source repository checks
      types: [source_exists, source_cloned, source_has_updates]

    extensions/web:
      description: Web fetch result verification
      types: [fetch_succeeded, fetch_returned_content]

  # Type signatures (minimal for validation, full definitions in separate files)
  types:
    # --- Core Filesystem ---
    config_exists:
      brief: Check if corpus config.yaml exists
      parameters: []

    index_exists:
      brief: Check if corpus index.md exists
      parameters: []

    index_is_placeholder:
      brief: Check if index contains placeholder text
      parameters: []

    file_exists:
      brief: Check if arbitrary file exists
      parameters:
        - { name: path, type: string, required: true }

    directory_exists:
      brief: Check if directory exists
      parameters:
        - { name: path, type: string, required: true }

    # --- Core State ---
    flag_set:
      brief: Check if a boolean flag is true
      parameters:
        - { name: flag, type: string, required: true }

    flag_not_set:
      brief: Check if a boolean flag is false or undefined
      parameters:
        - { name: flag, type: string, required: true }

    state_equals:
      brief: Check if state field equals specific value
      parameters:
        - { name: field, type: string, required: true }
        - { name: value, type: any, required: true }

    state_not_null:
      brief: Check if state field has a value
      parameters:
        - { name: field, type: string, required: true }

    state_is_null:
      brief: Check if state field is null or undefined
      parameters:
        - { name: field, type: string, required: true }

    count_equals:
      brief: Check if array length equals value
      parameters:
        - { name: field, type: string, required: true }
        - { name: count, type: number, required: true }

    count_above:
      brief: Check if array length exceeds threshold
      parameters:
        - { name: field, type: string, required: true }
        - { name: min, type: number, required: true }

    count_below:
      brief: Check if array length is below threshold
      parameters:
        - { name: field, type: string, required: true }
        - { name: max, type: number, required: true }

    # --- Core Tool ---
    tool_available:
      brief: Check if CLI tool is available
      parameters:
        - { name: tool, type: string, required: true }

    python_module_available:
      brief: Check if Python module can be imported
      parameters:
        - { name: module, type: string, required: true }

    # --- Core Composite ---
    all_of:
      brief: All nested preconditions must be true (AND)
      parameters:
        - { name: conditions, type: array, required: true }

    any_of:
      brief: At least one nested precondition must be true (OR)
      parameters:
        - { name: conditions, type: array, required: true }

    none_of:
      brief: No nested precondition may be true (NOR)
      parameters:
        - { name: conditions, type: array, required: true }

    # --- Core Expression ---
    evaluate_expression:
      brief: Evaluate arbitrary boolean expression
      parameters:
        - { name: expression, type: string, required: true }

    # --- Core Logging ---
    log_initialized:
      brief: Check if logging has been initialized
      parameters: []

    log_level_enabled:
      brief: Check if log level is enabled
      parameters:
        - { name: level, type: string, required: true }

    log_finalized:
      brief: Check if logging has been finalized
      parameters: []

    # --- Extensions - Source ---
    source_exists:
      brief: Check if source is configured
      parameters:
        - { name: source_id, type: string, required: true }

    source_cloned:
      brief: Check if source has been cloned
      parameters:
        - { name: source_id, type: string, required: true }

    source_has_updates:
      brief: Check if source has upstream changes
      parameters:
        - { name: source_id, type: string, required: true }

    # --- Extensions - Web ---
    fetch_succeeded:
      brief: Check if web fetch returned 2xx status
      parameters:
        - { name: result_field, type: string, required: true }

    fetch_returned_content:
      brief: Check if web fetch returned non-empty content
      parameters:
        - { name: result_field, type: string, required: true }

# ============================================================================
# NODES (5 types)
# ============================================================================

nodes:
  schema_version: "1.0"

  # Master lookup table: type -> category
  type_lookup:
    action: core
    conditional: core
    user_prompt: core
    validation_gate: core
    reference: core

  # Categories
  categories:
    core:
      description: Fundamental node types for workflow execution
      types: [action, conditional, user_prompt, validation_gate, reference]

  # Type signatures (minimal for validation, full definitions in separate files)
  types:
    action:
      brief: Executes operations and routes based on success/failure
      fields:
        - { name: type, type: string, required: true, value: "action" }
        - { name: description, type: string, required: false }
        - { name: actions, type: array, required: true, items: consequence }
        - { name: on_success, type: node_reference, required: true }
        - { name: on_failure, type: node_reference, required: true }

    conditional:
      brief: Branches based on a precondition evaluation
      fields:
        - { name: type, type: string, required: true, value: "conditional" }
        - { name: description, type: string, required: false }
        - { name: condition, type: precondition, required: true }
        - { name: branches, type: object, required: true }

    user_prompt:
      brief: Presents an AskUserQuestion and routes based on response
      fields:
        - { name: type, type: string, required: true, value: "user_prompt" }
        - { name: description, type: string, required: false }
        - { name: prompt, type: object, required: true }
        - { name: on_response, type: object, required: true }
      prompt_fields:
        - { name: question, type: string, required: true }
        - { name: header, type: string, required: true, max_length: 12 }
        - { name: options, type: array, required_unless: options_from_state }
        - { name: options_from_state, type: string, required_unless: options }
        - { name: option_mapping, type: object, required_with: options_from_state }
      on_response_keys:
        static: "{option_id}"
        dynamic: ["selected", "other"]

    validation_gate:
      brief: Runs multiple preconditions; all must pass to proceed
      fields:
        - { name: type, type: string, required: true, value: "validation_gate" }
        - { name: description, type: string, required: false }
        - { name: validations, type: array, required: true }
        - { name: on_valid, type: node_reference, required: true }
        - { name: on_invalid, type: node_reference, required: true }

    reference:
      brief: Loads and executes a reference document section
      fields:
        - { name: type, type: string, required: true, value: "reference" }
        - { name: doc, type: string, required: true }
        - { name: section, type: string, required: false }
        - { name: context, type: object, required: false }
        - { name: next_node, type: node_reference, required: true }

# ============================================================================
# WORKFLOW SCHEMA EXTENSIONS
# ============================================================================

workflow_schema:
  schema_version: "1.1"

  # Endings define terminal states for workflows
  endings:
    description: |
      Terminal states for workflow execution. Nodes route to endings to
      complete the workflow. Each ending defines the outcome type and
      can include a summary for logging/reporting.
    structure:
      additionalProperties:
        type: object
        properties:
          - name: type
            type: string
            required: true
            enum: [success, failure, cancelled]
            description: The outcome type of this ending

          - name: message
            type: string
            required: false
            description: Human-readable message describing the outcome

          - name: summary
            type: object
            required: false
            description: |
              Key-value pairs summarizing the workflow result.
              Values can use ${} interpolation to reference state.
    execution:
      effect: |
        # When a node routes to an ending:
        ending = workflow.endings[ending_id]

        # Build outcome
        outcome = {
          type: ending.type,
          ending_id: ending_id,
          message: interpolate(ending.message),
          summary: {}
        }

        # Interpolate summary values
        if ending.summary:
          for key, expr in ending.summary:
            outcome.summary[key] = interpolate(expr)

        # Log if logging is enabled
        if state._log:
          finalize_log(outcome.type, ending_id, outcome.message)

        return outcome

# ============================================================================
# WORKFLOWS (1 workflow)
# ============================================================================

workflows:
  schema_version: "1.0"

  # Master lookup table
  type_lookup:
    intent-detection: core

  # Categories
  categories:
    core:
      description: Reusable workflows for common patterns
      workflows: [intent-detection]

  # Workflow definitions
  definitions:
    intent-detection:
      name: intent-detection
      version: "1.0.0"
      brief: Reusable 3VL intent detection for dynamic routing
      description: >
        Parses user input into flags, matches against rules, and sets
        computed.matched_action for dynamic routing. Handles disambiguation
        when multiple intents match.

      depends_on:
        consequences:
          - parse_intent_flags
          - match_3vl_rules
          - set_state
        preconditions:
          - evaluate_expression

      inputs:
        - {
            name: arguments,
            type: string,
            required: true,
            description: "User input to parse",
          }
        - {
            name: intent_flags,
            type: object,
            required: true,
            description: "Flag definitions (keywords, negative_keywords)",
          }
        - {
            name: intent_rules,
            type: array,
            required: true,
            description: "Rules with conditions, action, priority",
          }
        - {
            name: fallback_action,
            type: string,
            required: false,
            description: "Action when no rules match (default: show_main_menu)",
          }

      outputs:
        - {
            name: computed.matched_action,
            type: string,
            description: "The action to execute",
          }
        - {
            name: computed.intent_flags,
            type: object,
            description: "Parsed 3VL flag values",
          }
        - {
            name: computed.intent_matches,
            type: object,
            description: "Match results with winner and candidates",
          }

      # Full workflow definition inline for single-file consumption
      workflow:
        initial_state:
          phase: "intent_detection"
          computed:
            matched_action: null
            intent_flags: null
            intent_matches: null

        start_node: check_has_input

        nodes:
          check_has_input:
            type: conditional
            description: Check if user provided input to parse
            condition:
              type: evaluate_expression
              expression: "arguments != null && arguments.trim() != ''"
            branches:
              "true": parse_intent_flags
              "false": use_fallback

          parse_intent_flags:
            type: action
            description: Parse user input into 3VL flags (T/F/U)
            actions:
              - type: parse_intent_flags
                input: "${arguments}"
                flag_definitions: "${intent_flags}"
                store_as: computed.intent_flags
            on_success: match_intent_rules
            on_failure: use_fallback

          match_intent_rules:
            type: action
            description: Match parsed flags against intent rules
            actions:
              - type: match_3vl_rules
                flags: "${computed.intent_flags}"
                rules: "${intent_rules}"
                store_as: computed.intent_matches
            on_success: check_clear_winner
            on_failure: use_fallback

          check_clear_winner:
            type: conditional
            description: Check if there's a clear winner (2+ point lead)
            condition:
              type: evaluate_expression
              expression: "computed.intent_matches.clear_winner == true"
            branches:
              "true": set_winner_action
              "false": check_has_candidates

          set_winner_action:
            type: action
            description: Set the winning rule's action as the matched action
            actions:
              - type: set_state
                field: computed.matched_action
                value: "${computed.intent_matches.winner.action}"
            on_success: success_resolved
            on_failure: use_fallback

          check_has_candidates:
            type: conditional
            description: Check if there are any candidates for disambiguation
            condition:
              type: evaluate_expression
              expression: "computed.intent_matches.top_candidates.length > 0"
            branches:
              "true": show_disambiguation
              "false": use_fallback

          show_disambiguation:
            type: user_prompt
            description: Present top candidates for user selection
            prompt:
              question: "Multiple intents detected. Which did you mean?"
              header: "Clarify"
              options_from_state: computed.intent_matches.top_candidates
              option_mapping:
                id: rule.name
                label: rule.name
                description: rule.description
            on_response:
              selected:
                consequence:
                  - type: set_state
                    field: computed.matched_action
                    value: "${user_responses.show_disambiguation.selected.rule.action}"
                next_node: success_resolved
              other:
                consequence:
                  - type: set_state
                    field: arguments
                    value: "${user_responses.show_disambiguation.text}"
                next_node: parse_intent_flags

          use_fallback:
            type: action
            description: Use fallback action when no rules match
            actions:
              - type: set_state
                field: computed.matched_action
                value: "${fallback_action ?? 'show_main_menu'}"
            on_success: success_resolved
            on_failure: success_resolved

        endings:
          success_resolved:
            type: success
            message: "Intent resolved"
            summary:
              matched_action: "${computed.matched_action}"
              flags_parsed: "${computed.intent_flags != null}"
              clear_winner: "${computed.intent_matches.clear_winner ?? false}"
